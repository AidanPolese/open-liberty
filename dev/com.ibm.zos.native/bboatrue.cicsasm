*ASM CICS(NOPROLOG NOEPILOG SYSEIB,SP)
*/*START OF SPECIFICATIONS ********************************************
*
* DESCRIPTIVE-NAME: WAS z/OS Adapters CICS Task Related User Exit
*                   **** FOR CICS TS 4.1 thru 5.2 ****
*
* CSECT NAME: BBOATRUE
*
* COMPONENT:  boss_adaptor
*
* EYE-CATCHER: none
*
* PROPRIETARY STATEMENT=
* IBM Confidential
* OCO Source Materials
* 5655-I35 (C) Copyright IBM Corp. 2014
* The source code for this program is not published or otherwise
* divested of its trade secrets, irrespective of what has been
* deposited with the U.S. Copyright Office.
* Status = H28W800
*
*
* FUNCTION:  Runs as main resource manager exit for WAS connectors
*            support under CICS Transaction Server
*
* METHOD-OF-ACCESS:
*
* SIZE:
*
* SERIALIZATION: None
*
* DEPENDENCIES: None
*
* EXTERNAL CLASSIFICATION: NONE
* END OF EXTERNAL CLASSIFICATION:
*
*END OF SPECIFICATIONS ***********************************************/
*
* TDK TODO: When it comes time to test all of this in the Liberty ZFAT
*           we are going to need to fluff up a fake tWAS function
*           table and hang it out there, and then see that it gets
*           invoked.  The functions can just return a bogus RC/RSN
*           that we can check for in the application.  It would be
*           better if we could actually drive the tWAS code, but I
*           think this will be impossible from the FAT.
*
         TITLE 'BBOATRUE - WAS Adapters CICS Task-Related user Exit'
         DFHREGS ,                                        @576822A
BBOATRUE AMODE 31
BBOATRUE RMODE ANY
         DFHUEXIT TYPE=XPIENV
BBOATRUE CSECT
         J     Around
         DC    CL8'BBOATRUE'            Module name
         DC    CL8' *OLA3* '            Version marker
         DC    CL10'&SYSDATE '          Asm date
         DC    CL6'&SYSTIME'            Asm time
*
Around   DS    0H
         STM   R14,R12,12(R13)  SAVE REGISTERS
         USING BBOATRUE,R15                                @PM74658C
         LARL  R12,STATICS                                 @PM74658C
         USING STATICS,R12                                 @PM74658C
         DROP  R15                                         @PM74658C
         LR    R3,R1
         USING DFHUEPAR,R3      ADDRESS UE PARAMETER LIST
         L     R8,UEPGAA        ADDRESS GLOBAL Area
         USING BBOACGAA,R8      Map TRUE global work area @576822A
         L     R15,UEPTAA       ADDRESS TASK LOCAL
         ST    R13,4(,R15)      Save caller's R13 in Bkchain
         ST    R15,8(,R13)      Store this new RSA in caller Fwchain
         LR    R13,R15          Set R13 to my RSA@
         USING BBOACTAA,R13                               @576822C
*
* Initialize CTAA.  TAA will be initialized to zeros on first call.
*
         LH    R9,BBOACTAA_VER  Load version of CTAA
         LTR   R9,R9            Is it zero?
         JNZ   CTAAINIT         Already initialized
         MVC   BBOACTAA_EYE,CTAAEYE
         LHI   R9,BBOACTAA_VERSION_1
         STH   R9,BBOACTAA_VER
         LHI   R9,BBOACTAA_MAPPED_LEN
         STH   R9,BBOACTAA_LEN
         LA    R9,DYNA_LEN(R13) Load next available byte
         ST    R9,76(R13)       Store NAB in RSA
         MVC   WOLA64SA+4(4),F4SAEYE  Set up F4SA for 64 bit caller.
         MVC   WOLA64SA+136+4(4),76(R13) Copy NAB from 72 byte RSA
*
* Set trace level from GAA.
*
CTAAINIT L     R9,BBOACGAA_TRACELVLX Get GAA exit trc lvl @576822A
         LTR   R9,R9            Zero? then off            @576822A
         JZ    SKIPTRC                                    @PM74658C
         MVC   TR_HEAD,=CL5'TRACE'                        @576822A
SKIPTRC  DS    0H                                         @576822A
*
* NOTE : !!! CAUTION !!! R10 used by BBOATRC macro.
* NOTE : !!! CAUTION !!! R10 used by BBOATRC macro.
* NOTE : !!! CAUTION !!! R10 used by BBOATRC macro.
*
         L     R11,4(R13)
         L     R11,16(R11)
         ST    R11,TR_WORD1
         BBOATRC TXT=ENTRMSG,VHEX=TR_WORD1,T=TR_HEAD
*
         ST    R3,TR_WORD1
         BBOATRC TXT=R1ADDR,VHEX=TR_WORD1,T=TR_HEAD
*
*---------------------------------------------------------------------
* Figure out which CICS release we're running on.
*---------------------------------------------------------------------
         EXEC  CICS ADDRESS EIB(DFHEIBR)                   
         USING DFHEIBLK,DFHEIBR Use R11 to address EIB       @PM74658C
         EXEC  CICS INQUIRE SYSTEM CICSTSLEVEL(TSLVL)
CHKTSV53 CLC   TSLVL(4),=CL4'0503' Is CICS V5R3?
         JNE   CHKTSV52
         MVC   BASESPAC,XBOABS53
         MVC   INQUIREC,XBOAIC53
         J     FRWDTRUE         
CHKTSV52 CLC   TSLVL(4),=CL4'0502' Is CICS V5R2?
         JNE   CHKTSV51
         MVC   BASESPAC,XBOABS52
         MVC   INQUIREC,XBOAIC52
         J     FRWDTRUE
CHKTSV51 CLC   TSLVL(4),=CL4'0501' Is CICS V5R1?            
         JNE   CHKTSV42         No, check for V42          
         MVC   BASESPAC,XBOABS51
         MVC   INQUIREC,XBOAIC51
         J     FRWDTRUE                              
CHKTSV42 CLC   TSLVL(4),=CL4'0402' Is CICS V4R2?              @711599A
         JNE   CHKTSV41         No, check for V41             @711599A
         MVC   BASESPAC,XBOABS42
         MVC   INQUIREC,XBOAIC42
         J     FRWDTRUE                                       @711599A
CHKTSV41 CLC   TSLVL(4),=CL4'0401' Is CICS V4R1?              @711599A
         JNE   INVTRUE          No, invalid CICS version
         MVC   BASESPAC,XBOABS41
         XC    INQUIREC,INQUIREC
         J     FRWDTRUE                                       @711599A
*---------------------------------------------------------@PI53321
* valid CICS version not found use the most recent
*-----------------------------------------------------
INVTRUE  MVC   BASESPAC,XBOABS53
         MVC   INQUIREC,XBOAIC53
*---------------------------------------------------------------------
* Switch to base space mode
*---------------------------------------------------------------------
FRWDTRUE L     R15,BASESPAC     Load switch to base space
         LR    R9,R3            Save DFHUEPAR in R9
         L     R3,UEPRMSTK      Load kernel stack address
         BASR  R14,R15          Call switch to base space
         LR    R3,R9            Restore DFHUEPAR
*
*---------------------------------------------------------------------
* Identify caller's parameters. If there are none, we make a fast
* exit.
*---------------------------------------------------------------------
         L     R9,UEPHMSA       ADDRESS CALLER'S RSA
         L     R5,24(,R9)       GET CALLER'S R1
         ST    R5,TR_WORD1
         BBOATRC TXT=CALLR1,VHEX=TR_WORD1,T=TR_HEAD
         LTR   R5,R5            PARM1 PRESENT?
         JZ    DONE             ..NO  - DONE                  @PM74658C
*
*
*---------------------------------------------------------------------
* Identify the type of request the exit was driven for.
*---------------------------------------------------------------------
         L     R2,UEPEXN        ADDRESS FUNCTION TYPE
         USING DFHUERTR,R2
*
*---------------------------------------------------------------------
* Is it a task manager call (end of task)? If yes, branch to ENDTASK
*---------------------------------------------------------------------
         CLI   UERTFID,UERTTASK Task manager call?
         JE    ENDTASK          ..YES - Jump to ENDTASK sec  @PM74658C
*
*---------------------------------------------------------------------
* Is it a Syncpoint? If yes, branch to SYNCPT label.
*---------------------------------------------------------------------
         CLI   UERTFID,UERTSYNC SYNCPOINT CALL?
         JE    SYNCPT           ..YES - Jump to syncpoint    @PM74658C
*
*---------------------------------------------------------------------
* Is it an Application call? If yes, continue on. If not an appl call
* then we leave now.
*---------------------------------------------------------------------
         CLI   UERTFID,UERTAPPL APPLICATION CALL?
         JE    APPLCALL         ..YES - Process it           @PM74658C
*
*---------------------------------------------------------------------
* Is it a Context request? If yes, brand to CONTREQ label.    @711599A
*---------------------------------------------------------------------
         CLI   UERTFID,UERTFCON  CONTEXT Management call?     @711599A
         JNE   DONE              ..NO  - Leave                @711599A
         J     CONTREQ           ..YES - Process context cal @PM74658C
         DROP  R2                                             @711599A
*
*---------------------------------------------------------------------
* Make sure to set the interest in CONTEXT calls to support passing
* OLA context over to CICS for inclusion in SMF 110s.         @711599A
*---------------------------------------------------------------------
APPLCALL DS    0H                                             @711599A
         L     R15,INQUIREC     Load inquire current program
         LTR   R15,R15          Did we load the program? (TS 4.2+)
         JZ    SKIPCTXT         No - Skip it.
         LR    R4,R3            Save DFHUEPAR in R4
         L     R3,UEPRMSTK      Load kernel stack address
         BASR  R14,R15          Call inquire current program
         LR    R3,R4            Restore DFHUEPAR
         MVC   CURRPROG,0(R15)  Copy current program name
         LR    R4,R0            Can't use base/disp on R0
         MVC   INVKPROG,0(R4)   Copy invoking program name
*
         BBOATRC TXT=CURRNAME,VSTR=CURRPROG,VL=8,T=TR_HEAD
         BBOATRC TXT=INVKNAME,VSTR=INVKPROG,VL=8,T=TR_HEAD
*
         CLC   INVKPROG(8),LINKSRVR Is it the link server?    @711599A
         JNE   SKIPCTXT                                       @711599A
         L     R6,UEPFLAGS          Address sched. flag word  @711599A
         OI    UEFDCON(R6),UEFMCON  We want CONTEXT calls     @711599A
         BBOATRC TXT=SETCNTX,T=TR_HEAD
*
*---------------------------------------------------------------------
* Check the RSA FWD pointer (RSA+8) for the address of one of our
* routines. We save the entry address of a routine in appl R13+8
* in our stub code (ie: BBOA1INV).
*---------------------------------------------------------------------
SKIPCTXT DS    0H                                             @711599A
         L     R6,8(,R9)        Get addr of the target entry
         LTR   R6,R6            No BBOA1 routine EPA present?
         JZ    DONE             ..NO  - DONE                  @PM74658C
         MVC   STB(8),4(R6)            Copy target routine name
         XC    8(4,R9),8(R9)    Clear the RSA FWD pointer
*
         ST    R6,TR_WORD1
         BBOATRC TXT=CALLSTB@,VHEX=TR_WORD1,T=TR_HEAD
*
*---------------------------------------------------------------------
* Get some storage to build an extra parameter area that we'll use to
* pass some CICS-specific things to the WOLA authorized routines.
* TODO: When we support transaction propagation, we'll need to save
*       something that we can use in the syncpoint exit to find our
*       way to the Liberty WOLA PC routines.
*---------------------------------------------------------------------
         LA    R6,PC1PRM    Get some storage for PC parms
         ST    R6,PC1PRMA   Save addr of parm area for tWAS stubs
         USING BBOAPC1P,R6
*----------------------------------------------------------------------
* If we end up calling tWAS, we'll need to save the PC number that we
* used so that if we're called later for syncpoint, we know where to
* go.  Set the addresses where the PC number should be stored.
*----------------------------------------------------------------------
         LA    R7,BBOACGAA_PCNUM_TWAS Get addr of cached PC number
         ST    R7,BBOAPC1P_GAA_PCNUM@ and Save it in PC1P
         LA    R7,BBOACTAA_PCNUM_TWAS Get addr of cached PC number
         ST    R7,BBOAPC1P_TAA_PCNUM@ and Save it in PC1P
*----------------------------------------------------------------------
* Retrieve UOW ID and save it in BBOAPC1P parm buffer.
*----------------------------------------------------------------------
         L     R9,UEPURID       Load address of UOW ID
         LTR   R9,R9            PRESENT?
         JZ    DONE             ..NO  - DONE (TODO - error)
         MVC   BBOAPC1P_UOW,0(R9) Store UOW ID into PC parms
         L     R9,UEPFLAGS      Load schedule flag word
         OI    UEFDSYNC(R9),UEFMSYNC Set syncpoint manager bit in case
*                               the PC routine abends.  CICS will call
*                               us to backout the UR.
         OI    UEFDTASK(R9),UEFMTASK Set task manager bit for end of
*                               task call
*
*----------------------------------------------------------------------
* Retrieve PB Token and save it in BBOAPC1P parm buffer.
*----------------------------------------------------------------------
         L     R9,UEPPBTOK      Load address of PB token
         LTR   R9,R9            PRESENT?
         JZ    NOPBTOK          ..NO  - Dont' copy it
         MVC   BBOAPC1P_PBT,0(R9) Store PB Token into PC parms
*
NOPBTOK  DS    0H
*
*----------------------------------------------------------------------
* Retrieve ACEE address and save it in BBOAPC1P parm buffer.
*----------------------------------------------------------------------
         L     R1,UEPSECBLK     Get CICS app's ACEE addr@ @LI4798-02A
         L     R1,0(,R1)        Get CICS app's ACEE addr  @LI4798-02A
         ST    R1,BBOAPC1P_ACEE Save it in PC parm list   @LI4798-02A
*----------------------------------------------------------------------
* Retrieve requested trace settings
*----------------------------------------------------------------------
         L     R7,BBOACGAA_TRACELVL  Get trace enabled setting @577271A
         ST    R7,BBOAPC1P_TRACELVL  Save trace enabled setting@577271A
*----------------------------------------------------------------------
* Clear flags in BBOAPC1P, and API RC/RSN.  Clear out the 64 bit save
* area in preparation for clearing the high halves of the registers
* and switching to 64 bit mode.
*----------------------------------------------------------------------
         XC    BBOAPC1P_FLG,BBOAPC1P_FLG
         XC    BBOA1_RC,BBOA1_RC
         XC    BBOA1_RN,BBOA1_RN
*----------------------------------------------------------------------
* Find master BGVT and save stub table pointer                @F003703A
*----------------------------------------------------------------------
         L     R7,X'10'                 Load CVT              @F003703A
         USING CVT,R7                                         @F003703A
         L     R7,CVTECVT               Load ECVT             @F003703A
         DROP  R7                                             @F003703A
         USING ECVT,R7                                        @F003703A
         ICM   R7,B'1111',ECVTBCBA      Load master/glbl BGVT @F003703A
         DROP  R7                                             @F003703A
         JNZ   GETAMCST                                       @F003703A
         LHI   R7,BBOAAPI_RC_SEVERE12                         @F003703A
         ST    R7,BBOA1_RC                                    @F003703A
         LHI   R7,BBOAAPI_RSN_NO_BCBA                         @F003703A
         ST    R7,BBOA1_RN                                    @F003703A
         J     FINDFCN                                        @F003703A
         USING BGVT,R7                                        @F003703A
GETAMCST ICM   R7,B'1111',BBODBGVT_BBOAMCST_PTR Load client stub tbl
         DROP  R7                                             @F003703A
         JNZ   GETAMCSS                                       @F003703A
         LHI   R7,BBOAAPI_RC_SEVERE12                         @F003703A
         ST    R7,BBOA1_RC                                    @F003703A
         LHI   R7,BBOAAPI_RSN_NO_AMCST                        @F003703A
         ST    R7,BBOA1_RN                                    @F003703A
         J     FINDFCN                                        @F003703A
         USING BBOAMCST,R7                                    @F003703A
GETAMCSS L     R9,AMCST_SLOTS Load first slot (tWAS)
         ICM   R7,B'1111',AMCST_SLOTS+4 Load second slot      @F003703A
         DROP  R7                                             @F003703A
         JNZ   GETAVEC                                        @F003703A
         J     GETTWAS
         USING BBOAMCSS,R7                                    @F003703A
GETAVEC  L     R7,AMCSS_VECTOR_PTR      Load client vec table @F003703A
         ST    R7,VECTPTR                                     @F003703A
GETTWAS  LTR   R7,R9 Move tWAS slot into R7
         JZ    NOTWAS
         L     R7,AMCSS_VECTOR_PTR      Load tWAS client vec table
         ST    R7,VECTTPTR
         J     FINDFCN
         DROP  R7                                             @F003703A
NOTWAS   CLC   VECTTPTR,VECTPTR  tWAS slot is empty, is Liberty empty?
         JNZ   FINDFCN           No, we have at least one good slot.
         LHI   R7,BBOAAPI_RC_SEVERE12
         ST    R7,BBOA1_RC
         LHI   R7,BBOAAPI_RSN_NO_AMCSS
         ST    R7,BBOA1_RN
*
* We are looking at each entry point and deciding where to go
* below.
*
FINDFCN  XC    WOLA64P,WOLA64P         Clear storage for 64 bit parms
         LA    R7,WOLA64P
*
         BBOATRC TXT=CALLSTUB,T=TR_HEAD,VSTR=STB,VL=8
         CLC   STB(8),=CL8'BBOASREG'   Is it Register?        @F003703A
         JE    REG_Stub                                       @PM74658C
         CLC   STB(8),=CL8'BBOASINV'   Is it Invoke?          @F003703A
         JE    INV_Stub                                       @PM74658C
         CLC   STB(8),=CL8'BBOASURG'   Is it Unregister?      @F003703A
         JE    URG_Stub                                       @PM74658C
         CLC   STB(8),=CL8'BBOASSRV'   Is it Host Service?    @F003703A
         JE    SRV_Stub                                       @PM74658C
         CLC   STB(8),=CL8'BBOASCNG'   Is it Conn. Get?       @F003703A
         JE    CNG_Stub                                       @PM74658C
         CLC   STB(8),=CL8'BBOASCNR'   Is it Conn. Rel?       @F003703A
         JE    CNR_Stub                                       @PM74658C
         CLC   STB(8),=CL8'BBOASSRQ'   Is it Send Req.?       @F003703A
         JE    SRQ_Stub                                       @PM74658C
         CLC   STB(8),=CL8'BBOASGET'   Is it Get data?        @F003703A
         JE    GET_Stub                                       @PM74658C
         CLC   STB(8),=CL8'BBOASGTX'   Is it Get context?     @F003703A
         JE    GTX_Stub                                       @PM74658C
         CLC   STB(8),=CL8'BBOASSRP'   Is it Send Resp.?      @F003703A
         JE    SRP_Stub                                       @PM74658C
         CLC   STB(8),=CL8'BBOASSRX'   Is it Send Resp. Exc.? @F003703A
         JE    SRX_Stub                                       @PM74658C
         CLC   STB(8),=CL8'BBOASRCA'   Is it Receive Req Any? @F003703A
         JE    RCA_Stub                                       @PM74658C
         CLC   STB(8),=CL8'BBOASRCS'   Is it Receive Req Spec?@F003703A
         JE    RCS_Stub                                       @PM74658C
         CLC   STB(8),=CL8'BBOASRCL'   Is it Receive Resp len?@F003703A
         JE    RCL_Stub                                       @PM74658C
         CLC   STB(8),=CL8'BBOASINF'  Is it Get Adapters info?@F003703A
         JE    INF_Stub                                       @PM74658C
* TDK TODO: Think about putting a BBOA1* check here to detect WAS70
*           callers, and issue a specific RC/RSN to help them figure
*           out that case.
         BBOATRC TXT=BADSTUB,T=TR_HEAD
         J     Done                                           @PM74658C
*
*----------------------------------------------------------------------
* Below we're copying the caller's parms into a 64 bit parameter list,
* and adding the CICS specific parameter struct.  We'll call the 64
* bit metal C stubs next.
*----------------------------------------------------------------------
REG_Stub DS    0H
         USING WOLA_CLIENT_REGISTER_PARMS,R7
         USING BBOA1REG_PLIST,R5
         ICM   R2,B'1111',BBOA1_RC
         JNZ   REG_Err
         MVC   WOLA_CLIENT_REGISTER_GROUP+4(4),BBOA1REG_GROUP
         MVC   WOLA_CLIENT_REGISTER_WOLA2+4(4),BBOA1REG_NODE
         MVC   WOLA_CLIENT_REGISTER_WOLA3+4(4),BBOA1REG_SERVER
         MVC   WOLA_CLIENT_REGISTER_NAME+4(4),BBOA1REG_REGNAME
         MVC   WOLA_CLIENT_REGISTER_MINCONN+4(4),BBOA1REG_MINCONN
         MVC   WOLA_CLIENT_REGISTER_MAXCONN+4(4),BBOA1REG_MAXCONN
         MVC   WOLA_CLIENT_REGISTER_FLAGS+4(4),BBOA1REG_REGFLAGS
         ST    R6,WOLA_CLIENT_REGISTER_CICSPRM+4
         MVC   WOLA_CLIENT_REGISTER_RC+4(4),BBOA1REG_RC
         MVC   WOLA_CLIENT_REGISTER_RSN+4(4),BBOA1REG_RSN
         NI    WOLA_CLIENT_REGISTER_RSN+4,127 Clear high bit
         STMH  R0,R15,WOLA64HH   Store high halves of registers
         LMH   R0,R15,ZEROES     Clear high halves of registers
         ICM   R15,B'1111',VECTPTR
         JZ    REG_TWAS          No Liberty register, try tWAS.
         USING BBOAXVEC,R15
         LG    R15,AVECCREG
         DROP  R15
         LR    R9,R13            Save CTAA address
         LA    R13,WOLA64SA      Load F4SA address for caller
         LR    R1,R7             Place our 64 bit parm list in R1
         SAM64                   Switch to 64 bit mode.
         BASR  R14,R15           Call into BBOAREG
         SAM31                   Switch back to 31 bit mode
         LR    R13,R9            Restore CTAA address
         LMH   R0,R15,WOLA64HH   Restore high halves of registers
         DROP  R7
*
* Check the return code from register.  If we couldn't find the WOLA
* group, try the tWAS version.
*
         L     R2,BBOA1REG_RC    Load address of BBOA1REG RC
         LHI   R14,BBOAAPI_RC_SEVERE12
         C     R14,0(R2)         Is it RC=12
         JNZ   After_API         Not RC=12, continue
         L     R2,BBOA1REG_RSN   Load address of BBOA1REG RSN
         LHI   R14,BBOAAPI_RSN_BADBGVT
         CH    R14,2(R2)         Is it RSN=10 No WOLA group?
         JNZ   After_API         Not RSN=10, continue
REG_TWAS MVC   0(BBOA1REG_PC1PRM-BBOA1REG_PLIST,R7),0(R5)   Copy PLIST
         LA    R2,PC1PRMA
         ST    R2,BBOA1REG_PC1PRM-BBOA1REG_PLIST(R7)        Copy PLIST
         ICM   R15,B'1111',VECTTPTR Load tWAS function vector
         JZ    After_API         If no tWAS vector, report orig. error
         USING BBOAXVEC_TWAS,R15
         L     R15,AVECTWAS_REG@ Load register function
         DROP  R15
         LR    R1,R7             Place our updated PLIST in R1
         BASR  R14,R15             and call into BBOAREG
         J     After_API
REG_Err  L     R2,BBOA1REG_RC
         MVC   0(4,R2),BBOA1_RC
         L     R2,BBOA1REG_RSN
         MVC   0(4,R2),BBOA1_RN
         DROP  R5
         J     Done
*
INV_Stub DS    0H
         USING WOLA_CLIENT_INVOKE_PARMS,R7
         USING BBOA1INV_PLIST,R5
         ICM   R2,B'1111',BBOA1_RC
         JNZ   INV_Err
         MVC   WOLA_CLIENT_INVOKE_REGNAME+4(4),BBOA1INV_REGNAME
         MVC   WOLA_CLIENT_INVOKE_REQTYPE+4(4),BBOA1INV_REQTYPE
         MVC   WOLA_CLIENT_INVOKE_SERVNAME+4(4),BBOA1INV_SERVNAME
         MVC   WOLA_CLIENT_INVOKE_SERVNAMEL+4(4),BBOA1INV_SERVNAMEL
         L     R2,BBOA1INV_REQDATA   Change ptr-to-ptr to ptr
         MVC   WOLA_CLIENT_INVOKE_REQDATA+4(4),0(R2)
         MVC   WOLA_CLIENT_INVOKE_REQDATAL+4(4),BBOA1INV_REQDATAL
         L     R2,BBOA1INV_RSPDATA   Change ptr-to-ptr to ptr
         MVC   WOLA_CLIENT_INVOKE_RSPDATA+4(4),0(R2)
         MVC   WOLA_CLIENT_INVOKE_RSPDATAL+4(4),BBOA1INV_RSPDATAL
         MVC   WOLA_CLIENT_INVOKE_WAITTIME+4(4),BBOA1INV_WAITTIME@
         ST    R6,WOLA_CLIENT_INVOKE_CICSPRM+4
         MVC   WOLA_CLIENT_INVOKE_RC+4(4),BBOA1INV_RC
         MVC   WOLA_CLIENT_INVOKE_RSN+4(4),BBOA1INV_RSN
         MVC   WOLA_CLIENT_INVOKE_RV+4(4),BBOA1INV_RVAL
         NI    WOLA_CLIENT_INVOKE_RV+4,127 Clear high bit
         STMH  R0,R15,WOLA64HH   Store high halves of registers
         LMH   R0,R15,ZEROES     Clear high halves of registers
         ICM   R15,B'1111',VECTPTR Is Liberty vector present?
         JZ    INV_TWAS          No... try tWAS version.
         USING BBOAXVEC,R15
         LG    R15,AVECCINV
         DROP  R15
         LR    R9,R13            Save CTAA address
         LA    R13,WOLA64SA      Load F4SA address for caller
         LR    R1,R7             Place our 64 bit parm list in R1
         SAM64                   Switch to 64 bit mode.
         BASR  R14,R15           Call into BBOAINV
         SAM31                   Switch back to 31 bit mode
         LR    R13,R9            Restore CTAA address
         LMH   R0,R15,WOLA64HH   Restore high halves of registers
         DROP  R7
         L     R2,BBOA1INV_RC    Load address of BBOA1INV RC
         LHI   R14,BBOAAPI_RC_ERROR8
         C     R14,0(R2)         Is it RC=8
         JNZ   After_API         Not RC=8, continue
         L     R2,BBOA1INV_RSN   Load address of BBOA1INV RSN
         LHI   R14,WOLA_RSN_INTERNAL_TRY_TWAS_STUB
         CH    R14,2(R2)         Is this a tWAS registration?
         JNZ   After_API         Nope, don't try tWAS version
INV_TWAS DS    0H                Assume tWAS since not Liberty
         MVC   0(BBOA1INV_PC1PRM-BBOA1INV_PLIST,R7),0(R5)   Copy PLIST
         LA    R2,PC1PRMA
         ST    R2,BBOA1INV_PC1PRM-BBOA1INV_PLIST(R7)        Copy PLIST
         ICM   R15,B'1111',VECTTPTR Load tWAS function vector
         JZ    INV_NULL          If no tWAS vector, report error
         USING BBOAXVEC_TWAS,R15
         L     R15,AVECTWAS_INVK@ Load invoke function
         DROP  R15
         LR    R1,R7             Place our updated PLIST in R1
         BASR  R14,R15             and call into BBOAINV
         J     After_API
INV_NULL DS 0H
         MVI   BBOA1_RC+3,BBOAAPI_RC_SEVERE12   Drop thru and set
         MVI   BBOA1_RN+3,BBOAAPI_RSN_NO_AMCSS  Drop thru and set
INV_Err  L     R2,BBOA1INV_RC
         MVC   0(4,R2),BBOA1_RC
         L     R2,BBOA1INV_RSN
         MVC   0(4,R2),BBOA1_RN
         DROP  R5
         J     Done
*
URG_Stub DS    0H
         USING WOLA_CLIENT_UNREGISTER_PARMS,R7
         USING BBOA1URG_PLIST,R5
         ICM   R2,B'1111',BBOA1_RC
         JNZ   URG_Err
         MVC   WOLA_CLIENT_UNREGISTER_NAME+4(4),BBOA1URG_REGNAME
         MVC   WOLA_CLIENT_UNREGISTER_FLAGS+4(4),BBOA1URG_URGFLAGS
         ST    R6,WOLA_CLIENT_UNREGISTER_CICSPRM+4
         MVC   WOLA_CLIENT_UNREGISTER_RC+4(4),BBOA1URG_RC
         MVC   WOLA_CLIENT_UNREGISTER_RSN+4(4),BBOA1URG_RSN
         NI    WOLA_CLIENT_UNREGISTER_RSN+4,127 Clear high bit
         STMH  R0,R15,WOLA64HH   Store high halves of registers
         LMH   R0,R15,ZEROES     Clear high halves of registers
         ICM   R15,B'1111',VECTPTR Is Liberty vector present?
         JZ    URG_TWAS          No... try tWAS version.
         USING BBOAXVEC,R15
         LG    R15,AVECCURG
         DROP  R15
         LR    R9,R13            Save CTAA address
         LA    R13,WOLA64SA      Load F4SA address for caller
         LR    R1,R7             Place our 64 bit parm list in R1
         SAM64                   Switch to 64 bit mode.
         BASR  R14,R15           Call into BBOAURG
         SAM31                   Switch back to 31 bit mode
         LR    R13,R9            Restore CTAA address
         LMH   R0,R15,WOLA64HH   Restore high halves of registers
         DROP  R7
         L     R2,BBOA1URG_RC    Load address of BBOA1URG RC
         LHI   R14,BBOAAPI_RC_ERROR8
         C     R14,0(R2)         Is it RC=8
         JNZ   After_API         Not RC=8, continue
         L     R2,BBOA1URG_RSN   Load address of BBOA1URG RSN
         LHI   R14,WOLA_RSN_INTERNAL_TRY_TWAS_STUB
         CH    R14,2(R2)         Is this a tWAS registration?
         JNZ   After_API         Nope, don't try tWAS version
URG_TWAS DS    0H                Assume tWAS since not Liberty
         MVC   0(BBOA1URG_PC1PRM-BBOA1URG_PLIST,R7),0(R5)   Copy PLIST
         LA    R2,PC1PRMA
         ST    R2,BBOA1URG_PC1PRM-BBOA1URG_PLIST(R7)        Copy PLIST
         ICM   R15,B'1111',VECTTPTR Load tWAS function vector
         JZ    URG_NULL          If no tWAS vector, report error
         USING BBOAXVEC_TWAS,R15
         L     R15,AVECTWAS_UREG@ Load unregister function
         DROP  R15
         LR    R1,R7             Place our updated PLIST in R1
         BASR  R14,R15             and call into BBOAREG
         J     After_API
URG_NULL DS 0H
         MVI   BBOA1_RC+3,BBOAAPI_RC_SEVERE12   Drop thru and set
         MVI   BBOA1_RN+3,BBOAAPI_RSN_NO_AMCSS  Drop thru and set
URG_Err  L     R2,BBOA1URG_RC
         MVC   0(4,R2),BBOA1_RC
         L     R2,BBOA1URG_RSN
         MVC   0(4,R2),BBOA1_RN
         DROP  R5
         J     Done
*
CNG_Stub DS    0H
         USING WOLA_CLIENT_CONNGET_PARMS,R7
         USING BBOA1CNG_PLIST,R5
         ICM   R2,B'1111',BBOA1_RC
         JNZ   CNG_Err
         MVC   WOLA_CLIENT_CONNGET_NAME+4(4),BBOA1CNG_REGNAME
         MVC   WOLA_CLIENT_CONNGET_HANDLE+4(4),BBOA1CNG_CONNHDL
         MVC   WOLA_CLIENT_CONNGET_WAITTIME+4(4),BBOA1CNG_WAITTIME
         ST    R6,WOLA_CLIENT_CONNGET_CICSPRM+4
         MVC   WOLA_CLIENT_CONNGET_RC+4(4),BBOA1CNG_RC
         MVC   WOLA_CLIENT_CONNGET_RSN+4(4),BBOA1CNG_RSN
         NI    WOLA_CLIENT_CONNGET_RSN+4,127 Clear high bit
         STMH  R0,R15,WOLA64HH   Store high halves of registers
         LMH   R0,R15,ZEROES     Clear high halves of registers
         ICM   R15,B'1111',VECTPTR Is Liberty vector present?
         JZ    CNG_TWAS          No... try tWAS version.
         USING BBOAXVEC,R15
         LG    R15,AVECCCNG      load connection get
         DROP  R15
         LR    R9,R13            Save CTAA address
         LA    R13,WOLA64SA      Load F4SA address for caller
         LR    R1,R7             Place our 64 bit parm list in R1
         SAM64                   Switch to 64 bit mode.
         BASR  R14,R15           Call into BBOACNG
         SAM31                   Switch back to 31 bit mode
         LR    R13,R9            Restore CTAA address
         LMH   R0,R15,WOLA64HH   Restore high halves of registers
         DROP  R7
         L     R2,BBOA1CNG_RC    Load address of BBOA1CNG RC
         LHI   R14,BBOAAPI_RC_ERROR8
         C     R14,0(R2)         Is it RC=8
         JNZ   After_API         Not RC=8, continue
         L     R2,BBOA1CNG_RSN   Load address of BBOA1CNG RSN
         LHI   R14,WOLA_RSN_INTERNAL_TRY_TWAS_STUB
         CH    R14,2(R2)         Is this a tWAS registration?
         JNZ   After_API         Nope, don't try tWAS version
CNG_TWAS DS    0H                Assume tWAS since not Liberty
         MVC   0(BBOA1CNG_PC1PRM-BBOA1CNG_PLIST,R7),0(R5)   Copy PLIST
         LA    R2,PC1PRMA
         ST    R2,BBOA1CNG_PC1PRM-BBOA1CNG_PLIST(R7)        Copy PLIST
         ICM   R15,B'1111',VECTTPTR Load tWAS function vector
         JZ    CNG_NULL          If no tWAS vector, report error
         USING BBOAXVEC_TWAS,R15
         L     R15,AVECTWAS_CONG@ Load connection get function
         DROP  R15
         LR    R1,R7             Place our updated PLIST in R1
         BASR  R14,R15             and call into BBOACNG
         J     After_API
CNG_NULL DS 0H
         MVI   BBOA1_RC+3,BBOAAPI_RC_SEVERE12   Drop thru and set
         MVI   BBOA1_RN+3,BBOAAPI_RSN_NO_AMCSS  Drop thru and set
CNG_Err  L     R2,BBOA1CNG_RC
         MVC   0(4,R2),BBOA1_RC
         L     R2,BBOA1CNG_RSN
         MVC   0(4,R2),BBOA1_RN
         DROP  R5
         J     Done
*
CNR_Stub DS    0H
         USING WOLA_CLIENT_CONNREL_PARMS,R7
         USING BBOA1CNR_PLIST,R5
         ICM   R2,B'1111',BBOA1_RC
         JNZ   CNR_Err
         MVC   WOLA_CLIENT_CONNREL_HANDLE+4(4),BBOA1CNR_CONNHDL
         ST    R6,WOLA_CLIENT_CONNREL_CICSPRM+4
         MVC   WOLA_CLIENT_CONNREL_RC+4(4),BBOA1CNR_RC
         MVC   WOLA_CLIENT_CONNREL_RSN+4(4),BBOA1CNR_RSN
         NI    WOLA_CLIENT_CONNREL_RSN+4,127 Clear high bit
         STMH  R0,R15,WOLA64HH   Store high halves of registers
         LMH   R0,R15,ZEROES     Clear high halves of registers
         ICM   R15,B'1111',VECTPTR Is Liberty vector present?
         JZ    CNR_TWAS          No... try tWAS version.
         USING BBOAXVEC,R15
         LG    R15,AVECCCNR
         DROP  R15
         LR    R9,R13            Save CTAA address
         LA    R13,WOLA64SA      Load F4SA address for caller
         LR    R1,R7             Place our 64 bit parm list in R1
         SAM64                   Switch to 64 bit mode.
         BASR  R14,R15           Call into BBOACNR
         SAM31                   Switch back to 31 bit mode
         LR    R13,R9            Restore CTAA address
         LMH   R0,R15,WOLA64HH   Restore high halves of registers
         DROP  R7
         L     R2,BBOA1CNR_RC    Load address of BBOA1CNR RC
         LHI   R14,BBOAAPI_RC_ERROR8
         C     R14,0(R2)         Is it RC=8
         JNZ   After_API         Not RC=8, continue
         L     R2,BBOA1CNR_RSN   Load address of BBOA1CNR RSN
         LHI   R14,WOLA_RSN_INTERNAL_TRY_TWAS_STUB
         CH    R14,2(R2)         Is this a tWAS registration?
         JNZ   After_API         Nope, don't try tWAS version
CNR_TWAS DS    0H                Assume tWAS since not Liberty
         MVC   0(BBOA1CNR_PC1PRM-BBOA1CNR_PLIST,R7),0(R5)   Copy PLIST
         LA    R2,PC1PRMA
         ST    R2,BBOA1CNR_PC1PRM-BBOA1CNR_PLIST(R7)        Copy PLIST
         ICM   R15,B'1111',VECTTPTR Load tWAS function vector
         JZ    CNR_NULL          If no tWAS vector, report error
         USING BBOAXVEC_TWAS,R15
         L     R15,AVECTWAS_CONR@ Load connection release function
         DROP  R15
         LR    R1,R7             Place our updated PLIST in R1
         BASR  R14,R15             and call into BBOACNR
         J     After_API
CNR_NULL DS 0H
         MVI   BBOA1_RC+3,BBOAAPI_RC_SEVERE12   Drop thru and set
         MVI   BBOA1_RN+3,BBOAAPI_RSN_NO_AMCSS  Drop thru and set
CNR_Err  L     R2,BBOA1CNR_RC
         MVC   0(4,R2),BBOA1_RC
         L     R2,BBOA1CNR_RSN
         MVC   0(4,R2),BBOA1_RN
         DROP  R5
         J     Done
*
GET_Stub DS    0H
         USING WOLA_CLIENT_GETDATA_PARMS,R7
         USING BBOA1GET_PLIST,R5
         ICM   R2,B'1111',BBOA1_RC
         JNZ   GET_Err
         MVC   WOLA_CLIENT_GETDATA_HANDLE+4(4),BBOA1GET_CONNHDL
         L     R2,BBOA1GET_MSGDATA  Convert ptr-to-ptr to ptr
         MVC   WOLA_CLIENT_GETDATA_DATA+4(4),0(R2)
         MVC   WOLA_CLIENT_GETDATA_DATAL+4(4),BBOA1GET_MSGDATAL
         ST    R6,WOLA_CLIENT_GETDATA_CICSPRM+4
         MVC   WOLA_CLIENT_GETDATA_RC+4(4),BBOA1GET_RC
         MVC   WOLA_CLIENT_GETDATA_RSN+4(4),BBOA1GET_RSN
         MVC   WOLA_CLIENT_GETDATA_RV+4(4),BBOA1GET_RVAL
         NI    WOLA_CLIENT_GETDATA_RV+4,127 Clear high bit
         STMH  R0,R15,WOLA64HH   Store high halves of registers
         LMH   R0,R15,ZEROES     Clear high halves of registers
         ICM   R15,B'1111',VECTPTR Is Liberty vector present?
         JZ    GET_TWAS          No... try tWAS version.
         USING BBOAXVEC,R15
         LG    R15,AVECCGET      load get data
         DROP  R15
         LR    R9,R13            Save CTAA address
         LA    R13,WOLA64SA      Load F4SA address for caller
         LR    R1,R7             Place our 64 bit parm list in R1
         SAM64                   Switch to 64 bit mode.
         BASR  R14,R15           Call into BBOAGET
         SAM31                   Switch back to 31 bit mode
         LR    R13,R9            Restore CTAA address
         LMH   R0,R15,WOLA64HH   Restore high halves of registers
         DROP  R7
         L     R2,BBOA1GET_RC    Load address of BBOA1GET RC
         LHI   R14,BBOAAPI_RC_ERROR8
         C     R14,0(R2)         Is it RC=8
         JNZ   After_API         Not RC=8, continue
         L     R2,BBOA1GET_RSN   Load address of BBOA1GET RSN
         LHI   R14,WOLA_RSN_INTERNAL_TRY_TWAS_STUB
         CH    R14,2(R2)         Is this a tWAS registration?
         JNZ   After_API         Nope, don't try tWAS version
GET_TWAS DS    0H                Assume tWAS since not Liberty
         MVC   0(BBOA1GET_PC1PRM-BBOA1GET_PLIST,R7),0(R5)   Copy PLIST
         LA    R2,PC1PRMA
         ST    R2,BBOA1GET_PC1PRM-BBOA1GET_PLIST(R7)        Copy PLIST
         ICM   R15,B'1111',VECTTPTR Load tWAS function vector
         JZ    GET_NULL          If no tWAS vector, report error
         USING BBOAXVEC_TWAS,R15
         L     R15,AVECTWAS_GETD@ Load get data function
         DROP  R15
         LR    R1,R7             Place our updated PLIST in R1
         BASR  R14,R15             and call into BBOAGET
         J     After_API
GET_NULL DS 0H
         MVI   BBOA1_RC+3,BBOAAPI_RC_SEVERE12   Drop thru and set
         MVI   BBOA1_RN+3,BBOAAPI_RSN_NO_AMCSS  Drop thru and set
GET_Err  L     R2,BBOA1GET_RC
         MVC   0(4,R2),BBOA1_RC
         L     R2,BBOA1GET_RSN
         MVC   0(4,R2),BBOA1_RN
         DROP  R5
         J     Done
*
GTX_Stub DS    0H
         USING WOLA_CLIENT_GETCTX_PARMS,R7
         USING BBOA1GTX_PLIST,R5
         ICM   R2,B'1111',BBOA1_RC
         JNZ   GTX_Err
         MVC   WOLA_CLIENT_GETCTX_HANDLE+4(4),BBOA1GTX_CONNHDL
         L     R2,BBOA1GTX_CTXTDATA  Convert ptr-to-ptr to ptr
         MVC   WOLA_CLIENT_GETCTX_DATA+4(4),0(R2)
         MVC   WOLA_CLIENT_GETCTX_DATAL+4(4),BBOA1GTX_CTXTLEN
         ST    R6,WOLA_CLIENT_GETCTX_CICSPRM+4
         MVC   WOLA_CLIENT_GETCTX_RC+4(4),BBOA1GTX_RC
         MVC   WOLA_CLIENT_GETCTX_RSN+4(4),BBOA1GTX_RSN
         MVC   WOLA_CLIENT_GETCTX_RV+4(4),BBOA1GTX_RV
         NI    WOLA_CLIENT_GETCTX_RV+4,127 Clear high bit
         STMH  R0,R15,WOLA64HH   Store high halves of registers
         LMH   R0,R15,ZEROES     Clear high halves of registers
         ICM   R15,B'1111',VECTPTR Is Liberty vector present?
         JZ    GTX_TWAS          No... try tWAS version.
         USING BBOAXVEC,R15
         LG    R15,AVECCGTX 
         DROP  R15
         LR    R9,R13            Save CTAA address
         LA    R13,WOLA64SA      Load F4SA address for caller
         LR    R1,R7             Place our 64 bit parm list in R1
         SAM64                   Switch to 64 bit mode.
         BASR  R14,R15           Call into BBOAGTX
         SAM31                   Switch back to 31 bit mode
         LR    R13,R9            Restore CTAA address
         LMH   R0,R15,WOLA64HH   Restore high halves of registers
         DROP  R7
         L     R2,BBOA1GTX_RC    Load address of BBOA1GTX RC
         LHI   R14,BBOAAPI_RC_ERROR8
         C     R14,0(R2)         Is it RC=8
         JNZ   After_API         Not RC=8, continue
         L     R2,BBOA1GTX_RSN   Load address of BBOA1GTX RSN
         LHI   R14,WOLA_RSN_INTERNAL_TRY_TWAS_STUB
         CH    R14,2(R2)         Is this a tWAS registration?
         JNZ   After_API         Nope, don't try tWAS version
GTX_TWAS DS    0H                Assume tWAS since not Liberty
         MVC   0(BBOA1GTX_PC1PRM-BBOA1GTX_PLIST,R7),0(R5)   Copy PLIST
         LA    R2,PC1PRMA
         ST    R2,BBOA1GTX_PC1PRM-BBOA1GTX_PLIST(R7)        Copy PLIST
         ICM   R15,B'1111',VECTTPTR Load tWAS function vector
         JZ    GTX_NULL          If no tWAS vector, report error
         USING BBOAXVEC_TWAS,R15
         L     R15,AVECTWAS_GTX@ Load get context function
         DROP  R15
         LR    R1,R7             Place our updated PLIST in R1
         BASR  R14,R15             and call into BBOAGTX
         J     After_API
GTX_NULL DS 0H
         MVI   BBOA1_RC+3,BBOAAPI_RC_SEVERE12   Drop thru and set
         MVI   BBOA1_RN+3,BBOAAPI_RSN_NO_AMCSS  Drop thru and set
GTX_Err  L     R2,BBOA1GTX_RC
         MVC   0(4,R2),BBOA1_RC
         L     R2,BBOA1GTX_RSN
         MVC   0(4,R2),BBOA1_RN
         DROP  R5
         J     Done
*
RCA_Stub DS    0H
         USING WOLA_CLIENT_RECVANY_PARMS,R7
         USING BBOA1RCA_PLIST,R5
         ICM   R2,B'1111',BBOA1_RC
         JNZ   RCA_Err
         MVC   WOLA_CLIENT_RECVANY_REGNAME+4(4),BBOA1RCA_REGNAME
         MVC   WOLA_CLIENT_RECVANY_HANDLE+4(4),BBOA1RCA_CONNHDL
         MVC   WOLA_CLIENT_RECVANY_SERVNAME+4(4),BBOA1RCA_SERVNAME
         MVC   WOLA_CLIENT_RECVANY_SERVNAMEL+4(4),BBOA1RCA_SERVNAMEL
         MVC   WOLA_CLIENT_RECVANY_DATAL+4(4),BBOA1RCA_REQDATAL
         MVC   WOLA_CLIENT_RECVANY_WAITTIME+4(4),BBOA1RCA_WAITTIME
         ST    R6,WOLA_CLIENT_RECVANY_CICSPRM+4
         MVC   WOLA_CLIENT_RECVANY_RC+4(4),BBOA1RCA_RC
         MVC   WOLA_CLIENT_RECVANY_RSN+4(4),BBOA1RCA_RSN
         NI    WOLA_CLIENT_RECVANY_RSN+4,127 Clear high bit
         STMH  R0,R15,WOLA64HH   Store high halves of registers
         LMH   R0,R15,ZEROES     Clear high halves of registers
         ICM   R15,B'1111',VECTPTR Is Liberty vector present?
         JZ    RCA_TWAS          No... try tWAS version.
         USING BBOAXVEC,R15
         LG    R15,AVECCRCA      load receive request any
         DROP  R15
         LR    R9,R13            Save CTAA address
         LA    R13,WOLA64SA      Load F4SA address for caller
         LR    R1,R7             Place our 64 bit parm list in R1
         SAM64                   Switch to 64 bit mode.
         BASR  R14,R15           Call into BBOARCA
         SAM31                   Switch back to 31 bit mode
         LR    R13,R9            Restore CTAA address
         LMH   R0,R15,WOLA64HH   Restore high halves of registers
         DROP  R7
         L     R2,BBOA1RCA_RC    Load address of BBOA1RCA RC
         LHI   R14,BBOAAPI_RC_ERROR8
         C     R14,0(R2)         Is it RC=8
         JNZ   After_API         Not RC=8, continue
         L     R2,BBOA1RCA_RSN   Load address of BBOA1RCA RSN
         LHI   R14,WOLA_RSN_INTERNAL_TRY_TWAS_STUB
         CH    R14,2(R2)         Is this a tWAS registration?
         JNZ   After_API         Nope, don't try tWAS version
RCA_TWAS DS    0H                Assume tWAS since not Liberty
         MVC   0(BBOA1RCA_PC1PRM-BBOA1RCA_PLIST,R7),0(R5)   Copy PLIST
         LA    R2,PC1PRMA
         ST    R2,BBOA1RCA_PC1PRM-BBOA1RCA_PLIST(R7)        Copy PLIST
         ICM   R15,B'1111',VECTTPTR Load tWAS function vector
         JZ    RCA_NULL          If no tWAS vector, report error
         USING BBOAXVEC_TWAS,R15
         L     R15,AVECTWAS_RRQA@ Load receive any function
         DROP  R15
         LR    R1,R7             Place our updated PLIST in R1
         BASR  R14,R15             and call into BBOARCA
         J     After_API
RCA_NULL DS 0H
         MVI   BBOA1_RC+3,BBOAAPI_RC_SEVERE12   Drop thru and set
         MVI   BBOA1_RN+3,BBOAAPI_RSN_NO_AMCSS  Drop thru and set
RCA_Err  L     R2,BBOA1RCA_RC
         MVC   0(4,R2),BBOA1_RC
         L     R2,BBOA1RCA_RSN
         MVC   0(4,R2),BBOA1_RN
         DROP  R5
         J     Done
*
RCS_Stub DS    0H
         USING WOLA_CLIENT_RECVSPC_PARMS,R7
         USING BBOA1RCS_PLIST,R5
         ICM   R2,B'1111',BBOA1_RC
         JNZ   RCS_Err
         MVC   WOLA_CLIENT_RECVSPC_HANDLE+4(4),BBOA1RCS_CONNHDL
         MVC   WOLA_CLIENT_RECVSPC_SERVNAME+4(4),BBOA1RCS_SERVNAME
         MVC   WOLA_CLIENT_RECVSPC_SERVNAMEL+4(4),BBOA1RCS_SERVNAMEL
         MVC   WOLA_CLIENT_RECVSPC_DATAL+4(4),BBOA1RCS_REQDATAL
         MVC   WOLA_CLIENT_RECVSPC_ASYNC+4(4),BBOA1RCS_ASYNC
         ST    R6,WOLA_CLIENT_RECVSPC_CICSPRM+4
         MVC   WOLA_CLIENT_RECVSPC_RC+4(4),BBOA1RCS_RC
         MVC   WOLA_CLIENT_RECVSPC_RSN+4(4),BBOA1RCS_RSN
         NI    WOLA_CLIENT_RECVSPC_RSN+4,127 Clear high bit
         STMH  R0,R15,WOLA64HH   Store high halves of registers
         LMH   R0,R15,ZEROES     Clear high halves of registers
         ICM   R15,B'1111',VECTPTR Is Liberty vector present?
         JZ    RCS_TWAS          No... try tWAS version.
         USING BBOAXVEC,R15
         LG    R15,AVECCRCS      Load receive req specific
         DROP  R15
         LR    R9,R13            Save CTAA address
         LA    R13,WOLA64SA      Load F4SA address for caller
         LR    R1,R7             Place our 64 bit parm list in R1
         SAM64                   Switch to 64 bit mode.
         BASR  R14,R15           Call into BBOARCS
         SAM31                   Switch back to 31 bit mode
         LR    R13,R9            Restore CTAA address
         LMH   R0,R15,WOLA64HH   Restore high halves of registers
         DROP  R7
         L     R2,BBOA1RCS_RC    Load address of BBOA1RCS RC
         LHI   R14,BBOAAPI_RC_ERROR8
         C     R14,0(R2)         Is it RC=8
         JNZ   After_API         Not RC=8, continue
         L     R2,BBOA1RCS_RSN   Load address of BBOA1RCS RSN
         LHI   R14,WOLA_RSN_INTERNAL_TRY_TWAS_STUB
         CH    R14,2(R2)         Is this a tWAS registration?
         JNZ   After_API         Nope, don't try tWAS version
RCS_TWAS DS    0H                Assume tWAS since not Liberty
         MVC   0(BBOA1RCS_PC1PRM-BBOA1RCS_PLIST,R7),0(R5)   Copy PLIST
         LA    R2,PC1PRMA
         ST    R2,BBOA1RCS_PC1PRM-BBOA1RCS_PLIST(R7)        Copy PLIST
         ICM   R15,B'1111',VECTTPTR Load tWAS function vector
         JZ    RCS_NULL          If no tWAS vector, report error
         USING BBOAXVEC_TWAS,R15
         L     R15,AVECTWAS_RRQS@ Load recv request specific function
         DROP  R15
         LR    R1,R7             Place our updated PLIST in R1
         BASR  R14,R15             and call into BBOARCS
         J     After_API
RCS_NULL DS 0H
         MVI   BBOA1_RC+3,BBOAAPI_RC_SEVERE12   Drop thru and set
         MVI   BBOA1_RN+3,BBOAAPI_RSN_NO_AMCSS  Drop thru and set
         J     After_API
RCS_Err  L     R2,BBOA1RCS_RC
         MVC   0(4,R2),BBOA1_RC
         L     R2,BBOA1RCS_RSN
         MVC   0(4,R2),BBOA1_RN
         DROP  R5
         J     Done
*
RCL_Stub DS    0H
         USING WOLA_CLIENT_RECVLEN_PARMS,R7
         USING BBOA1RCL_PLIST,R5
         ICM   R2,B'1111',BBOA1_RC
         JNZ   RCL_Err
         MVC   WOLA_CLIENT_RECVLEN_HANDLE+4(4),BBOA1RCL_CONNHDL
         MVC   WOLA_CLIENT_RECVLEN_ASYNC+4(4),BBOA1RCL_ASYNC
         MVC   WOLA_CLIENT_RECVLEN_RSPDATAL+4(4),BBOA1RCL_RSPDATAL
         ST    R6,WOLA_CLIENT_RECVLEN_CICSPRM+4
         MVC   WOLA_CLIENT_RECVLEN_RC+4(4),BBOA1RCL_RC
         MVC   WOLA_CLIENT_RECVLEN_RSN+4(4),BBOA1RCL_RSN
         NI    WOLA_CLIENT_RECVLEN_RSN+4,127 Clear high bit
         STMH  R0,R15,WOLA64HH   Store high halves of registers
         LMH   R0,R15,ZEROES     Clear high halves of registers
         ICM   R15,B'1111',VECTPTR Is Liberty vector present?
         JZ    RCL_TWAS          No... try tWAS version.
         USING BBOAXVEC,R15
         LG    R15,AVECCRCL      load receive response length
         DROP  R15
         LR    R9,R13            Save CTAA address
         LA    R13,WOLA64SA      Load F4SA address for caller
         LR    R1,R7             Place our 64 bit parm list in R1
         SAM64                   Switch to 64 bit mode.
         BASR  R14,R15           Call into BBOARCL
         SAM31                   Switch back to 31 bit mode
         LR    R13,R9            Restore CTAA address
         LMH   R0,R15,WOLA64HH   Restore high halves of registers
         DROP  R7
         L     R2,BBOA1RCL_RC    Load address of BBOA1RCL RC
         LHI   R14,BBOAAPI_RC_ERROR8
         C     R14,0(R2)         Is it RC=8
         JNZ   After_API         Not RC=8, continue
         L     R2,BBOA1RCL_RSN   Load address of BBOA1RCL RSN
         LHI   R14,WOLA_RSN_INTERNAL_TRY_TWAS_STUB
         CH    R14,2(R2)         Is this a tWAS registration?
         JNZ   After_API         Nope, don't try tWAS version
RCL_TWAS DS    0H                Assume tWAS since not Liberty
         MVC   0(BBOA1RCL_PC1PRM-BBOA1RCL_PLIST,R7),0(R5)   Copy PLIST
         LA    R2,PC1PRMA
         ST    R2,BBOA1RCL_PC1PRM-BBOA1RCL_PLIST(R7)        Copy PLIST
         ICM   R15,B'1111',VECTTPTR Load tWAS function vector
         JZ    RCL_NULL          If no tWAS vector, report error
         USING BBOAXVEC_TWAS,R15
         L     R15,AVECTWAS_RCRL@ Load receive resp length function
         DROP  R15
         LR    R1,R7             Place our updated PLIST in R1
         BASR  R14,R15             and call into BBOARCL
         J     After_API
RCL_NULL DS 0H
         MVI   BBOA1_RC+3,BBOAAPI_RC_SEVERE12   Drop thru and set
         MVI   BBOA1_RN+3,BBOAAPI_RSN_NO_AMCSS  Drop thru and set
RCL_Err  L     R2,BBOA1RCL_RC
         MVC   0(4,R2),BBOA1_RC
         L     R2,BBOA1RCL_RSN
         MVC   0(4,R2),BBOA1_RN
         DROP  R5
         J     Done
*
SRP_Stub DS    0H
         USING WOLA_CLIENT_SENDRESP_PARMS,R7
         USING BBOA1SRP_PLIST,R5
         ICM   R2,B'1111',BBOA1_RC
         JNZ   SRP_Err
         MVC   WOLA_CLIENT_SENDRESP_HANDLE+4(4),BBOA1SRP_CONNHDL
         L     R2,BBOA1SRP_RSPDATA
         MVC   WOLA_CLIENT_SENDRESP_DATA+4(4),0(R2)
         MVC   WOLA_CLIENT_SENDRESP_DATAL+4(4),BBOA1SRP_RSPDATAL
         ST    R6,WOLA_CLIENT_SENDRESP_CICSPRM+4
         MVC   WOLA_CLIENT_SENDRESP_RC+4(4),BBOA1SRP_RC
         MVC   WOLA_CLIENT_SENDRESP_RSN+4(4),BBOA1SRP_RSN
         NI    WOLA_CLIENT_SENDRESP_RSN+4,127 Clear high bit
         STMH  R0,R15,WOLA64HH   Store high halves of registers
         LMH   R0,R15,ZEROES     Clear high halves of registers
         ICM   R15,B'1111',VECTPTR Is Liberty vector present?
         JZ    SRP_TWAS          No... try tWAS version.
         USING BBOAXVEC,R15
         LG    R15,AVECCSRP
         DROP  R15
         LR    R9,R13            Save CTAA address
         LA    R13,WOLA64SA      Load F4SA address for caller
         LR    R1,R7             Place our 64 bit parm list in R1
         SAM64                   Switch to 64 bit mode.
         BASR  R14,R15           Call into BBOASRP
         SAM31                   Switch back to 31 bit mode
         LR    R13,R9            Restore CTAA address
         LMH   R0,R15,WOLA64HH   Restore high halves of registers
         DROP  R7
         L     R2,BBOA1SRP_RC    Load address of BBOA1SRP RC
         LHI   R14,BBOAAPI_RC_ERROR8
         C     R14,0(R2)         Is it RC=8
         JNZ   After_API         Not RC=8, continue
         L     R2,BBOA1SRP_RSN   Load address of BBOA1SRP RSN
         LHI   R14,WOLA_RSN_INTERNAL_TRY_TWAS_STUB
         CH    R14,2(R2)         Is this a tWAS registration?
         JNZ   After_API         Nope, don't try tWAS version
SRP_TWAS DS    0H                Assume tWAS since not Liberty
         MVC   0(BBOA1SRP_PC1PRM-BBOA1SRP_PLIST,R7),0(R5)   Copy PLIST
         LA    R2,PC1PRMA
         ST    R2,BBOA1SRP_PC1PRM-BBOA1SRP_PLIST(R7)        Copy PLIST
         ICM   R15,B'1111',VECTTPTR Load tWAS function vector
         JZ    SRP_NULL          If no tWAS vector, report error
         USING BBOAXVEC_TWAS,R15
         L     R15,AVECTWAS_SNRP@ Load send response function
         DROP  R15
         LR    R1,R7             Place our updated PLIST in R1
         BASR  R14,R15             and call into BBOASRP
         J     After_API
SRP_NULL DS 0H
         MVI   BBOA1_RC+3,BBOAAPI_RC_SEVERE12   Drop thru and set
         MVI   BBOA1_RN+3,BBOAAPI_RSN_NO_AMCSS  Drop thru and set
SRP_Err  L     R2,BBOA1SRP_RC
         MVC   0(4,R2),BBOA1_RC
         L     R2,BBOA1SRP_RSN
         MVC   0(4,R2),BBOA1_RN
         DROP  R5
         J     Done
*
SRQ_Stub DS    0H
         USING WOLA_CLIENT_SENDREQ_PARMS,R7
         USING BBOA1SRQ_PLIST,R5
         ICM   R2,B'1111',BBOA1_RC
         JNZ   SRQ_Err
         MVC   WOLA_CLIENT_SENDREQ_HANDLE+4(4),BBOA1SRQ_CONNHDL
         MVC   WOLA_CLIENT_SENDREQ_REQTYPE+4(4),BBOA1SRQ_REQTYPE
         MVC   WOLA_CLIENT_SENDREQ_SERVNAME+4(4),BBOA1SRQ_SERVNAME
         MVC   WOLA_CLIENT_SENDREQ_SERVNAMEL+4(4),BBOA1SRQ_SERVNAMEL
         L     R2,BBOA1SRQ_REQDATA  Change ptr-to-ptr to ptr
         MVC   WOLA_CLIENT_SENDREQ_REQDATA+4(4),0(R2)
         MVC   WOLA_CLIENT_SENDREQ_REQDATAL+4(4),BBOA1SRQ_REQDATAL
         MVC   WOLA_CLIENT_SENDREQ_ASYNC+4(4),BBOA1SRQ_ASYNC
         MVC   WOLA_CLIENT_SENDREQ_RSPDATAL+4(4),BBOA1SRQ_RSPDATAL
         ST    R6,WOLA_CLIENT_SENDREQ_CICSPRM+4
         MVC   WOLA_CLIENT_SENDREQ_RC+4(4),BBOA1SRQ_RC
         MVC   WOLA_CLIENT_SENDREQ_RSN+4(4),BBOA1SRQ_RSN
         NI    WOLA_CLIENT_SENDREQ_RSN+4,127 Clear high bit
         STMH  R0,R15,WOLA64HH   Store high halves of registers
         LMH   R0,R15,ZEROES     Clear high halves of registers
         ICM   R15,B'1111',VECTPTR Is Liberty vector present?
         JZ    SRQ_TWAS          No... try tWAS version.
         USING BBOAXVEC,R15
         LG    R15,AVECCSRQ      load send request fcn
         DROP  R15
         LR    R9,R13            Save CTAA address
         LA    R13,WOLA64SA      Load F4SA address for caller
         LR    R1,R7             Place our 64 bit parm list in R1
         SAM64                   Switch to 64 bit mode.
         BASR  R14,R15           Call into BBOASRQ
         SAM31                   Switch back to 31 bit mode
         LR    R13,R9            Restore CTAA address
         LMH   R0,R15,WOLA64HH   Restore high halves of registers
         DROP  R7
         L     R2,BBOA1SRQ_RC    Load address of BBOA1SRQ RC
         LHI   R14,BBOAAPI_RC_ERROR8
         C     R14,0(R2)         Is it RC=8
         JNZ   After_API         Not RC=8, continue
         L     R2,BBOA1SRQ_RSN   Load address of BBOA1SRQ RSN
         LHI   R14,WOLA_RSN_INTERNAL_TRY_TWAS_STUB
         CH    R14,2(R2)         Is this a tWAS registration?
         JNZ   After_API         Nope, don't try tWAS version
SRQ_TWAS DS    0H                Assume tWAS since not Liberty
         MVC   0(BBOA1SRQ_PC1PRM-BBOA1SRQ_PLIST,R7),0(R5)   Copy PLIST
         LA    R2,PC1PRMA
         ST    R2,BBOA1SRQ_PC1PRM-BBOA1SRQ_PLIST(R7)        Copy PLIST
         ICM   R15,B'1111',VECTTPTR Load tWAS function vector
         JZ    SRQ_NULL          If no tWAS vector, report error
         USING BBOAXVEC_TWAS,R15
         L     R15,AVECTWAS_SNRQ@ Load send request function
         DROP  R15
         LR    R1,R7             Place our updated PLIST in R1
         BASR  R14,R15             and call into BBOASRQ
         J     After_API
SRQ_NULL DS    0H
         MVI   BBOA1_RC+3,BBOAAPI_RC_SEVERE12   Drop thru and set
         MVI   BBOA1_RN+3,BBOAAPI_RSN_NO_AMCSS  Drop thru and set
SRQ_Err  L     R2,BBOA1SRQ_RC
         MVC   0(4,R2),BBOA1_RC
         L     R2,BBOA1SRQ_RSN
         MVC   0(4,R2),BBOA1_RN
         DROP  R5
         J     Done
*
SRV_Stub DS    0H
         USING WOLA_CLIENT_HOST_PARMS,R7
         USING BBOA1SRV_PLIST,R5
         ICM   R2,B'1111',BBOA1_RC
         JNZ   SRV_Err
         MVC   WOLA_CLIENT_HOST_REGNAME+4(4),BBOA1SRV_REGNAME
         MVC   WOLA_CLIENT_HOST_SERVNAME+4(4),BBOA1SRV_SERVNAME
         MVC   WOLA_CLIENT_HOST_SERVNAMEL+4(4),BBOA1SRV_SERVNAMEL
         L     R2,BBOA1SRV_REQDATA  Convert ptr-to-ptr to ptr
         MVC   WOLA_CLIENT_HOST_REQDATA+4(4),0(R2)
         MVC   WOLA_CLIENT_HOST_REQDATAL+4(4),BBOA1SRV_REQDATAL
         MVC   WOLA_CLIENT_HOST_HANDLE+4(4),BBOA1SRV_CONNHDL
         MVC   WOLA_CLIENT_HOST_WAITTIME+4(4),BBOA1SRV_WAITTIME@
         ST    R6,WOLA_CLIENT_HOST_CICSPRM+4
         MVC   WOLA_CLIENT_HOST_RC+4(4),BBOA1SRV_RC
         MVC   WOLA_CLIENT_HOST_RSN+4(4),BBOA1SRV_RSN
         MVC   WOLA_CLIENT_HOST_RV+4(4),BBOA1SRV_RVAL
         NI    WOLA_CLIENT_HOST_RV+4,127 Clear high bit
         STMH  R0,R15,WOLA64HH   Store high halves of registers
         LMH   R0,R15,ZEROES     Clear high halves of registers
         ICM   R15,B'1111',VECTPTR Is Liberty vector present?
         JZ    SRV_TWAS          No... try tWAS version.
         USING BBOAXVEC,R15
         LG    R15,AVECCSRV
         DROP  R15
         LR    R9,R13            Save CTAA address
         LA    R13,WOLA64SA      Load F4SA address for caller
         LR    R1,R7             Place our 64 bit parm list in R1
         SAM64                   Switch to 64 bit mode.
         BASR  R14,R15           Call into BBOASRV
         SAM31                   Switch back to 31 bit mode
         LR    R13,R9            Restore CTAA address
         LMH   R0,R15,WOLA64HH   Restore high halves of registers
         DROP  R7
         L     R2,BBOA1SRV_RC    Load address of BBOA1SRV RC
         LHI   R14,BBOAAPI_RC_ERROR8
         C     R14,0(R2)         Is it RC=8
         JNZ   After_API         Not RC=8, continue
         L     R2,BBOA1SRV_RSN   Load address of BBOA1SRV RSN
         LHI   R14,WOLA_RSN_INTERNAL_TRY_TWAS_STUB
         CH    R14,2(R2)         Is this a tWAS registration?
         JNZ   After_API         Nope, don't try tWAS version
SRV_TWAS DS    0H                Assume tWAS since not Liberty
         MVC   0(BBOA1SRV_PC1PRM-BBOA1SRV_PLIST,R7),0(R5)   Copy PLIST
         LA    R2,PC1PRMA
         ST    R2,BBOA1SRV_PC1PRM-BBOA1SRV_PLIST(R7)        Copy PLIST
         ICM   R15,B'1111',VECTTPTR Load tWAS function vector
         JZ    SRV_NULL          If no tWAS vector, report error
         USING BBOAXVEC_TWAS,R15
         L     R15,AVECTWAS_HOST@ Load host service function
         DROP  R15
         LR    R1,R7             Place our updated PLIST in R1
         BASR  R14,R15             and call into BBOAREG
         J     After_API
SRV_NULL DS 0H
         MVI   BBOA1_RC+3,BBOAAPI_RC_SEVERE12   Drop thru and set
         MVI   BBOA1_RN+3,BBOAAPI_RSN_NO_AMCSS  Drop thru and set
SRV_Err  L     R2,BBOA1SRV_RC
         MVC   0(4,R2),BBOA1_RC
         L     R2,BBOA1SRV_RSN
         MVC   0(4,R2),BBOA1_RN
         DROP  R5
         J     Done
*
SRX_Stub DS    0H
         USING WOLA_CLIENT_SENDEXCP_PARMS,R7
         USING BBOA1SRX_PLIST,R5
         ICM   R2,B'1111',BBOA1_RC
         JNZ   SRX_Err
         MVC   WOLA_CLIENT_SENDEXCP_HANDLE+4(4),BBOA1SRX_CONNHDL
         L     R2,BBOA1SRX_RSPDATA  Convert ptr-to-ptr to ptr
         MVC   WOLA_CLIENT_SENDEXCP_DATA+4(4),0(R2)
         MVC   WOLA_CLIENT_SENDEXCP_DATAL+4(4),BBOA1SRX_RSPDATAL
         ST    R6,WOLA_CLIENT_SENDEXCP_CICSPRM+4
         MVC   WOLA_CLIENT_SENDEXCP_RC+4(4),BBOA1SRX_RC
         MVC   WOLA_CLIENT_SENDEXCP_RSN+4(4),BBOA1SRX_RSN
         NI    WOLA_CLIENT_SENDEXCP_RSN+4,127 Clear high bit
         STMH  R0,R15,WOLA64HH   Store high halves of registers
         LMH   R0,R15,ZEROES     Clear high halves of registers
         ICM   R15,B'1111',VECTPTR Is Liberty vector present?
         JZ    SRX_TWAS          No... try tWAS version.
         USING BBOAXVEC,R15
         LG    R15,AVECCSRX      Load send resp exception fcn
         DROP  R15
         LR    R9,R13            Save CTAA address
         LA    R13,WOLA64SA      Load F4SA address for caller
         LR    R1,R7             Place our 64 bit parm list in R1
         SAM64                   Switch to 64 bit mode.
         BASR  R14,R15           Call into BBOASRX
         SAM31                   Switch back to 31 bit mode
         LR    R13,R9            Restore CTAA address
         LMH   R0,R15,WOLA64HH   Restore high halves of registers
         DROP  R7
         L     R2,BBOA1SRX_RC    Load address of BBOA1SRX RC
         LHI   R14,BBOAAPI_RC_ERROR8
         C     R14,0(R2)         Is it RC=8
         JNZ   After_API         Not RC=8, continue
         L     R2,BBOA1SRX_RSN   Load address of BBOA1SRX RSN
         LHI   R14,WOLA_RSN_INTERNAL_TRY_TWAS_STUB
         CH    R14,2(R2)         Is this a tWAS registration?
         JNZ   After_API         Nope, don't try tWAS version
SRX_TWAS DS    0H                Assume tWAS since not Liberty
         MVC   0(BBOA1SRX_PC1PRM-BBOA1SRX_PLIST,R7),0(R5)   Copy PLIST
         LA    R2,PC1PRMA
         ST    R2,BBOA1SRX_PC1PRM-BBOA1SRX_PLIST(R7)        Copy PLIST
         ICM   R15,B'1111',VECTTPTR Load tWAS function vector
         JZ    SRX_NULL          If no tWAS vector, report error
         USING BBOAXVEC_TWAS,R15
         L     R15,AVECTWAS_SNRX@ Load send resp exception function
         DROP  R15
         LR    R1,R7             Place our updated PLIST in R1
         BASR  R14,R15             and call into BBOASRX
         J     After_API
SRX_NULL DS 0H
         MVI   BBOA1_RC+3,BBOAAPI_RC_SEVERE12   Drop thru and set
         MVI   BBOA1_RN+3,BBOAAPI_RSN_NO_AMCSS  Drop thru and set
SRX_Err  L     R2,BBOA1SRX_RC
         MVC   0(4,R2),BBOA1_RC
         L     R2,BBOa1SRX_RSN
         MVC   0(4,R2),BBOA1_RN
         DROP  R5
         J     Done
*
INF_Stub DS    0H
         USING WOLA_CLIENT_INFO_PARMS,R7
         USING BBOA1INF_PLIST,R5
         ICM   R2,B'1111',BBOA1_RC
         JNZ   INF_Err
         MVC   WOLA_CLIENT_INFO_REGNAME+4(4),BBOA1INF_REGNAME
         MVC   WOLA_CLIENT_INFO_WOLAGRP+4(4),BBOA1INF_GROUP
         MVC   WOLA_CLIENT_INFO_WOLA2+4(4),BBOA1INF_NODE
         MVC   WOLA_CLIENT_INFO_WOLA3+4(4),BBOA1INF_SERVER
         L     R2,BBOA1INF_CONNDATA@   Change ptr-to-ptr to ptr
         MVC   WOLA_CLIENT_INFO_CONNDATA+4(4),0(R2)
         ST    R6,WOLA_CLIENT_INFO_CICSPRM+4
         MVC   WOLA_CLIENT_INFO_RC+4(4),BBOA1INF_RC
         MVC   WOLA_CLIENT_INFO_RSN+4(4),BBOA1INF_RSN
         NI    WOLA_CLIENT_INFO_RSN+4,127 Clear high bit
         STMH  R0,R15,WOLA64HH   Store high halves of registers
         LMH   R0,R15,ZEROES     Clear high halves of registers
         ICM   R15,B'1111',VECTPTR Is Liberty vector present?
         JZ    INF_TWAS          No... try tWAS version.
         USING BBOAXVEC,R15
         LH    R9,AVECSLOT       Load vector version
         CHI   R9,AVEC_INF_LVL   Does vector contain BBOA1INF?
         JL    INF_TWAS          No... try tWAS version.
         LG    R15,AVECCINF      Load info fcn
         DROP  R15
         LR    R9,R13            Save CTAA address
         LA    R13,WOLA64SA      Load F4SA address for caller
         LR    R1,R7             Place our 64 bit parm list in R1
         SAM64                   Switch to 64 bit mode.
         BASR  R14,R15           Call into BBOAINF
         SAM31                   Switch back to 31 bit mode
         LR    R13,R9            Restore CTAA address
         LMH   R0,R15,WOLA64HH   Restore high halves of registers
         DROP  R7
         L     R2,BBOA1INF_RC    Load address of BBOA1INF RC
         LHI   R14,BBOAAPI_RC_ERROR8
         C     R14,0(R2)         Is it RC=8
         JNZ   After_API         Not RC=8, continue
         L     R2,BBOA1INF_RSN   Load address of BBOA1INF RSN
         LHI   R14,WOLA_RSN_INTERNAL_TRY_TWAS_STUB
         CH    R14,2(R2)         Is this a tWAS registration?
         JNZ   After_API         Nope, don't try tWAS version
INF_TWAS DS    0H                Assume tWAS since not Liberty
         MVC   0(BBOA1INF_PC1PRM-BBOA1INF_PLIST,R7),0(R5)   Copy PLIST
         LA    R2,PC1PRMA
         ST    R2,BBOA1INF_PC1PRM-BBOA1INF_PLIST(R7)        Copy PLIST
         ICM   R15,B'1111',VECTTPTR Load tWAS function vector
         JZ    INF_NULL          If no tWAS vector, report error
         USING BBOAXVEC_TWAS,R15
         L     R15,AVECTWAS_INFO@ Load get info function
         DROP  R15
         LR    R1,R7             Place our updated PLIST in R1
         BASR  R14,R15             and call into BBOAINF
         J     After_API
INF_NULL DS 0H
         MVI   BBOA1_RC+3,BBOAAPI_RC_SEVERE12   Drop thru and set
         MVI   BBOA1_RN+3,BBOAAPI_RSN_NO_AMCSS  Drop thru and set
INF_Err  L     R2,BBOA1INF_RC
         MVC   0(4,R2),BBOA1_RC
         L     R2,BBOA1INF_RSN
         MVC   0(4,R2),BBOA1_RN
         DROP  R5
         J     Done
*
After_API DS    0H
         BBOATRC TXT=RETNPC,T=TR_HEAD
*
*----------------------------------------------------------------------
* Check the transactional flags.  We set the schedule flag word if we
* did something that requires processing in this TRUE for a syncpoint.
*----------------------------------------------------------------------
         LH    R9,BBOAPC1P_FLG  Load flags
         LARL  R2,FINSYNCP      Load return-to address        @PM74658C
         TML   R9,BBOAPC1P_TX_DIS_SYNC_MASK Is syncpoint not allowed?
         JZ    CHKSPALW         ..NO - Chk syncpt allowed bit @PM74658C
         OI    BBOACTAA_FLG,BBOACTAA_FLG_NO_SYNCP_MASK Remember that we
*                               need to disallow EC SYNCPOINT
         J     CHKOUTB
CHKSPALW TML   R9,BBOAPC1P_TX_ALLOW_SYNC_MASK Is syncpoint allowed?
         JZ    CHKOUTB          ..NO - Check outb res reqd    @PM74658C
         NI    BBOACTAA_FLG,255-BBOACTAA_FLG_NO_SYNCP_MASK Forget that
*                               we need to disallow EC SYNCPOINT
CHKOUTB  TML   R9,BBOAPC1P_TX_OUTBOUND_MASK Did I do something
*                               transactional that requires outbound
*                               resolution?
         JO    SETOUTB          ..YES  - Tell CICS            @PM74658C
         TML   R9,BBOAPC1P_TX_SET_SCHED_MASK Did I do something
*                               transactional locally?
         JO    SETSYNCP         ..YES  - Tell CICS            @PM74658C
         TM    BBOACTAA_FLG,BBOACTAA_FLG_SYNCP_MASK+BBOACTAA_FLG_SYNCP_x
               NOPC_MASK        Did I do smthg transactional before?
         JNZ   FINSYNCP         ..YES - Don't mod sched flag  @PM74658C
         L     R9,UEPFLAGS      Load address of schedule flag word
         NI    UEFDSYNC(R9),239 Turn off syncpoint manager bit
FINSYNCP DS    0H
*
*----------------------------------------------------------------------
* All done, we're leaving now.
*----------------------------------------------------------------------
DONE     DS    0H
         BBOATRC  TXT=EXITMSG,T=TR_HEAD
         L     R13,4(,R13)      Restore caller's R13
         LM    R14,R12,12(R13)  RESTORE CALLERS REGs
         BSM   0,R14            RETURN TO CALLER
*
SETOUTB  OI    BBOACTAA_FLG,BBOACTAA_FLG_SYNCP_MASK  Remember this task
*                               is transactional and requires the PC
*                               to be driven
SETSYNCP OI    BBOACTAA_FLG,BBOACTAA_FLG_SYNCP_NOPC_MASK Remember this
*                               task is transactional
         L     R9,UEPFLAGS      Load address of schedule flag word
         OI    UEFDSYNC(R9),UEFMSYNC Set syncpoint manager bit
         L     R9,UEPSYNCA      Load address of 1PC / RO flags
         OI    0(R9),UEPSUPDR   Set 1PC protocol understood flag
         BR    R2               Continue....
*
*----------------------------------------------------------------------
* Syncpoint processing section
*----------------------------------------------------------------------
SYNCPT   LA    R6,PC1PRM    Get some storage for PC parms
         USING BBOAPC1P,R6      TODO: Put this directly in TAA
         TM    BBOACTAA_FLG,BBOACTAA_FLG_NO_SYNCP_MASK EC SYNCP Allow?
         JO    SETBAK           ..YES  -- Set FC to backout   @PM74658C
         L     R9,36(,R5)       Get address of function byte 2
         ST    R9,TR_WORD1
         BBOATRC TXT=FUNCB2,VHEX=TR_WORD1,T=TR_HEAD
         L     R4,0(,R9)        Load contents of byte 2
         ST    R4,TR_WORD1
         BBOATRC TXT=FUNCB2A,VHEX=TR_WORD1,T=TR_HEAD
         TM    0(R9),UERTONLY+UERTELUW Is 1PC?
         JZ    CHECKCMT         ..NO  -- Check for 2PC        @PM74658C
         LHI   R9,BBOAAPI_COMMIT1TX Load 1PC function code
         J     SYNCPTFC         Jump to set function code
CHECKCMT L     R9,0(R5)         Get address of function byte 1
         ST    R9,TR_WORD1
         BBOATRC TXT=FUNCB1,VHEX=TR_WORD1,T=TR_HEAD
         L     R4,0(,R9)        Load contents of byte 1
         ST    R4,TR_WORD1
         BBOATRC TXT=FUNCB1A,VHEX=TR_WORD1,T=TR_HEAD
         TM    0(R9),UERTCOMM   Is commit function?
         JZ    CHECKPRP         ..NO  -- Check for prepare    @PM74658C
         LHI   R9,BBOAAPI_COMMIT2TX Load 2PC function code
         J     SYNCPTFC         Jump to set function code
CHECKPRP TM    0(R9),UERTPREP   Is prepare function?
         JZ    CHECKBAK         ..NO  -- Check for backout    @PM74658C
         LHI   R9,BBOAAPI_PREPARETX Load prepare function code
         J     SYNCPTFC         Jump to set function code
CHECKBAK TM    0(R9),UERTBACK   Is backout function?
         JZ    CHECKWT          ..NO -- Check for in-dbt wait @PM74658C
SETBAK   LHI   R9,BBOAAPI_BACKOUTTX Load backout function code
         J     SYNCPTFC         Jump to set function code
CHECKWT  TM    0(R9),UERTWAIT   Is in-doubt wait function?
         JZ    CHECKLST         ..NO  -- Check for lost UOW   @PM74658C
         J     DONE             Nothing to do for WAIT, return
CHECKLST TM    0(R9),UERTDGCS   Is UOW lost due to cold start?
         JZ    CHECKERR         ..NO  -- Check for err in-dbt @PM74658C
         LHI   R9,BBOAAPI_BACKOUTTX Need to back out this UOW
         J     SYNCPTFC         Jump to set function code
CHECKERR TM    0(R9),UERTDGNK   Am I in-doubt when I shouldnt' be?
         JZ    CHECKOTH         ..NO  -- Check for other fcns @PM74658C
         LHI   R9,BBOAAPI_BACKOUTTX Need to back out this UOW
         J     SYNCPTFC         Jump to set function code
CHECKOTH LHI   R9,0             No idea what function this is....
*----------------------------------------------------------------------
* We should have loaded the syncpoint function code by now - see what
* it is
*----------------------------------------------------------------------
SYNCPTFC LTR   R9,R9            Is function code zero?
         JZ    DONE             ..YES -- DONE (TODO - abend)  @PM74658C
         STH   R9,BBOAPC1P_RT   Store function code in PC parm list
         L     R9,0(R5)         Get address of function byte 1
         TM    0(R9),UERTRSYN   Is CICS RESYNC call?
         JZ    SYNPCTAA         ..NO  -- Get PC numr from TAA @PM74658C
SYNPCGAA L     R7,BBOACGAA_PCNUM_TWAS Get cached PC number @576822C
         OI    BBOACTAA_FLG,BBOACTAA_FLG_SYNCP_MASK For RESYNC need to
*                               drive PC no matter what
         J     SYNGOTPC         Got PC number
SYNPCTAA L     R7,BBOACTAA_PCNUM_TWAS Get cached PCnm from TAA @576822C
SYNGOTPC ST    R7,TR_WORD1
         BBOATRC TXT=CACHEPC,VHEX=TR_WORD1,T=TR_HEAD
         LTR   R7,R7            Was PC number cached?
         JZ    DONE             ..NO  -- DONE (TODO - abend)  @PM74658C
         L     R9,UEPURID       Load UOW ID
         LTR   R9,R9            PRESENT?
         JZ    DONE             ..NO  -- DONE (TODO - abend)  @PM74658C
         MVC   BBOAPC1P_UOW,0(R9) Store UOW ID in PC parm list
         LHI   R2,0             Clear BACB register for PC
         STH   R2,BBOAPC1P_FLG  Clear out PC parm flags
*----------------------------------------------------------------------
* Decide if we need to invoke the PC routine
*----------------------------------------------------------------------
         LHI   R15,0            Clear out return code register
         TM    BBOACTAA_FLG,BBOACTAA_FLG_SYNCP_MASK Do we need to PC?
         JZ    AFTERPC          ..NO  -- Skip the PC routine  @PM74658C
         LA    R2,DYNA_LEN(R13) Load next available byte
         LA    R9,ZEROES        Get null node name            @PM74646A
         LR    R1,R6            Put PC parm list address into R1
         L     R15,XBOATRUP
*
*----------------------------------------------------------------------
* CALL BBOATRUP for Syncpoint processing ...
*----------------------------------------------------------------------
*
         BASR  R14,R15          branch to BBOATRUP to pc
*        BBOATRC TXT=RETNPC,T=TR_HEAD
*----------------------------------------------------------------------
* If this syncpoint was not supposed to occur, ABEND
*----------------------------------------------------------------------
AFTERPC  LR    R4,R15           Save the return code in R4
         TM    BBOACTAA_FLG,BBOACTAA_FLG_NO_SYNCP_MASK Disallow EC SYNC
         JZ    AFTERPC1         ..NO - Proceed to set RC      @PM74658C
         XC    BBOACTAA_FLG,BBOACTAA_FLG Clear TAA flags for ABEND
         EXEC  CICS ABEND ABCODE('BBOX')
*----------------------------------------------------------------------
* Re-load the PC1 flags to see if we need to reset the schedule flag
* word (after phase 1).  Then, set the appropriate return code for the
* service in the caller's RSA (register 15).
*----------------------------------------------------------------------
AFTERPC1 LH    R9,BBOAPC1P_FLG  Load flags
         LARL  R2,SYNCPT1       Load return-to address        @PM74658C
         TML   R9,BBOAPC1P_TX_OUTBOUND_MASK Did I do something
*                               transactional?
         JO    SETOUTB          ..YES  -- Tell CICS           @PM74658C
         XC    BBOACTAA_FLG,BBOACTAA_FLG ..NO  -- Clear TAA flags
SYNCPT1  LH    R9,BBOAPC1P_RT   Load the function code
         ST    R4,TR_WORD1 Print the Return Code
         BBOATRC TXT=RETNPC1,VHEX=TR_WORD1,T=TR_HEAD
         CHI   R9,BBOAAPI_COMMIT1TX Did we call 1PC?
         JNE   CHK2PCRC         ..NO  -- Check for 2PC
         LTR   R4,R4            Did 1PC complete successfully?
         JNZ   FAIL1PC          ..NO  -- jump to fail         @PM74658C
         BBOATRC TXT=SYNCPASS,T=TR_HEAD
         LHI   R2,UERFOK        Set 1PC success RC
         J     SETSYNRC         RC set
FAIL1PC  LHI   R2,UERFBOUT      Set 1PC fail RC
         BBOATRC TXT=SYNCFAIL,T=TR_HEAD
         J     SETSYNRC         RC set
CHK2PCRC CHI   R9,BBOAAPI_COMMIT2TX Did we call 2PC?
         JNE   CHKPRPRC         ..NO  -- Check for Prepare
         LTR   R4,R4            Did 2PC complete successfully?
         JNZ   FAIL2PC          ..NO  -- jump to fail         @PM74658C
         LHI   R2,UERFDONE      Set 2PC success RC
         BBOATRC TXT=SYNCPASS,T=TR_HEAD
         J     SETSYNRC         RC set
FAIL2PC  LHI   R2,UERFHOLD      Set 2PC fail RC (TODO: what means?)
         BBOATRC TXT=SYNCFAIL,T=TR_HEAD
         J     SETSYNRC         RC set
CHKPRPRC CHI   R9,BBOAAPI_PREPARETX Did we call Prepare?
         JNE   CHKBAKRC         ..NO  -- Check for Backout
         LTR   R4,R4            Did Prepare complete successfully?
         JNZ   FAILPRP          ..NO  -- jump to fail         @PM74658C
         LHI   R2,UERFPREP      Set Prepare success RC
         BBOATRC TXT=SYNCPASS,T=TR_HEAD
         J     SETSYNRC         RC set
FAILPRP  LHI   R2,UERFBACK      Set Prepare fail RC
         BBOATRC TXT=SYNCFAIL,T=TR_HEAD
         J     SETSYNRC         RC set
CHKBAKRC CHI   R9,BBOAAPI_BACKOUTTX Did we call Backout?
         JNE   CHKOTHRC         ..NO  -- Check for others...
         LTR   R4,R4            Did Backout complete successfully?
         JNZ   FAILBAK          ..NO  -- jump to fail         @PM74658C
         LHI   R2,UERFDONE      Set Backout success RC
         BBOATRC TXT=SYNCPASS,T=TR_HEAD
         J     SETSYNRC         RC set
FAILBAK  LHI   R2,UERFHOLD      Set Backout fai RC (TODO: what means?)
         BBOATRC TXT=SYNCFAIL,T=TR_HEAD
         J     SETSYNRC         RC set
CHKOTHRC J     DONE             Who knows... (TODO: ABEND)
SETSYNRC L     R9,UEPHMSA       ADDRESS CALLER'S RSA
         ST    R2,TR_WORD1
         BBOATRC TXT=RETNPC2,VHEX=TR_WORD1,T=TR_HEAD
         ST    R2,16(,R9)       Store RC in Caller's R15
         CHI   R2,UERFHOLD      Do we need to sched a retry?  @PM74646A
         JNE   DONE             ..NO -- Syncpoint is finished @PM74646C
*----------------------------------------------------------------------
* We need to reschedule resolution of this transaction.  The BBOACNTL
* program handles this.  The customer gets to assign the transaction ID
* used to start BBOACNTL.  We saved this when the TRUE was started.
* Check to make sure that there is a valid transaction ID in the GAA.
*----------------------------------------------------------------------
         CLC   BLANKTXN,BBOACGAA_CTL_TRAN Is tran name blank? @PM74646A
         JE    NOCNTLTX         ..YES - can't reschedule.     @PM74646A
         CLC   ZEROES(4),BBOACGAA_CTL_TRAN Is tran name null? @PM74646A
         JE    NOCNTLTX         ..YES - can't reschedule.     @PM74646A
*----------------------------------------------------------------------
* Get the UOW ID and convert it to a printable string, so that it can
* be passed to BBOACNTL.
*----------------------------------------------------------------------
         MVC   GENMSG(18),=CL18'BBOC TXRESYNC UOW='           @PM74646A
         L     R9,UEPURID                                     @PM74646A
         UNPK  GENMSG+18(15),0(8,9)                           @PM74646A
         MVC   GENMSG+18+15(1),GENMSG+18+14                   @PM74646A
         OI    GENMSG+18+14,X'F0'                             @PM74646A
         IC    R9,GENMSG+18+15                                @PM74646A
         SRA   R9,4                                           @PM74646A
         OILL  R9,X'00F0'                                     @PM74646A
         STC   R9,GENMSG+18+15                                @PM74646A
         TR    GENMSG+18(16),XLATE-X'F0'                      @PM74646A 
*----------------------------------------------------------------------
* Schedule BBOACNTL.
*----------------------------------------------------------------------
         EXEC  CICS START TRANSID(BBOACGAA_CTL_TRAN) AFTER SECONDS(30) X
               FROM(GENMSG) LENGTH(STRTMSGL)
         CLC   EIBRESP,DFHRESP(NORMAL) Did it work?           @PM74646A
         JE    DONE             ..YES -- we are done.         @PM74646A
*----------------------------------------------------------------------
* If the schedule fails, we'll ABEND to draw attention to the problem.
*----------------------------------------------------------------------
NOCNTLTX DS 0H                                                @PM74646A
         EXEC  CICS ABEND ABCODE('BBOX')
*----------------------------------------------------------------------
*
* Process context management request section
*
*----------------------------------------------------------------------
CONTREQ  DS    0H                           TRUE called for context mgt
         LHI   R15,0
         C     R15,INQUIREC  Are we at CICS TS 4.2+ level?
         JZ    DONE          No... done.
*
         BBOATRC TXT=CONTMSG,T=TR_HEAD
*
*---------------------------------------------------------------------
* Verify that the EXEC CICS START TRAN() is for a transaction with
* a program name of BBOACLNK, else let it pass by.            @711599A
*---------------------------------------------------------------------
* Look for the OLA link server program, BBOACSRV. If we find this,
* we know this is an EC START TRAN it's issued for a Link task (BBO#).
*---------------------------------------------------------------------
*
         L     R15,INQUIREC     Load inquire current program
         LR    R4,R3            Save DFHUEPAR in R4
         L     R3,UEPRMSTK      Load kernel stack address
         BASR  R14,R15          Call inquire current program
         LR    R3,R4            Restore DFHUEPAR
         MVC   CURRPROG,0(R15)  Copy current program name
         LR    R4,R0            Can't use base/disp on R0
         MVC   INVKPROG,0(R4)   Copy invoking program name
*
         BBOATRC TXT=CURRNAMEL,VSTR=CURRPROG,VL=8,T=TR_HEAD
         BBOATRC TXT=INVKNAMEL,VSTR=INVKPROG,VL=8,T=TR_HEAD
*
         CLC   INVKPROG(8),LINKSRVR Is it the link task?      @711599A
         JNE   DONE                                           @711599A
*
*---------------------------------------------------------------------
* Get to context management parameters and return context data.
*---------------------------------------------------------------------
         L     R7,UEPHMSA                   Get pointer to caller's RSA
         L     R7,24(,R7)                   Point to plist
         L     R15,XBOACONT                 Load ctx mgt function
         BASR  R14,R15              Call context management function
         J     DONE                         Finished
*
*----------------------------------------------------------------------
* Task end section
*
* See if there is a TS QUEUE named BBO<taskn> that needs to be cleaned
* up.  This means that a link task ended prematurely due to an abend or
* other unknown condition.
*----------------------------------------------------------------------
ENDTASK  DS    0H
         EXEC  CICS ASSIGN ABCODE(ABENDCDE) ABPROGRAM(ABENDPGM)
         CLC   ABENDCDE,=CL4'    ' Did abend occur?
         JE    DONE             ..NO  -- Get out of here      @PM74658C
         UNPK  TASKN,EIBTASKN   Convert task number to EBCDIC
         OI    TASKN+7,X'F0'   Remove sign from last byte
         MVC   TASKN(3),=CL3'BBO' Create queue name prefix
         LHI   R2,BBOACLNK_SIZ  Load size of BBOACLNK block
         STH   R2,TSQLEN        Store size in halfword for EXEC
         EXEC  CICS READQ TS QUEUE(TASKN) INTO(ACLNKEYE)               X
               LENGTH(TSQLEN) RESP(RESPCODE)
         CLC   RESPCODE,DFHRESP(NORMAL) Did queue read complete ok?
         JNZ   DONE             ..NO  -- Can't proceed        @PM74658C
*----------------------------------------------------------------------
* PM70002 : Delete the TSQ now after an ABEND. Otherwise it will leak.
*----------------------------------------------------------------------
         EXEC  CICS DELETEQ TS QUEUE(TASKN) RESP(RESPCODE)
*----------------------------------------------------------------------
* No need to lookup the WOLA function vectors - by the time we get here
* the TRUE would have already been invoked at least once so the
* dynamic area (in task storage) will already be set up.
* Build the message we'll send back to the WAS caller.
*----------------------------------------------------------------------
         MVC   MSGSTG1,ABENDM1
         MVC   MSGSTG2,ABENDM2
         LA    R6,PC1PRM
         USING BBOAPC1P,R6
         XC    BBOAPC1P,BBOAPC1P Clear PC Parms area
         L     R2,BBOACGAA_TRACELVL Get trace enabled setting
         ST    R2,BBOAPC1P_TRACELVL Save trace enabled setting
         LA    R2,BBOACGAA_PCNUM_TWAS Get addr of cached PC number
         ST    R2,BBOAPC1P_GAA_PCNUM@ and Save it in PC1P
         LA    R2,BBOACTAA_PCNUM_TWAS Get addr of cached PC number
         ST    R2,BBOAPC1P_TAA_PCNUM@ and Save it in PC1P
         L     R2,UEPSECFLG     Load address of security flag byte
         TM    0(R2),UEPSEC     Is security enabled?
         JZ    SRXNOSEC         ..NO  -- Skip setting ACEE    @PM74658C
         L     R2,UEPSECBLK     Get CICS app's ACEE addr@
         L     R2,0(,R2)        Get CICS app's ACEE addr
         ST    R2,BBOAPC1P_ACEE Save it in PC parm list
SRXNOSEC L     R2,UEPURID       Load address of UOW ID
         LTR   R2,R2            Is UOW ID set?
         JZ    SRXNOUOW         ..NO  -- Skip setting UOW     @PM74658C
         MVC   BBOAPC1P_UOW,0(R2) Move UOW to PC parm list
SRXNOUOW XC    WOLA64P,WOLA64P  Clear parm list storage
         LA    R7,WOLA64P
         USING WOLA_CLIENT_SENDEXCP_PARMS,R7
         LA    R2,ACLNK_CONNHDL
         ST    R2,WOLA_CLIENT_SENDEXCP_HANDLE+4
         LA    R2,MSGSTG1
         ST    R2,WOLA_CLIENT_SENDEXCP_DATA+4
         LA    R2,ABENDML
         ST    R2,WOLA_CLIENT_SENDEXCP_DATAL+4
         ST    R6,WOLA_CLIENT_SENDEXCP_CICSPRM+4
         LA    R2,BBOA1_RC
         ST    R2,WOLA_CLIENT_SENDEXCP_RC+4
         LA    R2,BBOA1_RN
         ST    R2,WOLA_CLIENT_SENDEXCP_RSN+4
         ICM   R15,B'1111',VECTPTR  Do we have the liberty stub loaded?
         JZ    TWAS_001
         USING BBOAXVEC,R15
         L     R15,AVECCSRX+4    Load addr of send resp exc fcn
         DROP  R15
         STMH  R0,R15,WOLA64HH   Store high halves of registers
         LMH   R0,R15,ZEROES     Clear high halves of registers
         LR    R9,R13            Save CTAA address
         LA    R13,WOLA64SA      Load F4SA address for caller
         LR    R1,R7             Place our 64 bit parm list in R1
         SAM64                   Switch to 64 bit mode.
         BASR  R14,R15           Call into BBOASRX
         SAM31                   Switch back to 31 bit mode
         LR    R13,R9            Restore CTAA address
         LHI   R14,BBOAAPI_RC_ERROR8 Check BBOA1SRX response
         C     R14,BBOA1_RC      Is it RC=8
         JNZ   NOTTWAS1          Not RC=8, continue
         LHI   R14,WOLA_RSN_INTERNAL_TRY_TWAS_STUB
         CH    R14,BBOA1_RN+2    Is this a tWAS registration?
         JZ    TWAS_001          Yes, try tWAS version
         DROP  R7
         USING WOLA_CLIENT_CONNREL_PARMS,R7
NOTTWAS1 LA    R2,ACLNK_CONNHDL
         ST    R2,WOLA_CLIENT_CONNREL_HANDLE+4
         ST    R6,WOLA_CLIENT_CONNREL_CICSPRM+4
         LA    R2,BBOA1_RC
         ST    R2,WOLA_CLIENT_CONNREL_RC+4
         LA    R2,BBOA1_RN
         ST    R2,WOLA_CLIENT_CONNREL_RSN+4
         L     R15,VECTPTR
         USING BBOAXVEC,R15
         L     R15,AVECCCNR+4
         DROP  R15
         LR    R9,R13            Save CTAA address
         LA    R13,WOLA64SA      Load F4SA address for caller
         LR    R1,R7             Place our 64 bit parm list in R1
         SAM64                   Switch to 64 bit mode.
         BASR  R14,R15           Call into BBOACNR
         SAM31                   Switch back to 31 bit mode
         LR    R13,R9            Restore CTAA address
         LMH   R0,R15,WOLA64HH   Restore high halves of registers
         DROP  R7
         J     DONE                                           @PM74658C
TWAS_001 DS    0H
*----------------------------------------------------------------------
* Use the tWAS services to send the exception response and close the
* connection.         
*----------------------------------------------------------------------
         USING BBOA1SRX_PLIST,R7
         LA    R2,ACLNK_CONNHDL
         ST    R2,BBOA1SRX_CONNHDL
         LA    R2,MSGSTG1
         ST    R2,EXCDATAP
         LA    R2,EXCDATAP
         ST    R2,BBOA1SRX_RSPDATA
         LA    R2,ABENDML
         ST    R2,BBOA1SRX_RSPDATAL
         LA    R2,BBOA1_RC
         ST    R2,BBOA1SRX_RC
         LA    R2,BBOA1_RN
         ST    R2,BBOA1SRX_RSN
         ST    R6,PC1PRMA        Save addr of parm area for tWAS stubs
         DROP  R6
         LA    R6,PC1PRMA
         ST    R6,BBOA1SRX_PC1PRM
         L     R15,VECTTPTR      Load the tWAS stubs
         USING BBOAXVEC_TWAS,R15
         L     R15,AVECTWAS_SNRX@ Load addr of send resp exc fcn
         DROP  R15
         LR    R1,R7             Place our 64 bit parm list in R1
         BASR  R14,R15           Call into BBOASRX
         DROP  R7
         USING BBOA1CNR_PLIST,R7
         LA    R2,ACLNK_CONNHDL
         ST    R2,BBOA1CNR_CONNHDL
         LA    R2,BBOA1_RC
         ST    R2,BBOA1CNR_RC
         LA    R2,BBOA1_RN
         ST    R2,BBOA1CNR_RSN
         ST    R6,BBOA1CNR_PC1PRM
         L     R15,VECTTPTR
         USING BBOAXVEC_TWAS,R15
         L     R15,AVECTWAS_CONR@
         DROP  R15
         LR    R1,R7             Place our 64 bit parm list in R1
         BASR  R14,R15           Call into BBOACNR
         DROP  R7
         J     DONE                                           @PM74658C
*
WRITE_CICS_TRC DS 0H                                         @576822A
         MVC   DBGMSG+0(4),EIBTRNID                          @576822A
         MVI   DBGMSG+4,C' '                                 @576822A
         UNPK  DBGMSG+5(8),EIBTASKN(4)                       @576822A
         OI    DBGMSG+12,X'F0'                               @576822A
         MVI   DBGMSG+13,C' '                                @576822A
         MVC   DBGMSG+14(60),TRCEDATM                        @576822A
         EXEC  CICS WRITEQ TD QUEUE('BBOQ')                            X
               FROM(DBGMSG) LENGTH(DBGMSGL) NOHANDLE
         BR    R8                                            @576822A
         DROP  DFHEIBR                                        @PM74658A
*
*
STATICS  LTORG                                                @PM74658C
         COPY  BBOATRC2
*
ENTRMSG  DC    CL60'BBOATRUE: Entered.                                 X
                       '
R1ADDR   DC    CL60'BBOATRUE: R1 on entry             ----->>          X
                        '
CALLR1   DC    CL60'BBOATRUE: TRUE Caller R1          ----->>          X
                        '
CALLSTB@ DC    CL60'BBOATRUE: TRUE Caller Stub EPA    ----->>          X
                        '
EYEC     DC    CL60'BBOATRUE: R15 eyecatcher          ----->>          X
                        '
BADSTUB  DC    CL60'BBOATRUE: Unrecognized STUB! Terminate.            X
                        '
CALLSTUB DC    CL60'BBOATRUE: Called from stub        ----->>          X
                        '
PCNUM    DC    CL60'BBOATRUE: PC number               ----->>          X
                        '
BACBADDR DC    CL60'BBOATRUE: BACB address            ----->>          X
                        '
RETNPC   DC    CL60'BBOATRUE: Returned from PC.                        X
                       '
EXITMSG  DC    CL60'BBOATRUE: WAS-CICS TRUE exiting.                   X
                       '
FUNCB1   DC    CL60'BBOATRUE: Syncpoint Function Byte 1 @ ---->>       X
                       '
FUNCB2   DC    CL60'BBOATRUE: Syncpoint Function Byte 2 @ ---->>       X
                       '
FUNCB1A  DC    CL60'BBOATRUE: Contents of Byte 1          ---->>       X
                       '
FUNCB2A  DC    CL60'BBOATRUE: Contents of Byte 2          ---->>       X
                       '
CACHEPC  DC    CL60'BBOATRUE: Cached PC number            ---->>       X
                       '
RETNPC1  DC    CL60'BBOATRUE: PC returncode               ---->>       X
                       '
SYNCFAIL DC    CL60'BBOATRUE: Set function failed                      X
                       '
SYNCPASS DC    CL60'BBOATRUE: Set function succeeded                   X
                       '
RETNPC2  DC    CL60'BBOATRUE: Setting R15 in caller       ---->>       X
                       '
CURRNAME DC    CL60'BBOATRUE: Current program name        ---->>       X
                       '
INVKNAME DC    CL60'BBOATRUE: Invoking program name       ---->>       X
                       '
CURRNAMEL DC   CL60'BBOATRUE: EC START current pgm name   ---->>       X
                       '
INVKNAMEL DC   CL60'BBOATRUE: EC START invoking pgm name  ---->>       X
                       '
LINKSRV  DC    CL60'BBOATRUE: Link server name            ---->>       X
                       '
CONTMSG  DC    CL60'BBOATRUE: Processing Context management call       X
                       '
SETCNTX  DC    CL60'BBOATRUE: Setting flag for Context mgt calls       X
                       '
ABENDM1  DC    CL31'BBOA8950I Captured abend code: '
ABENDM2  DC    CL12' in program '
XBOATRUP DC    A(X'80000000'+BBOATRUP)
XBOABS53 DC    A(X'80000000'+BBOABS53)           @711599A
XBOABS52 DC    A(X'80000000'+BBOABS52)           @711599A
XBOABS51 DC    A(X'80000000'+BBOABS51)           @711599A
XBOABS42 DC    A(X'80000000'+BBOABS42)           @711599A
XBOABS41 DC    A(X'80000000'+BBOABS41)           @711599A
XBOAIC53 DC    A(X'80000000'+BBOAIC53)
XBOAIC52 DC    A(X'80000000'+BBOAIC52)
XBOAIC51 DC    A(X'80000000'+BBOAIC51)
XBOAIC42 DC    A(X'80000000'+BBOAIC42)
XBOACONT DC    A(X'80000000'+BBOACONT)
DBGMSGL  DC    H'80'                             @576822A
STRTMSGL DC    H'34'            Length of START data          
ABENDML  DC    F'55'            Length of ABEND message
BLANKTXN DC    CL4'    '        A blank CICS transaction name 
ZEROES   DC    64X'0'           Zeros used to clear things.
XLATE    DC    CL16'0123456789ABCDEF' Unpack translation tbl  
CTAAEYE  DC    CL8'BBOACTAA'
F4SAEYE  DC    CL4'F4SA'
LINKSRVR DC    C'BBOACSRV'                       @711599A
         EXTRN BBOATRUP
         EXTRN BBOABS53
         EXTRN BBOABS52
         EXTRN BBOABS51
         EXTRN BBOABS42
         EXTRN BBOABS41
         EXTRN BBOACONT
         EXTRN BBOAIC53
         EXTRN BBOAIC52
         EXTRN BBOAIC51
         EXTRN BBOAIC42
*
BBOAAPI_PREPARETX EQU X'0102'
BBOAAPI_COMMIT1TX EQU X'0103'
BBOAAPI_COMMIT2TX EQU X'0104'
BBOAAPI_BACKOUTTX EQU X'0105'
*
         DFHUEXIT TYPE=RM
         IHAPSA
*
* DFHSMSRY Mapping (for switch to base space)
         COPY DFHSMSRY
* *******************************************************************
* *******************************************************************
* START OF TAA (AKA DYNAMIC AREA)
* *******************************************************************
* *******************************************************************
*
* BBOATRUE Task Work Area mapping
         COPY BBOACTAA  
STB      DS CL8
TASKN    DS CL8
TSQLEN   DS H
RESPCODE DS F
MSGSTG1  DS CL31                First part of ABEND Message
ABENDCDE DS CL4                 ABEND code fillin
MSGSTG2  DS CL12                Second part of ABEND Message
ABENDPGM DS CL8                 PROGRAM fillin
         ORG MSGSTG1                                          @PM74646A
GENMSG   DS CL55                Generic message area          @PM74646A
BBOA1_RC DS F                   BBOA1SRX RC in END TASK
BBOA1_RN DS F                   BBOA1SRX RSN in END TASK
VECTPTR  DS A                   BBOAXVEC pointer for Liberty
VECTTPTR DS A                   BBOAXVEC pointer for tWAS
EXCDATAP DS A                   Pointer to exception data buffer (tWAS)                   
PC1PRMA  DS A                   Address of BBOAPC1P area (for tWAS)
PC1PRM   DS CL64                Area to use for BBOAPC1P
WOLA64P  DS CL128               Area to use for call to 64 bit mc stub
WOLA64SA DS CL160               Save area for call to 64 bit mc stub
WOLA64HH DS CL64                Area to store HH of registers in
TSLVL    DS CL6                 CICS level
         DS 0F
CURRPROG DS CL8              Current pgm name    @711599A
INVKPROG DS CL8              Invoking pgm name   @711599A
BASESPAC DS A                   Switch to base space program
INQUIREC DS A                Inquire current program
TR_HEAD  DS CL5
         DS 0F
TR_WORD1 DS CL4
         COPY  BBOATRC1
DBGMSG   DS CL80
         BBOACLNK
*
DFHEIBR  EQU 11                                               @PM74658C
         DFHEISTG DSECT=NO    RSA FOR CICS CMDS  @576822A
         DS 0F
* Compute dynamic area length
DYNA_LEN EQU *-BBOACTAA
* *******************************************************************
* *******************************************************************
* END OF TAA (AKA DYNAMIC AREA)
* *******************************************************************
* *******************************************************************
*
* EIB mapping                                    @576822A
         COPY DFHEIBLK                           @576822A
*
* PC1 Parms
          BBOAPC1P
*
* CVT/ECVT/BGVT etc
          CVT   DSECT=YES
          IHAECVT DSECT=YES
          BBODBGVT DSECT=YES
          BBOAMCST
*********************************************************************
* BBOAXVEC Vector mapping                                           *
*********************************************************************
          COPY BBOAXVEC
*
* Parameter mappings for all APIs assembler/PLX
          BBOAXPRM
*
* BBOATRUE Global Work Area mapping              @576822A
          BBOACGAA                               @576822A

          END  BBOATRUE
