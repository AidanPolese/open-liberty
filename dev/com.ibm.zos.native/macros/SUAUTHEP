*
* IBM Confidential
*
* OCO Source Materials
*
* Copyright IBM Corp. 2011
*
* The source code for this program is not published or otherwise
* divested of its trade secrets, irrespective of what has been
* deposited with the U.S. Copyright Office.
*
         MACRO
&NAME    SUAUTHEP &SAVEAREA=
         GBLC  &CCN_CSECT
         GBLC  &CCN_LITN
         GBLB  &BBGZ_SUAUTHEP_DSECT
* --------------------------------------------------------------------
* IMPORTANT NOTE
* This exit linkage clobbers the next/prev DSA pointers of the 144
* byte save area that it is given.  It assumes that the caller can
* find its save area without using the prev DSA pointer (backchain).
* This is true when calling from an XPLINK program, which has its own
* way to transition back to the XPLINK stack when the routine is
* finished.
* --------------------------------------------------------------------
*
* We saved the return code from name token create (IEAN4CR) 8 bytes
* back from the dynamic area.  If the name token create was
* successful, then we don't need to free our dynamic area storage
* because it's hung off the name token for the next caller.
*
         LGR  1,13             Copy dynamic area address to reg 1
         AGHI 1,-8             Subtract to find IEAN4CR return code
         L    2,0(1)           Load return code
         LTR  2,2              Test return code
         BRZ  SUAUTHEPNONEEDTOFREE&SYSNDX 
*
* Free the dynamic area
*
         LGR  2,15             Save return code in register 2
         NILH 1,X'FFFE'        Subtract 64K prefix from dynamic area
         LG   13,128(13)       Restore caller provided RSA.
         USING SUAUTHEP_SAVEAREA,13
         LMG  3,12,SUAUTHEP_SAVEAREA_R3T12 Restore regs 3 thru 12
         STG  1,SUAUTHEP_SAVEAREA_IARV64_ORG Store address to free
         IARV64 REQUEST=DETACH,MATCH=SINGLE,                           X
               MEMOBJSTART=SUAUTHEP_SAVEAREA_IARV64_ORG,               X
               USERTKN=NO_USERTKN,COND=NO,PLISTVER=0,                  X
               MF=(E,SUAUTHEP_SAVEAREA_IARV64_PL,COMPLETE)
         AIF ('&SAVEAREA' NE '72').LARGESAVEAREA1
         LGR   3,13            Save storage address for release
         LG   13,0(13)         Restore caller provided RSA.
         LARL  4,&CCN_LITN
         USING &CCN_LITN,4
         STORAGE RELEASE,LENGTH=IPTE_TEMP_STORAGE_LEN,ADDR=(3)
         DROP 4
         LGR  15,2             Restore reg 15 (return code)
         LMG  1,4,SUAUTHEP_SAVEAREA_R1T2 Restore regs 1 thru 4
         LG   14,8(13)         Restore reg 14
         AGO .COMMONEXIT1
.LARGESAVEAREA1 ANOP
         LG   14,SUAUTHEP_SAVEAREA_R14 Restore reg 14
         LGR  15,2             Restore reg 15 (return code)
         LMG  1,2,SUAUTHEP_SAVEAREA_R1T2 Restore regs 1 thru 2
.COMMONEXIT1 ANOP
         BR   14               Return to caller
         DROP 13
SUAUTHEPNONEEDTOFREE&SYSNDX DS 0H
*
* Try to unset the in-use bit in the prefix.
*
         LGR   3,1         Compute server task data in reg 3
         NILH  3,X'FFFE'   Subtract 64K prefix from dynamic area
         LGHI 6,-1 Load non-zero into R6 (expected value)
         LGHI 7,0  Load zero into R7
         CS   6,7,36(3) Try to return the dynamic area
         BRZ  RTNTOCALLER&SYSNDX Branch if we returned the dyn area
         LARL  5,&CCN_LITN
         USING &CCN_LITN,5
         ABEND ABEND_TYPE_SERVER,REASON=KRSN_SUAUTHEP_STACK_IN_USE,    X
               DUMP,STEP,SYSTEM
         DROP  5
RTNTOCALLER&SYSNDX DS 0H
         LG   13,128(13)       Restore caller provided RSA.
         LMG  1,12,32(13)      Restore regs 1 thru 12
         AIF ('&SAVEAREA' NE '72').COMMONEXIT2
         LGR  2,13             Save storage address for release
         LG   13,0(13)         Restore caller provided RSA.
         LARL  3,&CCN_LITN
         USING &CCN_LITN,3
         LGR  4,15             save reg 15 (return code)
         STORAGE RELEASE,LENGTH=IPTE_TEMP_STORAGE_LEN,ADDR=(2)
         DROP 3
         LGR  15,4             restore reg 15 (return code)
         USING SUAUTHEP_SAVEAREA,13
         LMG  1,4,SUAUTHEP_SAVEAREA_R1T2 Restore regs 1 thru 4
         DROP 13
.COMMONEXIT2 ANOP
         LG   14,8(13)         Restore reg 14
         BR   14               Return to caller
*
* Define the DSECTs we're going to use if this is the first time the
* macro is being invoked.
*
         AIF (&BBGZ_SUAUTHEP_DSECT).NODSECT
&BBGZ_SUAUTHEP_DSECT SETB 1
SUAUTHEP_SAVEAREA        DSECT    Caller provided F4SA
SUAUTHEP_SAVEAREA_RSVD   DS CL8   Header
SUAUTHEP_SAVEAREA_R14T2  DS CL40  Registers 14, 15, 0, 1 and 2
                        ORG SUAUTHEP_SAVEAREA_R14T2
SUAUTHEP_SAVEAREA_R14    DS CL8
SUAUTHEP_SAVEAREA_R15T0  DS CL16
SUAUTHEP_SAVEAREA_R1T2   DS CL16
SUAUTHEP_SAVEAREA_R3T12  DS CL80  Registers 2 thru 12
                        ORG SUAUTHEP_SAVEAREA_R3T12
SUAUTHEP_SAVEAREA_IARV64_ORG DS FD  Returned memory origin address
SUAUTHEP_SAVEAREA_IARV64_PL  DS CL88 Parameter list for v0
*
IPTE_TEMP_STORAGE_LEN EQU 512     Length of temporary storage
*
         RASABEND
*
&CCN_CSECT CSECT
.NODSECT ANOP
*
         MEND
