*
* IBM Confidential
*
* OCO Source Materials
*
* Copyright IBM Corp. 2011
*
* The source code for this program is not published or otherwise
* divested of its trade secrets, irrespective of what has been
* deposited with the U.S. Copyright Office.
*
         MACRO
&NAME    SAUTHPRL &CLIENT=NO,&ABENDINU=,&TOKENPRM=DFLT
         GBLC  &CCN_LITN
         GBLC  &CCN_CSECT
         GBLB  &BBGZ_SERVER_AUTH_PROLOG_DSECT
*
* NOTE name below TKNNAME must match that in
*      server_common_function_module.mc
*
&TKNNAME SETC 'BBGZCMPD'
*
* Save the caller's registers, then see if this task has a TGOO hung
* off of the common task data anchor (STCBBCBA in Liberty).
*
* While we are saving all of the registers here, the save area for
* registers 2-11 is used in some paths for a parameter list.  In
* these paths, it is assumed that registers 2-11 have not been
* modified, and that they will be re-saved when we are done with
* the parameter list.
*
         STMG  14,12,8(13)
         XGR   12,12 Clear our scratch area
         AIF ('&CLIENT' EQ 'YES').OBTAINTGOOCELL
         USING PSA,0
         LLGT  15,PSATOLD  Load TCB from PSA
         DROP  0
         USING TCB,15
         LLGT  15,TCBSTCB  Load STCB from PSA
         DROP  15
         USING STCB,15
         LLGT  15,stcbbcba Load common task data anchor
         DROP  15
         LTGR  15,15       Is common task data anchor set?
         BRZ   NOTGOO&SYSNDX No
         LG    15,24(15)   Load server task data
         LTGR  15,15       Is server task data set?
*
* In the normal path, if there is a TGOO we want to use it, doing a
* compare-and-swap to indicate that we are using it, and ABENDing if
* somehow the TGOO is in use by some other task/code.  However in
* the thread-recovery case, the TGOO may be in use by the thread
* itself.  In that case we want to allocate new storage in the event
* the TGOO is already in-use.
*
         AIF ('&ABENDINU' EQ 'NO').BRANCHCHECKTGOO
         BRNZ  TAKETGOO&SYSNDX Yes - use it
         AGO .ALLOCATETGOO
.BRANCHCHECKTGOO ANOP
         BRZ   NOTGOO&SYSNDX No
         LLGF  6,36(,15)   Get dynarea in use word    
         LTGR  6,6         Was task dynarea in use?
         BRZ   FINISH&SYSNDX No - use it
         AGO   .ALLOCATETGOO
*
* In the client process, try to obtain a TGOO cell from the client
* process data.  The caller had to pass the token on the call and
* we need to know what parameter it is in.  We'll be using part of
* our save area to build the parameter list to name token services,
* so we will need to store some registers later.
*
* NOTE that TOKENPRM should be set to the index of the parameter
*      in the metal C parameter list which contains the client
*      token, and that the client token should be passed as a
*      'long long' so that the value of the token occupies that
*      slot of the parameter list, and not the address of the token.
*      Index 1 is the first parameter.
*
.OBTAINTGOOCELL ANOP
         AIF ('&TOKENPRM' EQ 'DFLT').ALLOCATETGOO
         USING SAUTHPRL_SAVEAREA,13
         LARL  15,&CCN_LITN  Address literals (for name token name)
         USING &CCN_LITN,15
         MVC   SAUTHPRL_SAVEAREA_TOKNAM,=CL8'&TKNNAME' Copy 1st name
         DROP  15
         LGHI  15,&TOKENPRM-1 Get the position of the token
         SLAG  15,15,3(0)   Multiply by 8 (shift 3)
         LG    15,0(15,1)   Load the token into R15
         STG   15,SAUTHPRL_SAVEAREA_TOKNAM2 Copy 2nd name (token)
         LGHI  15,IEANT_HOMEAUTH_LEVEL  Name token is for home AS
         ST    15,SAUTHPRL_SAVEAREA_TOKLVL Store task level constant
*
         LA    1,SAUTHPRL_SAVEAREA_TOKPL Load the parm list addr
         USING SAUTHPRL_IEAN4RT_PL,1
         LA    15,SAUTHPRL_SAVEAREA_TOKLVL Load addr of level const
         STG   15,SAUTHPRL_IEAN4RT_PL_LVL  Store as 1st parm
         LA    15,SAUTHPRL_SAVEAREA_TOKNAM Load addr of name token name
         STG   15,SAUTHPRL_IEAN4RT_PL_NAME Store as 2nd parm
         LA    15,SAUTHPRL_SAVEAREA_TOKTOK Load addr to store tkn into
         STG   15,SAUTHPRL_IEAN4RT_PL_TOK  Store as 3rd parm
         LA    15,SAUTHPRL_SAVEAREA_TOKRC  Load addr to put RC into
         STG   15,SAUTHPRL_IEAN4RT_PL_RC   Store as 4th parm
SAUTHPRL_IEAN4RT_&SYSNDX ALIAS C'IEAN4RT'
         CALL  SAUTHPRL_IEAN4RT_&SYSNDX Call name token retrieve
         L     15,SAUTHPRL_SAVEAREA_TOKRC  Load the return code to R15
         LTR   15,15     Check the return code (0 = good)
         BRZ   SAUTHPRLFOUNDTOK&SYSNDX
         DROP  1
         LMG   14,1,SAUTHPRL_SAVEAREA_R14T1 Restore Regs 14-1
         STMG  2,11,SAUTHPRL_SAVEAREA_R2T11 Replace save area regs
         B     NOTGOO&SYSNDX Go allocate dynamic area using IARV64
*
* Go get a cell from the task data cell pool, hung off of the process
* data that we just looked up by name token.
*
SAUTHPRLFOUNDTOK&SYSNDX DS 0H
         LG    15,SAUTHPRL_SAVEAREA_TOKPTR Get process data addr
         LG    15,48(15) Get addr of cell pool (0x30 off R15)
         LG    1,8(15) Load cell pool anchor address
         STG   1,SAUTHPRL_SAVEAREA_CPANCH Cache cell pool anchor
         CALL CSRC4RGT Try to get a cell from the cell pool.
         LTR   15,15 Is return code good?
         BRZ   GOODCELL&SYSNDX Yes, got a cell, in R1.
         LGHI  14,8  Load 'no more cells' return code.
         CR    15,14 See if we got the 'no more cells' return code.
         BNZ   BADCELL&SYSNDX Nope, some other problem
         OILL  12,SAP_SCRATCH_MASK_MORECELL Grow pool later
BADCELL&SYSNDX DS 0H
         STMG  2,11,SAUTHPRL_SAVEAREA_R2T11 Replace save area regs
         LMG   14,1,SAUTHPRL_SAVEAREA_R14T1 Restore Regs 14-1
         B     NOTGOO&SYSNDX Go allocate dynamic area using IARV64
*
* Fix up the registers, then save the address of the cell pool so
* that we can use it in the epilog to return this cell back to
* the cell pool.
*
GOODCELL&SYSNDX DS 0H
         LG    15,SAUTHPRL_SAVEAREA_CPANCH Restore cell pool anchor
         STMG  2,11,SAUTHPRL_SAVEAREA_R2T11 Replace save area regs
         LGR   2,15 Move cell pool anchor into R2
         LGR   7,1 Move dynamic area into R7
         ICM   15,B'1111',0(7) See if dyn area eye catcher is set
         BZ    SETEYE&SYSNDX Branch if eye catcher not set
         LGR   15,7 Next code assumes dyn area is in R15
         B     FINISH&SYSNDX Branch if eye catcher already set
.ALLOCATETGOO ANOP
NOTGOO&SYSNDX DS 0H
*
* No server task data created yet.  We need to get a dynamic area
* for this task using IARV64.  We don't have room in the save area
* to put the parameter list for IARV64 because we can't clobber
* the back chain pointer in the save area.  We need to get some
* temporary storage using storage obtain, which we can then use to
* call IARV64.
*
         XGR   2,2 Clear reg 2 - not using cell pool for dyn area
         LARL  5,&CCN_LITN
         USING &CCN_LITN,5
         STORAGE OBTAIN,LENGTH=SAP_TEMP_STORAGE_LEN,BNDRY=DBLWD,       X
               SP=SAP_TEMP_STORAGE_SUBPOOL,KEY=SAP_TEMP_STORAGE_KEY
         LGR   6,1 Move obtained temp storage to register 6
         USING SAP_IARV64,6
         LGHI  15,SAP_IARV64_DYN_AREA_SEGMENTS Get two segments 2MB
         STG   15,SAP_IARV64_SEGCT Store segment count
         LGHI  15,SAP_IARV64_DYN_AREA_GUARD_SEGMENTS One seg. guard
         ST    15,SAP_IARV64_GUARDSZ Store guard count
         LGHI  15,SAP_IARV64_DYN_AREA_STORAGE_KEY Use key 2 storage
         STC   15,SAP_IARV64_KEY Store key
         IARV64 REQUEST=GETSTOR,COND=NO,SEGMENTS=SAP_IARV64_SEGCT,     X
               KEY=SAP_IARV64_KEY,FPROT=NO,SVCDUMPRGN=YES,             X
               GUARDSIZE=SAP_IARV64_GUARDSZ,CONTROL=AUTH,GUARDLOC=HIGH,X
               USERTKN=NO_USERTKN,ORIGIN=SAP_IARV64_ORIGIN,PLISTVER=0, X
               MF=(E,SAP_IARV64_PLIST,COMPLETE)
         LG    7,SAP_IARV64_ORIGIN  Load new dynamic area address
         STORAGE RELEASE,LENGTH=SAP_TEMP_STORAGE_LEN,ADDR=(6),         X
               SP=SAP_TEMP_STORAGE_SUBPOOL,KEY=SAP_TEMP_STORAGE_KEY
         DROP  6
         DROP  5
*
* Clear the first 64 K of storage for the prefix area, and initialize
* the header.  See if we need to grow any cell pools, and set the
* appropriate bit in the server task data if so.
*
SETEYE&SYSNDX DS 0H
         BBGZSTDI STDREG=7,NOTRACING=&CLIENT
         USING BBGZSTDI_BBGZSTD,7
         TMLL  12,SAP_SCRATCH_MASK_MORECELL Do we need to grow pool?
         JZ    NOGROW&SYSNDX Nope - continue
         MVI   BBGZSTDI_DYNGETFAIL,1 Set bit indicating grow pool
         DROP  7
NOGROW&SYSNDX DS 0H
         LGR   15,7 Move dynamic area to R15
         BRU   FINISH&SYSNDX Jump to finish
*
* We have server task data.  The server task data is the prefix to our
* stack.  Make sure that no one is using it before we use it (ie. an
* IRB got dispatched on this task and is running simultaneously).
* Note offset 36 into stack prefix is the stack ownership word, and
* the dependency here is noted in server_task_data.h.
*
TAKETGOO&SYSNDX DS 0H
         XGR   2,2         Clear reg 2 - not using cell pool dyn area
         LGHI  6,0         Load zero into R6 (expected value)
         LGHI  7,-1        Load non-zero into R7
         CS    6,7,36(15)  Try to take dynamic area
         BRZ   FINISH&SYSNDX Branch if successful
         LARL  5,&CCN_LITN
         USING &CCN_LITN,5
         ABEND ABEND_TYPE_SERVER,REASON=KRSN_SAUTHPRL_STACK_IN_USE,    X
               DUMP,STEP,SYSTEM
         DROP  5
*
* We found the server task data hung off the STCBBCBA.  The address
* of the dynamic area is in R15.  Finish up, do the DSA chaining etc
*
FINISH&SYSNDX DS 0H
         OILH  15,1        Advance past the 64K prefix area
         STG   2,0(15)     Store R2 (did we use the cell pool)
         AGHI  15,16       Advance past the storage above (quad word)
         LG    1,32(13)    Restore input parms
         STG   13,128(15)  Backchain
         LGR   13,15       Put stack where expected to be
*
* Define the DSECTs we're going to use if this is the first time the
* macro is being invoked.
*
         AIF (&BBGZ_SERVER_AUTH_PROLOG_DSECT).NODSECT
&BBGZ_SERVER_AUTH_PROLOG_DSECT SETB 1
SAP_IARV64         DSECT    Mapping of the parms to IARV64
SAP_IARV64_SEGCT   DS FD    Number of segments requested
                   ORG SAP_IARV64_SEGCT
SAP_IARV64_ORIGIN  DS FD    Returned storage start address
SAP_IARV64_GUARDSZ DS F     Number of guard segments requested
SAP_IARV64_KEY     DS CL1   Storage key requested
                   DS CL3   Available
SAP_IARV64_PLIST   DS CL88  Parameter list for execute form v0
                   DS CL152 Available
*
SAUTHPRL_SAVEAREA        DSECT    Caller provided F4SA
SAUTHPRL_SAVEAREA_RSVD   DS CL8   Header
SAUTHPRL_SAVEAREA_R14T1  DS CL32  Registers 14, 15, 0 and 1
SAUTHPRL_SAVEAREA_R2T11  DS CL80  Registers 2 thru 11
                        ORG SAUTHPRL_SAVEAREA_R2T11
SAUTHPRL_SAVEAREA_TOKNAM DS CL8   Name token name 1st part
SAUTHPRL_SAVEAREA_TOKNAM2 DS CL8  Name token name 2nd part
SAUTHPRL_SAVEAREA_TOKLVL DS F     Name token level (home/system)
SAUTHPRL_SAVEAREA_TOKRC  DS F     Name token service return code
SAUTHPRL_SAVEAREA_TOKTOK DS CL16  Name token token
                        ORG SAUTHPRL_SAVEAREA_TOKTOK
SAUTHPRL_SAVEAREA_TOKPTR DS CL8
SAUTHPRL_SAVEAREA_TOKCLR DS CL8 
SAUTHPRL_SAVEAREA_TOKPL  DS CL32  Name token svc parameter list area
SAUTHPRL_SAVEAREA_CPANCH DS AD    Address of cell pool anchor
SAUTHPRL_SAVEAREA_R12    DS CL8   Register 12 (do not use - scratch)
*
SAUTHPRL_IEAN4RT_PL      DSECT  Parameter list for IEAN4RT
SAUTHPRL_IEAN4RT_PL_LVL  DS AD  Pointer to token level
SAUTHPRL_IEAN4RT_PL_NAME DS AD  Pointer to token name
SAUTHPRL_IEAN4RT_PL_TOK  DS AD  Pointer to token
SAUTHPRL_IEAN4RT_PL_RC   DS AD  Pointer to return code
*
SAP_TEMP_STORAGE_LEN EQU 256     Length of temporary storage
SAP_TEMP_STORAGE_SUBPOOL EQU 229 Subpool of temporary storage
SAP_TEMP_STORAGE_KEY EQU 2       Key of temporary storage
*
SAP_IARV64_DYN_AREA_SEGMENTS EQU 2        Request 2 segments
SAP_IARV64_DYN_AREA_GUARD_SEGMENTS EQU 1  One segment is guard
SAP_IARV64_DYN_AREA_STORAGE_KEY EQU X'20' Storage in key 2
*
SAP_SCRATCH_MASK_MORECELL EQU 1
*
         RASABEND
*
&CCN_CSECT CSECT
.NODSECT ANOP
*
         MEND
