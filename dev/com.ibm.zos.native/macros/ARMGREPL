*
* IBM Confidential
*
* OCO Source Materials
*
* Copyright IBM Corp. 2011
*
* The source code for this program is not published or otherwise
* divested of its trade secrets, irrespective of what has been
* deposited with the U.S. Copyright Office.
*
         MACRO
&NAME    ARMGREPL
         GBLC  &CCN_LITN
         GBLC  &CCN_CSECT
         GBLB  &BBGZ_ARMGREPL_DSECT
*
* This epilog gets control for RESMGR recovery in 64 bit mode.  It
* must return control to RESMGR in 31 bit mode, since that's the
* mode the prolog got control in.  So this un-does everything done
* by the prolog.
*
         LG   2,128(13)        Load previous register save area
         AGHI 13,-24           Subtract param list and temp storage
         LG   3,0(13)          Load 256 byte temporary storage
         USING ARMGREPL_TEMP,3
         NILH 13,X'FFFE'       Subtract the 64K prefix area
*
* Release the dynamic area storage we obtained in the prolog with
* IARV64.
*        
         STG  13,ARMGREPL_TEMP_IARV64_ORG Store the address to free
         IARV64 REQUEST=DETACH,MATCH=SINGLE,                           X
               MEMOBJSTART=ARMGREPL_TEMP_IARV64_ORG,                   X
               USERTKN=NO_USERTKN,COND=NO,PLISTVER=0,                  X
               TTOKEN=ARMGREPL_TEMP_TTOKEN,                            X
               MF=(E,ARMGREPL_TEMP_IARV64_PL,COMPLETE)
         SAM31                 Switch to 31 bit mode
         SYSSTATE PUSH
         SYSSTATE AMODE64=NO   
         LMH  14,12,ARMGREPL_TEMP_HHREGS Restore high halves of regs
         LR   13,2             Restore register save area
*
* Release the temporary storage
*         
         LARL 15,&CCN_LITN     Address constants
         USING &CCN_LITN,15         
         STORAGE RELEASE,LENGTH=ARMGREPL_TEMP_STORAGE_LEN,ADDR=(3),    X
               SP=ARMGREPL_TEMP_STORAGE_SUBPOOL,                       X
               KEY=ARMGREPL_TEMP_STORAGE_KEY
         DROP 15
         DROP 3
*
* Switch to Key0
*
         MODESET  EXTKEY=ZERO                 Switch to Key0 
*
* Restore the registers and return
*
         LM   14,12,12(13)     Restore registers
         LHI  15,0             Always RC=0
         BR   14               Return to caller
         SYSSTATE POP
*
* Define the DSECTs we're going to use if this is the first time the
* macro is being invoked.
*
         AIF (&BBGZ_ARMGREPL_DSECT).NODSECT
&BBGZ_ARMGREPL_DSECT SETB 1
ARMGREPL_TEMP            DSECT    Mapping of temporary storage
ARMGREPL_TEMP_HHREGS     DS CL60  High halves of R14-R12
ARMGREPL_TEMP_CLEAR      DS CL64  Cleared storage
                         ORG ARMGREPL_TEMP_CLEAR
ARMGREPL_TEMP_TTOKEN     DS CL16  TTOKEN for calling thread
ARMGREPL_TEMP_AVAIL1     DS CL4   Available
ARMGREPL_TEMP_IARV64_SEG DS FD    Segments requested
                         ORG ARMGREPL_TEMP_IARV64_SEG
ARMGREPL_TEMP_IARV64_ORG DS FD    Storage origin address
ARMGREPL_TEMP_IARV64_GRD DS F     Guard segments requested
ARMGREPL_TEMP_IARV64_KEY DS CL1   Storage key requested
ARMGREPL_TEMP_AVAIL2     DS CL3   Available
ARMGREPL_TEMP_IARV64_PL  DS CL88  Parameter list for IARV64 v0
ARMGREPL_TEMP_AVAIL3     DS CL72  Available
*
ARMGREPL_TEMP_STORAGE_LEN EQU 256     Length of temporary storage
ARMGREPL_TEMP_STORAGE_SUBPOOL EQU 229 Subpool of temporary storage
ARMGREPL_TEMP_STORAGE_KEY EQU 2       Key of temporary storage
&CCN_CSECT CSECT
.NODSECT ANOP
         MEND