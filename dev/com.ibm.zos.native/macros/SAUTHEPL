*
* IBM Confidential
*
* OCO Source Materials
*
* Copyright IBM Corp. 2011
*
* The source code for this program is not published or otherwise
* divested of its trade secrets, irrespective of what has been
* deposited with the U.S. Copyright Office.
*
         MACRO
&NAME    SAUTHEPL &CLIENT=,&ABENDINU=
         GBLC  &CCN_CSECT
         GBLC  &CCN_LITN
         GBLB  &BBGZ_SERVER_AUTH_EPILOG_DSECT
*
* See if this thread has a server task data area set up.  If it does,
* make sure it's the address of the dynamic area that we obtained.
* If this is the case, we don't need to free the dynamic area because
* it will be used by the next caller on this task.
*         
         LGR   3,13        Compute server task data in reg 3
         AGHI  3,-16       Subtract our 'cache' from the prolog
         LG    2,0(3)      Load address of cell pool (if used)
         NILH  3,X'FFFE'   Subtract 64K prefix from dynamic area
         LG    13,128(13)  Restore caller provided RSA.
         AIF ('&CLIENT' EQ 'YES').CHECKCELLPOOL
         USING PSA,0
         LLGT  5,PSATOLD   Load TCB from PSA
         DROP  0
         USING TCB,5
         LLGT  5,TCBSTCB   Load STCB from PSA
         DROP  5
         USING STCB,5
         LLGT  5,STCBBCBA  Load common task data anchor
         DROP  5
         LTGR  5,5         Is the common task data anchor set?
         BRZ   NOTGOO&SYSNDX
         LG    5,24(5)     Load server task data pointer
         CGR   5,3         Is server task data pointer our dyn area @?
         AIF ('&ABENDINU' EQ 'NO').BRANCHRETURN
         BRZ   HAVETGOO&SYSNDX Yes -- keep dynamic area
         AGO .RELEASETGOO
.BRANCHRETURN ANOP
         BRZ   RTNTOCALLER&SYSNDX Yes -- keep dynamic area
         AGO .RELEASETGOO
*
* In the client process, see if we used the cell pool to obtain our
* dynamic area.  If we did, return it there.  If not, release it.
*
.CHECKCELLPOOL ANOP
         LTGR  2,2 See if we used the cell pool...
         BRZ   NOTGOO&SYSNDX No, so use IARV64 to release.
         LGR   0,3 Move cell address into R0
         LGR   1,2 Move cell pool anchor address into R1
         LGR   2,15 Move invoke return code to R2
         CALL CSRC4RFR
         LGR   15,2 Restore invoke return code
         B     RTNTOCALLER&SYSNDX
*
* Free the dynamic area.  We need to get some temp storage to put the
* IARV64 parameter list.  Then call IARV64 to free the dynamic area.
*
.RELEASETGOO ANOP
NOTGOO&SYSNDX DS 0H
         LGR   2,15             Save return code in register 2
         LARL  5,&CCN_LITN
         USING &CCN_LITN,5
         STORAGE OBTAIN,LENGTH=SAE_TEMP_STORAGE_LEN,BNDRY=DBLWD,       X
               SP=SAE_TEMP_STORAGE_SUBPOOL,KEY=SAE_TEMP_STORAGE_KEY
         LGR   6,1              Save storage address
         USING SAE_IARV64,6
         STG   3,SAE_IARV64_ORIGIN
         IARV64 REQUEST=DETACH,MATCH=SINGLE,USERTKN=NO_USERTKN,COND=NO,X
               MEMOBJSTART=SAE_IARV64_ORIGIN,PLISTVER=0,               X
               MF=(E,SAE_IARV64_PLIST,COMPLETE)
         STORAGE RELEASE,LENGTH=SAE_TEMP_STORAGE_LEN,ADDR=(6),         X
               SP=SAE_TEMP_STORAGE_SUBPOOL,KEY=SAE_TEMP_STORAGE_KEY
         DROP  6
         DROP  5
         LGR  15,2             Restore return code in reg 15
         BRU  RTNTOCALLER&SYSNDX Jump to return
*
* Our task related storage is hung off of the common task data anchor.
* Mark the task data as available again.
* Note offset 36 into stack prefix is the stack ownership word, and
* the dependency here is noted in server_task_data.h.
*
HAVETGOO&SYSNDX DS 0H
         LGHI 6,-1 Load non-zero into R6 (expected value)
         LGHI 7,0  Load zero into R7
         CS   6,7,36(3) Try to return the dynamic area
         BRZ  RTNTOCALLER&SYSNDX Branch if we returned the dyn area
         LARL  5,&CCN_LITN
         USING &CCN_LITN,5
         ABEND ABEND_TYPE_SERVER,REASON=KRSN_SAUTHEPL_STACK_IN_USE,    X
               DUMP,STEP,SYSTEM
         DROP  5
RTNTOCALLER&SYSNDX DS 0H
         LMG  1,12,32(13)      Restore regs 1 thru 12
         LG   14,8(13)         Restore reg 14
         BR   14               Return to caller
*
* Define the DSECTs we're going to use if this is the first time the
* macro is being invoked.
*
         AIF (&BBGZ_SERVER_AUTH_EPILOG_DSECT).NODSECT
&BBGZ_SERVER_AUTH_EPILOG_DSECT SETB 1
SAE_IARV64         DSECT    Mapping of the parms to IARV64
SAE_IARV64_ORIGIN  DS FD    Returned storage start address
SAE_IARV64_PLIST   DS CL88  Parameter list for execute form v0
                   DS CL160 Available
SAE_TEMP_STORAGE_LEN EQU 256     Length of temporary storage
SAE_TEMP_STORAGE_SUBPOOL EQU 229 Subpool of temporary storage
SAE_TEMP_STORAGE_KEY EQU 2       Key of temporary storage
*
         RASABEND
*
&CCN_CSECT CSECT
.NODSECT ANOP
*
         MEND
