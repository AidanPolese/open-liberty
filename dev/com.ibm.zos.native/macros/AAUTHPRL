*
* IBM Confidential
*
* OCO Source Materials
*
* Copyright IBM Corp. 2011
*
* The source code for this program is not published or otherwise
* divested of its trade secrets, irrespective of what has been
* deposited with the U.S. Copyright Office.
*
         MACRO
&NAME    AAUTHPRL
         GBLC  &CCN_LITN
         GBLC  &CCN_CSECT
         GBLB  &BBGZ_AAUTHPRL_DSECT
&TKNNAME SETC 'BBGZ_AAUTHPRL_DYN'
* --------------------------------------------------------------------
* IMPORTANT NOTE
* This entry linkage clobbers the next/prev DSA pointers of the 144
* byte save area that it is given.  It assumes that the caller can
* find its save area without using the prev DSA pointer (backchain).
* This is true when calling from an XPLINK program, which has its own
* way to transition back to the XPLINK stack when the routine is
* finished.
* --------------------------------------------------------------------
*
* Aliases to prevent the compiler from failing on the C defined IEAN4*
* aliases (ASMA311E).
*
AAUTHPRL_IEAN4CR_&SYSNDX ALIAS C'IEAN4CR'
AAUTHPRL_IEAN4RT_&SYSNDX ALIAS C'IEAN4RT'
*
* Because we're calling IARV64 to get storage, and IARV64 requires
* many arguments to be in memory, we're only saving registers 14
* thru register 1 in the save area,  The rest of the save area is
* used for parameters, until the IARV64 completes successfully.
* IARV64 will clobber registers 14, 15, 0 and 1.
*
         USING AAUTHPRL_SAVEAREA,13
         STMG  14,1,AAUTHPRL_SAVEAREA_R14T1 Store regs 14, 15, 0 and 1
*
* Try to find the dynamic area previously used by this thread by
* looking up the name token created to store the dynamic area.
*
         LARL  15,&CCN_LITN  Address literals (for name token name)
         USING &CCN_LITN,15  
         MVC   AAUTHPRL_SAVEAREA_TOKNAM,=CL16'&TKNNAME' Copy name
         DROP  15
         LGHI  15,IEANT_TASKAUTH_LEVEL  Name token is for this task
         ST    15,AAUTHPRL_SAVEAREA_TOKLVL Store task level constant
         LA    1,AAUTHPRL_SAVEAREA_TOKPL Load the parm list addr
         USING AAUTHPRL_IEAN4RT_PL,1
         LA    15,AAUTHPRL_SAVEAREA_TOKLVL Load addr of level const
         STG   15,AAUTHPRL_IEAN4RT_PL_LVL  Store as 1st parm
         LA    15,AAUTHPRL_SAVEAREA_TOKNAM Load addr of name token name
         STG   15,AAUTHPRL_IEAN4RT_PL_NAME Store as 2nd parm
         LA    15,AAUTHPRL_SAVEAREA_TOKTOK Load addr to store tkn into
         STG   15,AAUTHPRL_IEAN4RT_PL_TOK  Store as 3rd parm
         LA    15,AAUTHPRL_SAVEAREA_TOKRC  Load addr to put RC into
         STG   15,AAUTHPRL_IEAN4RT_PL_RC   Store as 4th parm
         CALL  AAUTHPRL_IEAN4RT_&SYSNDX Call name token retrieve
         L     15,AAUTHPRL_SAVEAREA_TOKRC  Load the return code to R15
         LTR   15,15     Check the return code (0 = good)
         BRZ   AAUTHPRLFOUNDTOK&SYSNDX
         DROP  1
*
* No name token, do the IARV64
*
         LGHI  15,AAUTHPRL_IARV64_DYN_AREA_SEGMENTS Get two segments 2M
         STG   15,AAUTHPRL_SAVEAREA_IARV64_SEG Store segment count
         LGHI  15,AAUTHPRL_IARV64_DYN_AREA_GUARD_SEGMENTS One seg. grd
         ST    15,AAUTHPRL_SAVEAREA_IARV64_GRD Store guard count
         LGHI  15,AAUTHPRL_IARV64_DYN_AREA_STORAGE_KEY Use key 2 stg
         STC   15,AAUTHPRL_SAVEAREA_IARV64_KEY Store key
         IARV64 REQUEST=GETSTOR,COND=NO,                               X
               SEGMENTS=AAUTHPRL_SAVEAREA_IARV64_SEG,                  X
               KEY=AAUTHPRL_SAVEAREA_IARV64_KEY,FPROT=NO,              X
               SVCDUMPRGN=YES,GUARDSIZE=AAUTHPRL_SAVEAREA_IARV64_GRD,  X
               CONTROL=AUTH,GUARDLOC=HIGH,USERTKN=NO_USERTKN,          X
               ORIGIN=AAUTHPRL_SAVEAREA_IARV64_ORG,PLISTVER=0,         X
               MF=(E,AAUTHPRL_SAVEAREA_IARV64_PL,COMPLETE)
*
* Clear the first 64 K of storage for the prefix area, and initialize
* the header.
*
         LG    14,AAUTHPRL_SAVEAREA_IARV64_ORG Load obtained stg addr
         BBGZATDI ATDREG=14
*
* Create a name token, hanging the storage off of it
*
         MVC   AAUTHPRL_SAVEAREA_TOKPTR,AAUTHPRL_SAVEAREA_IARV64_ORG
         XC    AAUTHPRL_SAVEAREA_TOKCLR,AAUTHPRL_SAVEAREA_TOKCLR
         LARL  15,&CCN_LITN         Address constants (for name)
         USING &CCN_LITN,15
         MVC   AAUTHPRL_SAVEAREA_TOKNAM,=CL16'&TKNNAME' Fill the name
         DROP  15
         LGHI  15,IEANT_TASK_LEVEL  Load task level constant
         ST    15,AAUTHPRL_SAVEAREA_TOKLVL Store task level constant
         LGHI  15,IEANT_NOPERSIST   Load nonpersistant token constant
         ST    15,AAUTHPRL_SAVEAREA_TOKPER Store constant
         LA    1,AAUTHPRL_SAVEAREA_TOKPL Load address of parameter list
         USING AAUTHPRL_IEAN4CR_PL,1
         LA    15,AAUTHPRL_SAVEAREA_TOKLVL Load task level constant adr
         STG   15,AAUTHPRL_IEAN4CR_PL_LVL Store as 1st arg
         LA    15,AAUTHPRL_SAVEAREA_TOKNAM Load name token name address
         STG   15,AAUTHPRL_IEAN4CR_PL_NAME Store as 2nd arg
         LA    15,AAUTHPRL_SAVEAREA_TOKTOK Load name token token addr
         STG   15,AAUTHPRL_IEAN4CR_PL_TOK Store as 3rd arg
         LA    15,AAUTHPRL_SAVEAREA_TOKPER Load nonpersist const addr
         STG   15,AAUTHPRL_IEAN4CR_PL_PST Store as 4th arg
         LA    15,AAUTHPRL_SAVEAREA_TOKRC Load addr of stg to store RC
         STG   15,AAUTHPRL_IEAN4CR_PL_RC Store as 5th arg
         CALL  AAUTHPRL_IEAN4CR_&SYSNDX Call name token create
         DROP  1
*
* Jump to the 'finish' part.  We'll store the IEAN4CR return code
* in the dynamic area to check it in the epilog.
*
         LG    15,AAUTHPRL_SAVEAREA_TOKPTR Reload obtained stack
         BRU   AAUTHPRLFIN&SYSNDX
*
* We found the name token, get the dynamic area from it.  Try to take
* ownership by setting the in-use word in the prefix.
* Note offset 28 into stack prefix is the stack ownership word, and
* the dependency here is noted in angel_task_data.h.
*
AAUTHPRLFOUNDTOK&SYSNDX DS 0H
         LG    15,AAUTHPRL_SAVEAREA_TOKPTR First part of token is stack
         LGHI  0,0 Load zero into R0 (expected)
         LGHI  1,-1 Load non-zero into R1
         CS    0,1,28(15) Try to set the in-use word
         BRZ   AAUTHPRLFIN&SYSNDX Set OK, jump to finish
         STMG  2,12,AAUTHPRL_SAVEAREA_R2T12 Store the rest of the regs
         LARL  5,&CCN_LITN
         USING &CCN_LITN,5
         ABEND ABEND_TYPE_SERVER,REASON=KRSN_AAUTHPRL_STACK_IN_USE,    X
               DUMP,STEP,SYSTEM
         DROP  5
*
* Finish up, do the DSA chaining etc
*
AAUTHPRLFIN&SYSNDX DS 0H
         OILH  15,1        Advance past the 64K prefix area
         MVC   0(4,15),AAUTHPRL_SAVEAREA_TOKRC Store RC from IEAN4xx
         AGHI  15,8        Advance 8 bytes (double word boundary)
         STMG  2,12,AAUTHPRL_SAVEAREA_R2T12 Store the rest of the regs
         LG    1,32(13)    Restore input parms
         STG   13,128(15)  Backchain
         LGR   13,15       Put stack where expected to be
         DROP  13
*
* Define the DSECTs we're going to use if this is the first time the
* macro is being invoked.
*
         AIF (&BBGZ_AAUTHPRL_DSECT).NODSECT
&BBGZ_AAUTHPRL_DSECT SETB 1
AAUTHPRL_SAVEAREA        DSECT    Caller provided F4SA
AAUTHPRL_SAVEAREA_RSVD   DS CL8   Header
AAUTHPRL_SAVEAREA_R14T1  DS CL32  Registers 14, 15, 0 and 1
AAUTHPRL_SAVEAREA_R2T12  DS CL88  Registers 2 thru 12
                        ORG AAUTHPRL_SAVEAREA_R2T12
AAUTHPRL_SAVEAREA_TOKNAM DS CL16  Name token name
AAUTHPRL_SAVEAREA_TOKLVL DS F     Name token level (home/system)
AAUTHPRL_SAVEAREA_TOKPER DS F     Name token persist option
AAUTHPRL_SAVEAREA_TOKRC  DS F     Name token service return code
AAUTHPRL_SAVEAREA_TOKAV1 DS CL4   Available (for alignment)
AAUTHPRL_SAVEAREA_TOKTOK DS CL16  Name token token
                        ORG AAUTHPRL_SAVEAREA_TOKTOK
AAUTHPRL_SAVEAREA_TOKPTR DS CL8
AAUTHPRL_SAVEAREA_TOKCLR DS CL8 
AAUTHPRL_SAVEAREA_TOKPL  DS CL40  Name token svc parameter list area
AAUTHPRL_SAVEAREA_TOKAV2 DS CL16  Available
                        ORG AAUTHPRL_SAVEAREA_R2T12
AAUTHPRL_SAVEAREA_IARV64_SEG DS FD  Segment count to obtain
                        ORG AAUTHPRL_SAVEAREA_IARV64_SEG
AAUTHPRL_SAVEAREA_IARV64_ORG DS FD  Returned memory origin address
AAUTHPRL_SAVEAREA_IARV64_GRD DS F   Guard segments to obtain
AAUTHPRL_SAVEAREA_IARV64_KEY DS CL1 Storage key
AAUTHPRL_SAVEAREA_IARV64_AV1 DS CL3 Available
AAUTHPRL_SAVEAREA_IARV64_PL  DS CL88 Parameter list for v0
*
AAUTHPRL_IARV64_DYN_AREA_SEGMENTS EQU 2        Request 2 segments
AAUTHPRL_IARV64_DYN_AREA_GUARD_SEGMENTS EQU 1  One segment is guard
AAUTHPRL_IARV64_DYN_AREA_STORAGE_KEY EQU X'20' Storage in key 2
*
AAUTHPRL_IEAN4RT_PL      DSECT  Parameter list for IEAN4RT
AAUTHPRL_IEAN4RT_PL_LVL  DS AD  Pointer to token level
AAUTHPRL_IEAN4RT_PL_NAME DS AD  Pointer to token name
AAUTHPRL_IEAN4RT_PL_TOK  DS AD  Pointer to token
AAUTHPRL_IEAN4RT_PL_RC   DS AD  Pointer to return code
*
AAUTHPRL_IEAN4CR_PL      DSECT  Parameter list for IEAN4CR
AAUTHPRL_IEAN4CR_PL_LVL  DS AD  Pointer to token level
AAUTHPRL_IEAN4CR_PL_NAME DS AD  Pointer to token name
AAUTHPRL_IEAN4CR_PL_TOK  DS AD  Pointer to token
AAUTHPRL_IEAN4CR_PL_PST  DS AD  Pointer to persistent option
AAUTHPRL_IEAN4CR_PL_RC   DS AD  Pointer to return code
*
         RASABEND
*
&CCN_CSECT CSECT
.NODSECT ANOP
*
         MEND
