*
* IBM Confidential
*
* OCO Source Materials
*
* Copyright IBM Corp. 2016
*
* The source code for this program is not published or otherwise
* divested of its trade secrets, irrespective of what has been
* deposited with the U.S. Copyright Office.
*
         MACRO
&NAME    ESAFPRLG
         GBLC  &CCN_LITN
         GBLC  &CCN_CSECT
         GBLB  &ESAFPRLG_DSECT
*
* This prolog gets control for ESAF normal call exit in 31 bit mode,
* dynamic area, and modifies the parameter list to give control to
* the corresponding metal C function in 64 bit mode.
*
         SYSSTATE PUSH
         SYSSTATE AMODE64=NO
         STM   14,12,12(13)    Store registers
*
* Get some below the bar storage that we can use to store the high
* halves of the registers and parameter list. R1 will reference the
* new storage.
*
         LARL  15,&CCN_LITN    Address literals area off R15
         USING &CCN_LITN,15
         LR    4,1   Save input parms so storage obtain doesn't clobber
         STORAGE OBTAIN,LENGTH=ESAFPRLG_TEMP_STORAGE_LEN,              X
               SP=ESAFPRLG_TEMP_STORAGE_SUBPOOL,CALLRKY=YES
         DROP  15

*               
* Save off and then clear the high halves of the registers.
*               
         STMH  14,12,0(1)      Save high halves of registers
         AHI   1,64            Advance past reg high half save area
         XC    0(64,1),0(1)    Clear the next 64 bytes
         LMH   14,13,0(1)      Clear the high halves of registers

*
* Switch to 64 bit mode now
*
         SYSSTATE POP
         SAM64                 Switch to 64 bit mode

*
* The parameter count is the first element of the parameter list,
* followed by that many 31-bit pointers. Store the parameter count
* and loop that many times, converting the pointers to 64-bit.
*
         LLGT  6,0(4)          Load parameter count ptr into R6
         LLGT  6,0(6)          Load parameter count into R6       
         AGHI  4,4             Advance past parm count 
         LGR   3,13            Save backchain address in R3     
         LGR   13,1            Load address of new parm area into R13
         
PRMS     LLGT  2,0(4)          Load parm pointer into R2
         STG   2,0(13)         Store new 64-bit parm pointer        
         AGHI  4,4             Advance past input parm 
         AGHI  13,8            Advance past new parm pointer
         BRCTG 6,PRMS          Repeat until all parms converted

*
* Save our temporary storage address, we'll need it in the epilog.
*
         STG   1,0(13)         Save our temporary storage address
         AGHI  13,8            Advance past temporary storage address

*
* Set up the DSA to point to the previous DSA
*
         STG   3,128(,13)      Store backchain address
*
* Define the DSECTs we're going to use if this is the first time the
* macro is being invoked.
*
         AIF (&ESAFPRLG_DSECT).NODSECT
&ESAFPRLG_DSECT SETB 1
ESAFPRLG_TEMP_STORAGE_LEN EQU 32768   Length of temporary storage
ESAFPRLG_TEMP_STORAGE_SUBPOOL EQU 131   Subpool of temporary storage
&CCN_CSECT CSECT
.NODSECT ANOP
         MEND