*
* IBM Confidential
*
* OCO Source Materials
*
* Copyright IBM Corp. 2016
*
* The source code for this program is not published or otherwise
* divested of its trade secrets, irrespective of what has been
* deposited with the U.S. Copyright Office.
*
         MACRO
&NAME    SAIOPRL
         GBLC  &CCN_LITN
         GBLC  &CCN_CSECT
         GBLB  &BBGZ_SAIOPRL_DSECT        
*
* This prolog gets control for AIO exit routines, in 64 bit mode,
* driven on an SRB.  We save the caller regs, and get at the 200 bytes
* of passed workarea and use that for local data.
* Clobber registers 14,15
*
          J SAIOXXXX
          DC CL8'BANANA18'
SAIOXXXX  STMG   14,12,8(13)  Store registers 14-12 into 136 byte SA
          LGR    9,1          Save R1 in R9 to avoid key switch later
*
*
* The parameter list given to us by USS for BPX4AIO is in R1.
* It looks like this:
*         R1 -> Address AIOCB (in progress)
*            -> Address Work Area (our dynamic area in Key0)
*            -> Address of Length (2K)
* Since the provided DSA is in Key0, do the cellpool get for storage
* (1M) in Key2 and switch to Key2 before calling metal C routine.
*
* To get to the AsyncIO SRB Dynarea cellpool we need to get to the 
* AIOCD (AsyncIOCompletionData).aiosrb_cellpool_id.   The AIOCD
* is anchored in the PGOO.  Rather than doing a NameToken lookup
* on every SRB call, we will pull the PGOO's address from the 
* Connection (aioconn.pgoo) pointed to by the IOCB (aioexitdata)
* passed in the parmlist.
*
         USING SAIOPRL_PARMS,1     Parameters mapped off R1
         LG    4,SAIOPRL_DYNAREA@
         USING SAIOPRL_DYNAREA,4   Dynamic area now off R4
         XGR   15,15               Load zero into R15
         STG   15,SAIOPRL_SAVEAREA_IARV64_ORG Clear IARV64 Addr
         LG    15,SAIOPRL_AIOCB@   IOCB passed on BPX4AIO
         LTGR  15,15               Is IOCB set?
         BRNZ  GDIOCB&SYSNDX       Yes, IOCB is good.    
         LARL  5,&CCN_LITN
         USING &CCN_LITN,5
         ABEND ABEND_TYPE_SERVER,REASON=KRSN_SAIOPRL_NOIOCB,           X
               DUMP,STEP,SYSTEM
         DROP  5
* Get the Connection reference from the IOCB.aioexitdata
GDIOCB&SYSNDX DS 0H   
         LG    15,84(15)           Load aioconn address(hex 54 offset)
         LTGR  15,15               Is aioconn set?
         BRNZ  GDAIOCONN&SYSNDX    Yes, aioconn is good.
         LARL  5,&CCN_LITN
         USING &CCN_LITN,5
         ABEND ABEND_TYPE_SERVER,REASON=KRSN_SAIOPRL_NOAIOCONN,        X
               DUMP,STEP,SYSTEM
         DROP  5
* Get the PGOO reference from the aioconn.pgoo
GDAIOCONN&SYSNDX DS 0H   
         LG    15,64(15)           Load pgoo address(hex 40 offset)
         LTGR  15,15               Is pgoo set?
         BRNZ  GOODPGOO&SYSNDX     Yes, PGOO is good.
         LARL  5,&CCN_LITN
         USING &CCN_LITN,5
         ABEND ABEND_TYPE_SERVER,REASON=KRSN_SAIOPRL_NOPGOO,           X
               DUMP,STEP,SYSTEM
         DROP  5
*
GOODPGOO&SYSNDX DS 0H
* Following has offset dependency on 
* "server_process_data.asyncio_completion_data_p"
         LG    15,176(15)          Load AIOCD address(hex B0 offset)
         LTGR  15,15               Is AIOCD set?
         BRNZ  GDAIOCD&SYSNDX      Yes, AIOCD is good.
         LARL  5,&CCN_LITN
         USING &CCN_LITN,5
         ABEND ABEND_TYPE_SERVER,REASON=KRSN_SAIOPRL_NOAIOCD,          X
               DUMP,STEP,SYSTEM
         DROP  5
* AsyncIOCompletionData.aiosrb_cellpool_id -- offset dependency
GDAIOCD&SYSNDX DS 0H
         STG   15,SAIOPRL_AIOCD_PTR Stash AIOCD ptr
         LG    15,72(15)           Load AIO SRB cellpool(hex 48 offset)
         LTGR  15,15               Is cell pool set?
         BRNZ  GOODPOOL&SYSNDX     Yes, pool is good.
         LARL  5,&CCN_LITN
         USING &CCN_LITN,5
         ABEND ABEND_TYPE_SERVER,REASON=KRSN_SAIOPRL_NOSRBPOOL,        X
               DUMP,STEP,SYSTEM
         DROP  5
*
GOODPOOL&SYSNDX DS 0H
         LG    11,8(15)            Get cellpool anchor address into R11
         LGR   1,11                Move to R1 for cell pool get call
         CALL CSRC4RGT             Try to get a cell
         LTR   15,15               Is return code good?
         BRZ   GOODCELL&SYSNDX     Yes, got a cell, in R1.
         LGHI  14,8                Load 'no more cells' return code
         CR    15,14               If we got the 'no more cells'
         BRZ   NOMORECELLS1&SYSNDX Use IARV64 until pool expands
         LGR   8,15                Move Cellpool get RC to R8
         LARL  5,&CCN_LITN
         USING &CCN_LITN,5
         ABEND ABEND_TYPE_SERVER,REASON=KRSN_SAIOPRL_CPERROR,          X
               DUMP,STEP,SYSTEM
         DROP  5
*
NOMORECELLS1&SYSNDX DS 0H
* Set a mark on the AsyncIO wall that the SRB cellpool needs to be 
* expanded.  Until then we will just IARV64 our own area for this
* call.
         XGR   11,11               Indicator "no cell obtained"
*AsyncIOCompletionData.aio_TToken -- Owning TTOKEN for IARV64
         LG    15,SAIOPRL_AIOCD_PTR Get AIOCD pointer
         MVC   SAIOPRL_SAVEAREA__IARV64_TTOKEN,80(15) aio_TToken
*AsyncIOCompletionData.aiocdFlags.aiocdFlagsExpand_aiosrb_cellpool         
         LGF   0,52(0,15)          Load aiocdFlags into R0 (expected)
NOMORECELLS2&SYSNDX DS 0H         
         LGR   1,0                 Grab existing flags
         TMLL  1,SAIOPRL_AIOCDFLAGSEXPAND_AIOSRB_CELLPOOL Expand Set?
         BRNE  NOMORECELLS3&SYSNDX Skip flag set, Issue IARV64
         OILL  1,SAIOPRL_AIOCDFLAGSEXPAND_AIOSRB_CELLPOOL flags (new)
         CS    0,1,52(15)          Try to set the aiocdFlags
         BRNZ  NOMORECELLS2&SYSNDX Not Set, jump to try again
*
* Use IARV64 to get stack storage until the cellpool is expanded
NOMORECELLS3&SYSNDX DS 0H 
         LGHI  15,SAIOPRL_IARV64_DYN_AREA_SEGMENTS Get 2 segments 2M
         STG   15,SAIOPRL_SAVEAREA_IARV64_SEG Store segment count
         LGHI  15,SAIOPRL_IARV64_DYN_AREA_GUARD_SEGMENTS One seg. grd
         ST    15,SAIOPRL_SAVEAREA_IARV64_GRD Store guard count
         LGHI  15,SAIOPRL_IARV64_DYN_AREA_STORAGE_KEY Use key 2 stg
         STC   15,SAIOPRL_SAVEAREA_IARV64_KEY Store key        
         IARV64 REQUEST=GETSTOR,COND=NO,                               X
               SEGMENTS=SAIOPRL_SAVEAREA_IARV64_SEG,                   X
               KEY=SAIOPRL_SAVEAREA_IARV64_KEY,FPROT=NO,               X
               SVCDUMPRGN=YES,GUARDSIZE=SAIOPRL_SAVEAREA_IARV64_GRD,   X
               CONTROL=AUTH,GUARDLOC=HIGH,USERTKN=NO_USERTKN,          X
               ORIGIN=SAIOPRL_SAVEAREA_IARV64_ORG,PLISTVER=0,          X
               TTOKEN=SAIOPRL_SAVEAREA__IARV64_TTOKEN,                 X
               MF=(E,SAIOPRL_SAVEAREA_IARV64_PL,COMPLETE)
         LG    1,SAIOPRL_SAVEAREA_IARV64_ORG Load obtained stg addr             
*
* Clear the first 64 K of storage for the prefix area, and initialize
* the header.
* 
GOODCELL&SYSNDX DS 0H
         LGR   8,1                 Load obtained stg addr
         MODESET  EXTKEY=KEY2      Switch Key0 to Key2
         BBGZSTDI STDREG=8,NOTRACING=YES,CLEARPREFIX=NO Skip Clear 64K
         OILH  8,1                 Advance 64K prefix area
*
* Save the workarea in R8 after 64K prefix, to be referred later
* in the epilog. Advance 8 bytes ( length of SAIO_DYNAREA@)
*
         STG   4,0(8)              Save workarea address SAIO_DYNAREA@
         AGHI  8,8                 Advance 8 bytes
* Save the cell pool anchor addr in the next 8 bytes
         STG   11,0(8)             save cellpool anchor addr
         AGHI  8,8                 Advance another 8 bytes
* Save IARV64 Obtained storage addr in the next next next 8 bytes
         LG    5,SAIOPRL_SAVEAREA_IARV64_ORG Save IARV64 addr
         STG   5,0(8)              save cellpool anchor addr
         AGHI  8,8                 Advance another 8 bytes
* Chain our DSA and pass parms
         STG   13,128(,8)          Save caller R13 DSA in backchain
         LGR   13,8                Put new dynamic area addr in R13
         LGR   1,9                 Restore R1 for input param list
         DROP  4          
*
* Define the DSECTs we are going to use if this is the first time
* the macro is being invoked.
*
          AIF (&BBGZ_SAIOPRL_DSECT).NODSECT
&BBGZ_SAIOPRL_DSECT SETB 1
SAIOPRL_PARMS              DSECT    Mapping of R1 Parameter list
SAIOPRL_AIOCB@             DS AD    0x000 Address of AIOCB
SAIOPRL_DYNAREA@           DS AD    0x008 Address of 2K workarea
SAIOPRL_WORKLEN@           DS AD    0x010 Address of work area len
*                                   0x018 Size of Parms
*
SAIOPRL_DYNAREA            DSECT    Mapping of local variables
SAIOPRL_AIOCD_PTR           DS AD  Pointer to AIOCD area
SAIOPRL_SAVEAREA_IARV64_ORG DS FD  Returned memory origin address
SAIOPRL_SAVEAREA_IARV64_SEG DS FD  Segment count to obtain
SAIOPRL_SAVEAREA_IARV64_GRD DS F   Guard segments to obtain
SAIOPRL_SAVEAREA_IARV64_KEY DS CL1 Storage key
SAIOPRL_SAVEAREA_IARV64_AV1 DS CL3 Available
SAIOPRL_SAVEAREA__IARV64_TTOKEN DS CL16 TTOKEN for Ownership
SAIOPRL_SAVEAREA_IARV64_PL  DS CL88 Parameter list for v0
*
SAIOPRL_IARV64_DYN_AREA_SEGMENTS EQU 2        Request 2 segments
SAIOPRL_IARV64_DYN_AREA_GUARD_SEGMENTS EQU 1  One segment is guard
SAIOPRL_IARV64_DYN_AREA_STORAGE_KEY EQU X'20' Storage in key 2
*
*
*AsyncIOCompletionData.aiocdFlags.aiocdFlagsExpand_aiosrb_cellpool
SAIOPRL_AIOCDFLAGSEXPAND_AIOSRB_CELLPOOL EQU x'01'
*
*
    RASABEND
*
&CCN_CSECT CSECT
.NODSECT ANOP
          MEND
