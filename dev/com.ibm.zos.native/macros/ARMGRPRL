*
* IBM Confidential
*
* OCO Source Materials
*
* Copyright IBM Corp. 2011
*
* The source code for this program is not published or otherwise
* divested of its trade secrets, irrespective of what has been
* deposited with the U.S. Copyright Office.
*
         MACRO
&NAME    ARMGRPRL
         GBLC  &CCN_LITN
         GBLC  &CCN_CSECT
         GBLB  &BBGZ_ARMGRPRL_DSECT
*
* This prolog gets control for RESMGR recovery in 31 bit mode, gets
* dynamic area, and modifies the parameter list to give control to
* the corresponding metal C function in 64 bit mode.
*
         SYSSTATE PUSH
         SYSSTATE AMODE64=NO
         STM   14,12,12(13)  Store registers
*
* Get some below the bar storage that we can use to store the high
* halves of the registers, and to hold the parameter list for IARV64.
*
         LARL  15,&CCN_LITN  Address literals area off R15
         USING &CCN_LITN,15
         LR    4,1 Save input parms so storage obtain doesn't clobber
*
* Switch to Key2
*
         MODESET  EXTKEY=KEY2                 Switch Key0 to Key2        
         STORAGE OBTAIN,LENGTH=ARMGRPRL_TEMP_STORAGE_LEN,              X
               SP=ARMGRPRL_TEMP_STORAGE_SUBPOOL,                       X
               KEY=ARMGRPRL_TEMP_STORAGE_KEY
         DROP  15
         USING ARMGRPRL_TEMP,1
         STMH  14,12,ARMGRPRL_TEMP_HHREGS Save high halves of registers
         XC    ARMGRPRL_TEMP_CLEAR,ARMGRPRL_TEMP_CLEAR Clear 64 bytes
         LMH   14,13,ARMGRPRL_TEMP_CLEAR Clear the high halves of regs
*
* Before switching to 64 bit mode, get the TTOKEN for our task, to
* work around an RSM bug where IARV64 DETACH fails because of an
* invalid TTOKEN.  Save the TTOKEN in the temporary storage.
*
         USING PSA,0
         LLGT  15,PSATOLD
         DROP  0
         USING TCB,15
         LLGT  15,TCBSTCB  Load STCB from PSA
         DROP  15
         USING STCB,15
         MVC   ARMGRPRL_TEMP_TTOKEN,STCBTTKN
         DROP  15
*
* Switch to 64 bit mode now
*
         SYSSTATE POP
         SAM64                Switch to 64 bit mode
*
* Now call IARV64 to get dynamic area.  We're going to set up the same
* 1 meg stack with 64K prefix as we set up everywhere else.
*
         LGR   3,1       Load temporary storage into R3
         DROP  1
         USING ARMGRPRL_TEMP,3
         LGHI  15,ARMGRPRL_IARV64_SEGMENTS Request two segments = 2MB
         STG   15,ARMGRPRL_TEMP_IARV64_SEG Store segment count
         LGHI  15,ARMGRPRL_IARV64_GUARDSEGS Request one seg guard = 1MB
         ST    15,ARMGRPRL_TEMP_IARV64_GRD Store guard size
         LGHI  15,ARMGRPRL_IARV64_KEY Use key 2 storage
         STC   15,ARMGRPRL_TEMP_IARV64_KEY Store key
         IARV64 REQUEST=GETSTOR,COND=NO,FPROT=NO,SVCDUMPRGN=YES,       X
               SEGMENTS=ARMGRPRL_TEMP_IARV64_SEG,CONTROL=AUTH,         X
               KEY=ARMGRPRL_TEMP_IARV64_KEY,USERTKN=NO_USERTKN,        X
               GUARDSIZE=ARMGRPRL_TEMP_IARV64_GRD,GUARDLOC=HIGH,       X
               TTOKEN=ARMGRPRL_TEMP_TTOKEN,                            X
               ORIGIN=ARMGRPRL_TEMP_IARV64_ORG,PLISTVER=0,             X
               MF=(E,ARMGRPRL_TEMP_IARV64_PL,COMPLETE)
         LGR   2,13      Save our register save area address
         LG    13,ARMGRPRL_TEMP_IARV64_ORG Put new dyn area into R13
*
* Clear the first 64 K of storage for the prefix area, and advance
* past it.  Also initialize the header.
*
         BBGZATDI ATDREG=13
         OILH  13,1        Advance past the 64K prefix area
*
* Save our temporary storage address, we'll need it in the epilog.
*
         STG   3,0(13)   Save our temporary storage address
         AGHI  13,8      Advance past temporary storage address
*
* The parameter list given to us by RESMGR is two 31 bit pointers.
* We will re-construct the paramter list so it's two 64 bit pointers.
*
         LLGT  1,0(4)         Load RMPL pointer into R1
         STG   1,0(13)        Store RMPL pointer
         LLGT  1,4(4)         Load user parm pointer into R1
         STG   1,8(13)        Store user parm pointer
         LGR   1,13           Load new parm list into R1
         AGHI  13,16          Advance past new parm list
*
* Set up the DSA to point to the previous DSA
*
         STG   2,128(,13)     Backchain
*
* Define the DSECTs we're going to use if this is the first time the
* macro is being invoked.
*
         AIF (&BBGZ_ARMGRPRL_DSECT).NODSECT
&BBGZ_ARMGRPRL_DSECT SETB 1
ARMGRPRL_TEMP            DSECT    Mapping of temporary storage
ARMGRPRL_TEMP_HHREGS     DS CL60  High halves of R14-R12
ARMGRPRL_TEMP_CLEAR      DS CL64  Cleared storage
                         ORG ARMGRPRL_TEMP_CLEAR
ARMGRPRL_TEMP_TTOKEN     DS CL16  TTOKEN for calling thread
ARMGRPRL_TEMP_AVAIL1     DS CL4   Available
ARMGRPRL_TEMP_IARV64_SEG DS FD    Segments requested
                         ORG ARMGRPRL_TEMP_IARV64_SEG
ARMGRPRL_TEMP_IARV64_ORG DS FD    Storage origin address
ARMGRPRL_TEMP_IARV64_GRD DS F     Guard segments requested
ARMGRPRL_TEMP_IARV64_KEY DS CL1   Storage key requested
ARMGRPRL_TEMP_AVAIL2     DS CL3   Available
ARMGRPRL_TEMP_IARV64_PL  DS CL88  Parameter list for IARV64 v0
ARMGRPRL_TEMP_AVAIL3     DS CL72  Available
*
ARMGRPRL_IARV64_SEGMENTS  EQU 2
ARMGRPRL_IARV64_GUARDSEGS EQU 1
ARMGRPRL_IARV64_KEY       EQU X'20'
*
ARMGRPRL_TEMP_STORAGE_LEN EQU 256     Length of temporary storage
ARMGRPRL_TEMP_STORAGE_SUBPOOL EQU 229 Subpool of temporary storage
ARMGRPRL_TEMP_STORAGE_KEY EQU 2       Key of temporary storage
&CCN_CSECT CSECT
.NODSECT ANOP
         MEND