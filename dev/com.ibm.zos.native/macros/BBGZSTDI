*
* IBM Confidential
*
* OCO Source Materials
*
* Copyright IBM Corp. 2011, 2016
*
* The source code for this program is not published or otherwise
* divested of its trade secrets, irrespective of what has been
* deposited with the U.S. Copyright Office.
*
         MACRO
&NAME    BBGZSTDI &STDREG=,&NOTRACING=NO,&CLEARPREFIX=YES
         GBLC  &CCN_CSECT
         GBLB  &BBGZ_BBGZSTDI_DSECT
         GBLB  &BBGZ_BBGZSTDI_ALIAS
*
* Initialize the BBGZSTD control block.
*
* STDREG is the register which contains the address of the storage to
* initialize as the BBGZSTD.  Can be any register 2 - 14.
*
* NOTRACING is an indication to skip the NAMETOKEN lookup for the trace
* level and just set it to NULL.  Used in SRB mode were no tracing is 
* possible (yet).
*
* Clobbers registers 14, 15, 0 and 1.  Note that STDREG can be 14 but
* this macro will not restore 14 before returning.
*
         AIF ('&STDREG' EQ '').NOSTDREG
         USING BBGZSTDI_BBGZSTD,&STDREG
* Clear entire "used" part of the prefix area
         LA    15,STDI_USEDSIZE Length to clear
         AIF ('&STDREG' NE '14').STDNOT14A
         LGR   0,&STDREG   Save STD if in R14 
.STDNOT14A ANOP          
         LGR   14,&STDREG  Load the address of storage to clear      
         XGR   1,1         Clear register 1, for clear on move long
         MVCL  14,0  
         AIF ('&STDREG' NE '14').STDNOT14B
         LGR   &STDREG,0   Restore STD if in R14
.STDNOT14B ANOP 
*             
         XGR   15,15       Clear register 15
         OIHH  15,X'C2C2'  Eye catcher BB
         OIHL  15,X'C7E9'  Eye catcher GZ
         OILH  15,X'E2E3'  Eye catcher ST
         OILL  15,X'C46D'  Eye catcher D_
         STG   15,BBGZSTDI_BBGZSTD_EYE Store eye catcher      
* Area cleared above.  So, already set to 0         
*        XC    BBGZSTDI_BBGZSTD_VER(4),BBGZSTDI_BBGZSTD_VER Version 0
         AIF ('&NOTRACING' EQ 'YES').NOTRC_PARM
*
* Look up the name token that has a pointer to the 
* RAS_aggregate_trace_level.  The name of the name token is defined
* in server_tracing_functions.c.
*
         LA    1,BBGZSTDI_LOCALUSE Use part of prefix temporary
         USING BBGZSTDI_NAMETOK,1
         XGR   15,15       Clear register 15
         LGR   0,15        Clear register 0
         OIHH  15,X'C2C2'  Name token name BB
         OIHL  15,X'C7E9'  Name token name GZ
         OILH  15,X'6DD9'  Name token name _R
         OILL  15,X'C1E2'  Name token name AS
         OIHH  0,X'6DD3'   Name token name _L
         OIHL  0,X'E5D3'   Name token name VL
         OILH  0,X'6DD7'   Name token name _P
         OILL  0,X'E3D9'   Name token name TR
         STMG  15,0,BBGZSTDI_NAMETOK_NAME Store name token name
         LGHI  15,IEANT_HOME_LEVEL  Load home level constant
         ST    15,BBGZSTDI_NAMETOK_LEVEL Store home level constant
         LA    15,BBGZSTDI_NAMETOK_NEXT Load address of parameter list
         USING BBGZSTDI_IEAN4RT_PL,15
         LA    0,BBGZSTDI_NAMETOK_LEVEL
         STG   0,BBGZSTDI_IEAN4RT_PL_LVL
         LA    0,BBGZSTDI_NAMETOK_NAME
         STG   0,BBGZSTDI_IEAN4RT_PL_NAME
         LA    0,BBGZSTDI_NAMETOK_TOKEN
         STG   0,BBGZSTDI_IEAN4RT_PL_TOK
         LA    0,BBGZSTDI_NAMETOK_RC
         STG   0,BBGZSTDI_IEAN4RT_PL_RC
         AIF ('&STDREG' NE '14').STDNOT14C
         STG   &STDREG,BBGZSTDI_IEAN4RT_PL_STD Save STD if in R14
.STDNOT14C ANOP
         LGR 1,15 Load parameter list into R1
         DROP  15
         DROP  1
         USING BBGZSTDI_IEAN4RT_PL,1
         CALL  BBGZSTDI_IEAN4RT Call name token create
         AIF ('&STDREG' NE '14').STDNOT14D
         LG    &STDREG,BBGZSTDI_IEAN4RT_PL_STD Restore STD if in R14
.STDNOT14D ANOP
         LG    15,BBGZSTDI_IEAN4RT_PL_RC Check for RC=0 from lookup
         LHI   0,0
         C     0,0(15)
         JNE   NOTRCLVL_&SYSNDX
*
* Second half of token is the address of the trace level
*
         LG    15,BBGZSTDI_IEAN4RT_PL_TOK Get address of token
         MVC   BBGZSTDI_BBGZSTD_TRCP,8(15) 
         J     FINISH_PREFIX_&SYSNDX
         DROP  1
.NOTRC_PARM ANOP       
NOTRCLVL_&SYSNDX DS 0H
*
* We could not get the trace level address.  In the interest of
* keeping the trace guards small, point to a null byte.  This way
* the trace guard does not have to check for null.
*
         LA    0,BBGZSTDI_BBGZSTD_NULL
         STG   0,BBGZSTDI_BBGZSTD_TRCP
FINISH_PREFIX_&SYSNDX DS 0H
         LGHI  15,-1       Load non-zero into R15
         ST    15,BBGZSTDI_DYNAMIC_AREA_IN_USE Mark dyna as in-use
*
* Set the length in the stack prefix area:
*         
         LGHI  15,1        Load 1 into length field
         SLLG  15,15,16(0) Shift 16 bits = 64K
         ST    15,BBGZSTDI_BBGZSTD_LEN Set length into header
         AIF ('&CLEARPREFIX' EQ 'NO').SKIPCLEAR         
* Clear remainder of Prefix (64K-used portion)
         LGR   14,&STDREG  Load the address of storage to clear        
         AGHI  14,STDI_USEDSIZE      Advance past header
         AGHI  15,-STDI_USEDSIZE     Subtract header length
         XGR   1,1         Clear register 1, for clear on move long
         MVCL  14,0
         DROP  &STDREG
.SKIPCLEAR ANOP     
*
* DSECTS used by this macro
*
         AIF (&BBGZ_BBGZSTDI_DSECT).NODSECT
&BBGZ_BBGZSTDI_DSECT SETB 1
BBGZSTDI_BBGZSTD     DSECT
BBGZSTDI_BBGZSTD_EYE DS CL8  0x000
BBGZSTDI_BBGZSTD_VER DS F    0x008
BBGZSTDI_BBGZSTD_LEN DS F    0x00C
BBGZSTDI_BBGZSTD_SENV DS AD  0x010
BBGZSTDI_BBGZSTD_CENV DS AD  0x018
BBGZSTDI_BBGZSTD_NULL DS CL1 0x020
BBGZSTDI_DYNGETFAIL   DS CL1 0x021
BBGZSTDI_CHK_ANGL_ANC DS CL1 0x022
BBGZSTDI_BBGZSTD_AVL1 DS CL1 0x023
BBGZSTDI_DYNAMIC_AREA_IN_USE DS F 0x024
BBGZSTDI_BBGZSTD_TRCP DS AD  0x028
* Define fields to allow us to clear the other fields defined
* in server_task_data.h.  Starting at offset x'30' till the end.
BBGZSTDI_BBGZSTD_INUSE DS CL256 Depends server_task_data._inuseEnd
* End of BBGZSTD area -- length is x'136' or 304 decimal bytes
*
STDI_USEDSIZE EQU *-BBGZSTDI_BBGZSTD  304 Currently.
BBGZSTDI_LOCALUSE    DS CL1  Area used for NameToken Parms+
*
BBGZSTDI_NAMETOK         DSECT
BBGZSTDI_NAMETOK_NAME    DS CL16  Name token name
BBGZSTDI_NAMETOK_LEVEL   DS F     Name token level (home/system)
BBGZSTDI_NAMETOK_RC      DS F     Name token service return code
BBGZSTDI_NAMETOK_TOKEN   DS CL16  Name token token
BBGZSTDI_NAMETOK_NEXT    DS 0H    Next avail byte
*
BBGZSTDI_IEAN4RT_PL      DSECT  Parameter list for IEAN4RT
BBGZSTDI_IEAN4RT_PL_LVL  DS AD  Pointer to token level
BBGZSTDI_IEAN4RT_PL_NAME DS AD  Pointer to token name
BBGZSTDI_IEAN4RT_PL_TOK  DS AD  Pointer to token
BBGZSTDI_IEAN4RT_PL_RC   DS AD  Pointer to return code
BBGZSTDI_IEAN4RT_PL_STD  DS AD  Extra parm - pointer back to STD
*
&CCN_CSECT CSECT
.NODSECT ANOP
*
* Aliases to prevent the compiler from failing on the C defined IEAN4*
* aliases (ASMA311E).
*
         AIF (&BBGZ_BBGZSTDI_ALIAS).NOALIAS
         AIF ('&NOTRACING' EQ 'YES').SKIP_IEAN4RT_ALIAS
&BBGZ_BBGZSTDI_ALIAS SETB 1
BBGZSTDI_IEAN4RT ALIAS C'IEAN4RT'
.SKIP_IEAN4RT_ALIAS ANOP
.NOALIAS ANOP
         AGO .ENDING
.NOSTDREG ANOP
         MNOTE 8,'STDREG MUST BE SET TO A REGISTER 2 - 14'
.ENDING  ANOP
         MEND