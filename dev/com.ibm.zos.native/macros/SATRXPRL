*
* IBM Confidential
*
* OCO Source Materials
*
* Copyright IBM Corp. 2011
*
* The source code for this program is not published or otherwise
* divested of its trade secrets, irrespective of what has been
* deposited with the U.S. Copyright Office.
*
         MACRO
&NAME    SATRXPRL
         GBLC  &CCN_LITN
         GBLC  &CCN_CSECT
         GBLB  &BBGZ_SATRXPRL_DSECT
*
* This prolog gets control for RRS exit routines, in 31 bit mode,
* driven on an SRB.  We'll get a small dynamic area, switch to 64
* bit mode, and massage the parameter list
*
         SYSSTATE PUSH
         SYSSTATE AMODE64=NO
         STM   14,12,12(13)  Store registers
*
* Get some below the bar storage that we can use to store the high
* halves of the registers and use as the dynamic area.
*
         LARL  15,&CCN_LITN  Address literals area off R15
         USING &CCN_LITN,15
         LR    4,1 Save input parms so storage obtain doesn't clobber
         STORAGE OBTAIN,LENGTH=SATRXPRL_TEMP_STORAGE_LEN,              X
               SP=SATRXPRL_TEMP_STORAGE_SUBPOOL,                       X
               KEY=SATRXPRL_TEMP_STORAGE_KEY
         DROP  15
         USING SATRXPRL_TEMP,1
         STMH  14,12,SATRXPRL_TEMP_HHREGS Save high halves of registers
         XC    SATRXPRL_TEMP_CLEAR,SATRXPRL_TEMP_CLEAR Clear 64 bytes
         LMH   14,13,SATRXPRL_TEMP_CLEAR Clear the high halves of regs
*
* Switch to 64 bit mode now
*
         SYSSTATE POP
         SAM64                Switch to 64 bit mode
*
* The parameter list given to us by RRS is in R1.  There's already a
* C mapping of the list as a struct, so change R1 to point to the
* parameter list pointer, and then the C code can use the struct.
*
         ST    1,SATRXPRL_TEMP_STG    Save origin of storage obtain
         STG   4,SATRXPRL_TEMP_PARM   Save parm list addr in 64 bit
         LGR   4,13                   Put prev dynamic area in R4
         LA    13,SATRXPRL_TEMP_DYNA  Put new dynamic area addr in R13
         LA    1,SATRXPRL_TEMP_PARM   Load parm list addr
         DROP  1
*
* Set up the DSA to point to the previous DSA
*
         STG   4,128(,13)     Backchain
*
* Define the DSECTs we're going to use if this is the first time the
* macro is being invoked.
*
         AIF (&BBGZ_SATRXPRL_DSECT).NODSECT
&BBGZ_SATRXPRL_DSECT SETB 1
SATRXPRL_TEMP            DSECT    Mapping of temporary storage
SATRXPRL_TEMP_HHREGS     DS CL60  High halves of R14-R12
SATRXPRL_TEMP_CLEAR      DS CL64  Cleared storage
                         ORG SATRXPRL_TEMP_CLEAR
SATRXPRL_TEMP_STG        DS F     Storage obtain origin
SATRXPRL_TEMP_PARM       DS FD    Addr of RRS exit parm list
SATRXPRL_TEMP_AVAIL      DS CL8   Available
SATRXPRL_TEMP_DYNA       DS CL32688 Dynamic area
*
SATRXPRL_TEMP_STORAGE_LEN EQU 32768   Length of temporary storage
SATRXPRL_TEMP_STORAGE_SUBPOOL EQU 249 Subpool of temporary storage
SATRXPRL_TEMP_STORAGE_KEY EQU 2       Key of temporary storage
*
&CCN_CSECT CSECT
.NODSECT ANOP
         MEND