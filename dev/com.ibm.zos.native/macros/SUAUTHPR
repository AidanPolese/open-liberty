*
* IBM Confidential
*
* OCO Source Materials
*
* Copyright IBM Corp. 2011
*
* The source code for this program is not published or otherwise
* divested of its trade secrets, irrespective of what has been
* deposited with the U.S. Copyright Office.
*
         MACRO
&NAME    SUAUTHPR &SAVEDYNA=,&SAVEAREA=
         GBLC  &CCN_LITN
         GBLC  &CCN_CSECT
         GBLB  &BBGZ_SUAUTHPR_DSECT
* --------------------------------------------------------------------
* TKNNAME is also defined in server_task_data.mc
* --------------------------------------------------------------------
&TKNNAME SETC 'BBGZ_SUAUTHPR_DA'
* --------------------------------------------------------------------
* Entry linkage for an unauthorized metal C function used by the
* liberty server.  Obtains a stack for this task to use.
* --------------------------------------------------------------------
* IMPORTANT NOTE
* This entry linkage clobbers the next/prev DSA pointers of the 144
* byte save area that it is given.  It assumes that the caller can
* find its save area without using the prev DSA pointer (backchain).
* This is true when calling from an XPLINK program, which has its own
* way to transition back to the XPLINK stack when the routine is
* finished.
* --------------------------------------------------------------------
*
* Aliases to prevent the compiler from failing on the C defined IEAN4*
* aliases (ASMA311E).
*
         AIF ('&SAVEDYNA' EQ 'NO').NOIEAN4CR
SUAUTHPR_IEAN4CR_&SYSNDX ALIAS C'IEAN4CR'
.NOIEAN4CR ANOP
SUAUTHPR_IEAN4RT_&SYSNDX ALIAS C'IEAN4RT'
         USING SUAUTHPR_SAVEAREA,13
* Careful not to store too many registers here.
* We should be getting 144 bytes but BPX4IPT seems to have a bug and 
* only pass us 72.
         AIF ('&SAVEAREA' NE '72').LARGESAVEAREA
         STMG  14,4,SUAUTHPR_SAVEAREA_R14T1 Store regs 14 thru 4
         LARL  2,&CCN_LITN  Address literals (for name token name)
         USING &CCN_LITN,2 
* comes from default subpool 0
         STORAGE OBTAIN,LENGTH=IPT_TEMP_STORAGE_LEN
         DROP  2
         STG   13,0(1)          save callers reg 13 in new area
         LGR   15,13
         LGR   13,1             set reg 13 to new area
         LMG   14,2,8(15)       restore regs 14 thru 2
.LARGESAVEAREA ANOP
*
* Because we're calling IARV64 to get storage, and IARV64 requires
* many arguments to be in memory, we're only saving registers 14
* thru register 1 in the save area,  The rest of the save area is
* used for parameters, until the IARV64 completes successfully.
* IARV64 will clobber registers 14, 15, 0 and 1.
*
         STMG  14,1,SUAUTHPR_SAVEAREA_R14T1 Store regs 14, 15, 0 and 1
*
* If this process is connected to the angel, the authorized code will
* have stashed this task's dynamic area off of the STCBBCBA.  Look
* there for it.
*
         USING PSA,0
         LLGT  15,PSATOLD  Load TCB from PSA
         DROP  0
         USING TCB,15
         LLGT  15,TCBSTCB  Load STCB from PSA
         DROP  15
         USING STCB,15
         LLGT  15,stcbbcba Load common task data anchor
         DROP  15
         LTGR  15,15       Is common task data anchor set?
         BRZ   SUAUTHPRNOBCBA&SYSNDX No
         LG    15,32(15)   Load unauth server task data
         LTGR  15,15       Is server task data set?
         BRZ   SUAUTHPRNOBCBA&SYSNDX No
         STG   15,SUAUTHPR_SAVEAREA_TOKPTR Pretend we got name token
         LHI   15,0
         ST    15,SUAUTHPR_SAVEAREA_TOKRC Fake good token
         BRU   SUAUTHPRFOUNDTOK&SYSNDX Jump to name token OK
*
* Try to find the dynamic area previously used by this thread by
* looking up the name token created to store the dynamic area.
*
SUAUTHPRNOBCBA&SYSNDX DS 0H
         LARL  15,&CCN_LITN  Address literals (for name token name)
         USING &CCN_LITN,15  
         MVC   SUAUTHPR_SAVEAREA_TOKNAM,=CL16'&TKNNAME' Copy name
         DROP  15
         LGHI  15,IEANT_TASK_LEVEL  Name token is for this task
         ST    15,SUAUTHPR_SAVEAREA_TOKLVL Store task level constant
         LA    1,SUAUTHPR_SAVEAREA_TOKPL Load the PL addr for IEAN4RT
         USING SUAUTHPR_IEAN4RT_PL,1
         LA    15,SUAUTHPR_SAVEAREA_TOKLVL Load addr of level const
         STG   15,SUAUTHPR_IEAN4RT_PL_LVL Store as 1st parm
         LA    15,SUAUTHPR_SAVEAREA_TOKNAM Load address of name
         STG   15,SUAUTHPR_IEAN4RT_PL_NAME Store as 2nd parm
         LA    15,SUAUTHPR_SAVEAREA_TOKTOK Load addr to store tok into
         STG   15,SUAUTHPR_IEAN4RT_PL_TOK Store as 3rd parm
         LA    15,SUAUTHPR_SAVEAREA_TOKRC Load addr to put RC into
         STG   15,SUAUTHPR_IEAN4RT_PL_RC Store as 4th parm
         CALL  SUAUTHPR_IEAN4RT_&SYSNDX Call name token retrieve
         L     15,SUAUTHPR_SAVEAREA_TOKRC Load the ret code into R15
         LTR   15,15     Check the return code (0 = good)
         BRZ   SUAUTHPRFOUNDTOK&SYSNDX
         DROP  1
*
* No name token, do the IARV64
*
         LGHI  15,SUAUTHPR_IARV64_DYN_AREA_SEGMENTS Get two segs
         STG   15,SUAUTHPR_SAVEAREA_IARV64_SEG Store segment count
         LGHI  15,SUAUTHPR_IARV64_DYN_AREA_GUARD_SEGMENTS One page grd
         ST    15,SUAUTHPR_SAVEAREA_IARV64_GRD Store guard count
         IARV64 REQUEST=GETSTOR,COND=NO,FPROT=YES,SVCDUMPRGN=YES,      X
               SEGMENTS=SUAUTHPR_SAVEAREA_IARV64_SEG,                  X
               GUARDSIZE=SUAUTHPR_SAVEAREA_IARV64_GRD,                 X
               GUARDLOC=HIGH,USERTKN=NO_USERTKN,                       X
               ORIGIN=SUAUTHPR_SAVEAREA_IARV64_ORG,                    X
               PLISTVER=0,MF=(E,SUAUTHPR_SAVEAREA_IARV64_PL,COMPLETE)
*
* Clear the first 64 K of storage for the prefix area, and initialize
* the header.
*
         LG    14,SUAUTHPR_SAVEAREA_IARV64_ORG Load obtained stg addr
         BBGZSTDI STDREG=14
         AIF ('&SAVEDYNA' EQ 'NO').NONAMTOK
*
* Create a name token, hanging the storage off of it
*
         MVC   SUAUTHPR_SAVEAREA_TOKPTR,SUAUTHPR_SAVEAREA_IARV64_ORG
         XC    SUAUTHPR_SAVEAREA_TOKCLR,SUAUTHPR_SAVEAREA_TOKCLR
         LARL  15,&CCN_LITN         Address constants (for name)
         USING &CCN_LITN,15
         MVC   SUAUTHPR_SAVEAREA_TOKNAM,=CL16'&TKNNAME' Fill in name
         DROP  15
         LGHI  15,IEANT_TASK_LEVEL  Load task level constant
         ST    15,SUAUTHPR_SAVEAREA_TOKLVL Store task level constant
         LGHI  15,IEANT_NOPERSIST   Load nonpersistant token constant
         ST    15,SUAUTHPR_SAVEAREA_TOKPER Store constant
         LA    1,SUAUTHPR_SAVEAREA_TOKPL Load addr of parameter list
         USING SUAUTHPR_IEAN4CR_PL,1
         LA    15,SUAUTHPR_SAVEAREA_TOKLVL Load task level const addr
         STG   15,SUAUTHPR_IEAN4CR_PL_LVL Store as 1st arg
         LA    15,SUAUTHPR_SAVEAREA_TOKNAM Load name token name address
         STG   15,SUAUTHPR_IEAN4CR_PL_NAME Store as 2nd arg
         LA    15,SUAUTHPR_SAVEAREA_TOKTOK Load token address
         STG   15,SUAUTHPR_IEAN4CR_PL_TOK Store as 3rd arg
         LA    15,SUAUTHPR_SAVEAREA_TOKPER Load persist const addr
         STG   15,SUAUTHPR_IEAN4CR_PL_PST Store as 4th arg
         LA    15,SUAUTHPR_SAVEAREA_TOKRC Load addr of stg to store RC
         STG   15,SUAUTHPR_IEAN4CR_PL_RC Store as 5th arg
         CALL  SUAUTHPR_IEAN4CR_&SYSNDX Call name token create
         DROP  1
*
* Jump to the 'finish' part.  We'll store the IEAN4CR return code
* in the dynamic area to check it in the epilog.
*
         LG    15,SUAUTHPR_SAVEAREA_TOKPTR Reload obtained stack
         BRU   SUAUTHPRFIN&SYSNDX
.NONAMTOK ANOP
* 
* Don't bother creating the name token -- we want to free this prefix
* area in the epilog because the caller specified SAVEDYNA=NO.
*
         LGHI  15,-1 Simulate name token create failing
         ST    15,SUAUTHPR_SAVEAREA_TOKRC Store bad RC
         LGR   15,14 Reload obtained stack
         BRU   SUAUTHPRFIN&SYSNDX
*
* We found the name token, get the dynamic area from it.  Try to take
* ownership by setting the in-use word in the prefix.
* Note offset 36 into stack prefix is the stack ownership word, and
* the dependency here is noted in server_task_data.h.
*
SUAUTHPRFOUNDTOK&SYSNDX DS 0H
         LG    15,SUAUTHPR_SAVEAREA_TOKPTR First part of tkn is stack
         LGHI  0,0 Load zero into R0 (expected)
         LGHI  1,-1 Load non-zero into R1
         CS    0,1,36(15) Try to set the in-use word
         BRZ   SUAUTHPRFIN&SYSNDX Set OK, jump to finish
         STMG  2,12,SUAUTHPR_SAVEAREA_R2T12 Store the rest of the regs
         LARL  5,&CCN_LITN
         USING &CCN_LITN,5
         ABEND ABEND_TYPE_SERVER,REASON=KRSN_SUAUTHPR_STACK_IN_USE,    X
               DUMP,STEP,SYSTEM
         DROP  5
*
* Finish up, do the DSA chaining etc
*
SUAUTHPRFIN&SYSNDX DS 0H
         OILH  15,1        Advance past the 64K prefix area
         MVC   0(4,15),SUAUTHPR_SAVEAREA_TOKRC Store RC from IEAN4xx
         AGHI  15,8        Advance 8 bytes (double word boundary)
         STMG  2,12,SUAUTHPR_SAVEAREA_R2T12 Store the rest of the regs
         LG    1,32(13)    Restore input parms
         STG   13,128(15)  Backchain
         LGR   13,15       Put stack where expected to be
         DROP  13
*
* Define the DSECTs we're going to use if this is the first time the
* macro is being invoked.
*
         AIF (&BBGZ_SUAUTHPR_DSECT).NODSECT
&BBGZ_SUAUTHPR_DSECT SETB 1
SUAUTHPR_SAVEAREA        DSECT    Caller provided F4SA
SUAUTHPR_SAVEAREA_RSVD   DS CL8   Header
SUAUTHPR_SAVEAREA_R14T1  DS CL32  Registers 14, 15, 0 and 1
SUAUTHPR_SAVEAREA_R2T12  DS CL88  Registers 2 thru 12
                        ORG SUAUTHPR_SAVEAREA_R2T12
SUAUTHPR_SAVEAREA_TOKNAM DS CL16  Name token name
SUAUTHPR_SAVEAREA_TOKLVL DS F     Name token level (home/system)
SUAUTHPR_SAVEAREA_TOKPER DS F     Name token persist option
SUAUTHPR_SAVEAREA_TOKRC  DS F     Name token service return code
SUAUTHPR_SAVEAREA_TOKAV1 DS CL4   Available (for alignment)
SUAUTHPR_SAVEAREA_TOKTOK DS CL16  Name token token
                        ORG SUAUTHPR_SAVEAREA_TOKTOK
SUAUTHPR_SAVEAREA_TOKPTR DS CL8
SUAUTHPR_SAVEAREA_TOKCLR DS CL8 
SUAUTHPR_SAVEAREA_TOKPL  DS CL40  Name token svc parameter list area
SUAUTHPR_SAVEAREA_TOKAV2 DS CL16  Available
                        ORG SUAUTHPR_SAVEAREA_R2T12
SUAUTHPR_SAVEAREA_IARV64_SEG DS FD  Segment count to obtain
                        ORG SUAUTHPR_SAVEAREA_IARV64_SEG
SUAUTHPR_SAVEAREA_IARV64_ORG DS FD  Returned memory origin address
SUAUTHPR_SAVEAREA_IARV64_GRD DS F   Guard segments to obtain
SUAUTHPR_SAVEAREA_IARV64_AV1 DS CL4 Available
SUAUTHPR_SAVEAREA_IARV64_PL  DS CL88 Parameter list for v0
*
SUAUTHPR_IARV64_DYN_AREA_SEGMENTS EQU 2        Request 2 segments
SUAUTHPR_IARV64_DYN_AREA_GUARD_SEGMENTS EQU 1  One segment is guard
*
SUAUTHPR_IEAN4RT_PL      DSECT  Parameter list for IEAN4RT
SUAUTHPR_IEAN4RT_PL_LVL  DS AD  Pointer to token level
SUAUTHPR_IEAN4RT_PL_NAME DS AD  Pointer to token name
SUAUTHPR_IEAN4RT_PL_TOK  DS AD  Pointer to token
SUAUTHPR_IEAN4RT_PL_RC   DS AD  Pointer to return code
*
SUAUTHPR_IEAN4CR_PL      DSECT  Parameter list for IEAN4CR
SUAUTHPR_IEAN4CR_PL_LVL  DS AD  Pointer to token level
SUAUTHPR_IEAN4CR_PL_NAME DS AD  Pointer to token name
SUAUTHPR_IEAN4CR_PL_TOK  DS AD  Pointer to token
SUAUTHPR_IEAN4CR_PL_PST  DS AD  Pointer to persistent option
SUAUTHPR_IEAN4CR_PL_RC   DS AD  Pointer to return code
*
IPT_TEMP_STORAGE_LEN EQU 512     Length of temporary storage
*
         RASABEND
*
&CCN_CSECT CSECT
.NODSECT ANOP
*
         MEND
