*
* IBM Confidential
*
* OCO Source Materials
*
* Copyright IBM Corp. 2011
*
* The source code for this program is not published or otherwise
* divested of its trade secrets, irrespective of what has been
* deposited with the U.S. Copyright Office.
*
         MACRO
&NAME    SRMGRPRL &REQTASKD=
         GBLC  &CCN_LITN
         GBLC  &CCN_CSECT
         GBLB  &BBGZ_SRMGRPRL_DSECT
*
* This prolog gets control for RESMGR recovery in 31 bit mode, gets
* dynamic area, and modifies the parameter list to give control to
* the corresponding metal C function in 64 bit mode.
* @param REQTASKD specify 'YES' to return immediately if there is no
*                 server task data control block for this task.
*
         SYSSTATE PUSH
         SYSSTATE AMODE64=NO
         STM   14,12,12(13)  Store registers
         USING PSA,0
         L     15,PSATOLD  Load TCB from PSA
         DROP  0
         USING TCB,15
         L     15,TCBSTCB  Load STCB from PSA
         DROP  15
         USING STCB,15
         L     15,stcbbcba Load common task data anchor
         DROP  15
         LTR   15,15       Is common task data anchor set?
         BRZ   NOTGOO&SYSNDX No
         LG    15,24(15)   Load server task data.  Clober R15.
         LTGR  15,15       Is server task data set?
         BRNZ  TAKETGOO&SYSNDX Yes - use it
NOTGOO&SYSNDX DS 0H
*
* No server task data created yet.  We need to get a dynamic area
* for this task using IARV64.  We don't have room in the save area
* to put the parameter list for IARV64 because it's only a 72 byte
* save area.  We need to get some temporary storage using storage 
* obtain, which we can then use to call IARV64.
*
         AIF ('&REQTASKD' NE 'YES').INVTASKD
         LM    14,12,12(13)  Restore registers
         LHI   15,0          Always return RC = 0
         BR    14            Return to caller
* TODO: Support REQTASKD=NO, get dynamic area, and reverse in epilog
*
* We have a TGOO. 
*
TAKETGOO&SYSNDX DS 0H
*
* Switch to 64 bit mode now.  Note we haven't saved the high halves
* of the registers yet.
*
         SYSSTATE POP
         SAM64                Switch to 64 bit mode
         LHI   6,0         Load zero into R6 (expected value)
         LHI   7,-1        Load non-zero into R7
         CS    6,7,36(15)  Try to take dynamic area
         BRZ   FINISH&SYSNDX Branch if successful
         LARL  5,&CCN_LITN
         USING &CCN_LITN,5
         ABEND ABEND_TYPE_SERVER,REASON=KRSN_SRMGRPRL_STACK_IN_USE,    X
               DUMP,STEP,SYSTEM
         DROP  5
*
* Save the high halves of the registers in the TGOO.
*
FINISH&SYSNDX DS 0H
         OILH  15,1        Advance past the 64K prefix area
         STMH  14,12,0(15) Save high halves of registers
         XC    60(60,15),60(15) Clear 60 bytes
         LMH   0,14,60(15) Clear the high halves of regs, except R15
         AGHI  15,64       Advance past high halves of registers
*
* The parameter list given to us by RESMGR is two 31 bit pointers.
* We will re-construct the parameter list so it's two 64 bit pointers.
*
         LLGT  4,0(1)         Load RMPL pointer into R1
         STG   4,0(15)        Store RMPL pointer
         LLGT  4,4(1)         Load user parm pointer into R1
         STG   4,8(15)        Store user parm pointer
         LGR   1,15           Load new parm list into R1
         AGHI  15,16          Advance past new parm list
*
* Finish up.
*         
         STG   13,128(15)  Backchain
         LGR   13,15       Put stack where expected to be
*
* Define the DSECTs we're going to use if this is the first time the
* macro is being invoked.
*
         AIF (&BBGZ_SRMGRPRL_DSECT).NODSECT
&BBGZ_SRMGRPRL_DSECT SETB 1
*
         RASABEND
*
&CCN_CSECT CSECT
.NODSECT ANOP
         AGO .ENDING
.INVTASKD ANOP
         MNOTE 8,'ONLY REQTASKD=YES IS CURRENTLY SUPPORTED'
.ENDING  ANOP
*
         MEND
