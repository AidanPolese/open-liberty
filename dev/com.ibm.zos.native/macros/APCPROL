*
* IBM Confidential
*
* OCO Source Materials
*
* Copyright IBM Corp. 2011
*
* The source code for this program is not published or otherwise
* divested of its trade secrets, irrespective of what has been
* deposited with the U.S. Copyright Office.
*
         MACRO
&NAME    APCPROL
         GBLC  &CCN_LITN
         GBLC  &CCN_CSECT
         GBLB  &BBGZ_APCPROL_DSECT
*
* On entry, register 4 points to an 8 byte area which is the latent
* parm area.  The first word points to the BBGZPLPA control block
* which contains a pointer to the SGOO for the angel we are either
* connecting to or connected to.  The latent parm area was set up
* by the ETDEF macro in angel_pc_initialization.mc.
*
* Address the literal area in register 7.  This is where the compiler
* puts all of the literals in the assembler source.
*
         LARL  7,&CCN_LITN
         USING &CCN_LITN,7
         LGR   8,1 Save input parms so don't get clobbered
         LTGR  5,0 Save number of input parms so don't get clobbered
         BRL   INVPARM&SYSNDX Branch to ABEND if parm count < 0
         CGHI  5,9 See if parm count is <= 8
         BRL   GOODPARM&SYSNDX Skip ABEND if parm count 0<=x<=8
INVPARM&SYSNDX DS 0H
         ABEND ABEND_TYPE_SERVER,REASON=KRSN_APCPROL_INV_PARM_COUNT,   X
               DUMP,STEP,SYSTEM
*
* See if this thread has a TGOO hung off the STCB.  The TGOO has a 
* pointer to dynamic area that we can use
*
GOODPARM&SYSNDX DS 0H
         USING PSA,0
         LLGT  15,PSATOLD  Load TCB from PSA
         DROP  0
         USING TCB,15
         LLGT  15,TCBSTCB  Load STCB from PSA
         DROP  15
         USING STCB,15
         LLGT  15,stcbbcba Load common task data anchor
         DROP  15
         LTGR  15,15       Is common task data anchor set?
         BRZ   NOTGOO&SYSNDX No
         LG    15,16(15)   Load angel task data
         LTGR  15,15       Is angel task data set?
         BRNZ  HAVETGOO&SYSNDX Yes - use it
NOTGOO&SYSNDX DS 0H
*
* No TGOO, we will get dynamic area using IARV64.
* Get some storage that we can use for a parameter list to IARV64
*
         STORAGE OBTAIN,LENGTH=APCPROL_TEMP_STORAGE_LEN,BNDRY=DBLWD,   X
               SP=APCPROL_TEMP_STORAGE_SUBPOOL,                        X
               KEY=APCPROL_TEMP_STORAGE_KEY
*
* Fill in the parameter list for IARV64.  Get 1MB to use as our stack.
* This storage will serve as our dynamic area, as well as a prefix
* area that we can use to store things needed by this thread.  The
* prefix area is 64K, followed by the dynamic area.
*
         LGR   6,1       Move IARV64 parameter list
         USING APCPROL_IARV64,6
         LGHI  15,APCPROL_IARV64_DYN_AREA_SEGMENTS
         STG   15,APCPROL_IARV64_SEGCT Store segment count
         LGHI  15,APCPROL_IARV64_DYN_AREA_GUARD_SEGMENTS
         ST    15,APCPROL_IARV64_GUARDSZ
         LGHI  15,APCPROL_IARV64_DYN_AREA_STORAGE_KEY
         STC   15,APCPROL_IARV64_KEY Store key
         IARV64 REQUEST=GETSTOR,COND=NO,SEGMENTS=APCPROL_IARV64_SEGCT, X
               KEY=APCPROL_IARV64_KEY,FPROT=NO,SVCDUMPRGN=YES,         X
               CONTROL=AUTH,GUARDSIZE=APCPROL_IARV64_GUARDSZ,          X
               GUARDLOC=HIGH,USERTKN=NO_USERTKN,                       X
               ORIGIN=APCPROL_IARV64_ORIGIN,                           X
               PLISTVER=0,MF=(E,APCPROL_IARV64_PLIST,COMPLETE)
         LG    13,APCPROL_IARV64_ORIGIN Put storage where expected
         DROP  6
*
* Release the parameter list that we used for IARV64
*
         STORAGE RELEASE,LENGTH=APCPROL_TEMP_STORAGE_LEN,ADDR=(6),     X
               SP=APCPROL_TEMP_STORAGE_SUBPOOL,                        X
               KEY=APCPROL_TEMP_STORAGE_KEY
         DROP  7
*
* Clear the first 64 K of storage for the prefix area and initialize
* the header.
*
         BBGZATDI ATDREG=13
         BRU   MASSAGE&SYSNDX
*
* We have angel task data.  The angel task data is the prefix to our
* stack.  Make sure that no one is using it before we use it (ie. an
* IRB got dispatched on this task and is running simultaneously).
* Note offset 28 into stack prefix is the stack ownership word, and
* the dependency here is noted in angel_task_data.h.
*
HAVETGOO&SYSNDX DS 0H
         LGHI 6,-1 Load non-zero value into R6
         LGHI 7,0  Load zero into R7, expected value
         CS   7,6,28(15) Try to take the dynamic area
         BRZ  TOOKDYNA&SYSNDX Branch if we took the dynamic area
         LARL  7,&CCN_LITN
         USING &CCN_LITN,7
         ABEND ABEND_TYPE_SERVER,REASON=KRSN_APCPROL_STACK_IN_USE,     X
               DUMP,STEP,SYSTEM
         DROP  7
TOOKDYNA&SYSNDX DS 0H
         LGR  13,15
*
* Advance past the 64K prefix to the dynamic area.
*
MASSAGE&SYSNDX OILH  13,1 Advance 64K
*
* Massage the caller's parameters into key 2.  Prefix the parameter
* list with the latent parm area.
*
         L     4,0(4)    Load first word of latent parm area
         STG   4,0(13)   Store latent parm control block addr in R13
         SLAG  5,5,3(0)  Multiply parm count by 8 (shift 3)
         LTGR  0,5       Move length to R0 for MVCSK
         BZ    ADVANCE&SYSNDX Don't move if no parms
         AGHI  0,-1      Subtract 1 for MVCSK length
         LGHI  1,128     Source key is 8, 0x80 hex
         MVCSK 8(13),0(8) Move parm list to after latent parm
ADVANCE&SYSNDX LGR   1,13 Restore input parms in key 2
         AGR   13,5      Advance R13 for dynamic area (parms)
         AGHI  13,8      Advance R13 for dynamic area (latent parms)
*
* Define the DSECTs we're going to use if this is the first time the
* macro is being invoked.
*
         AIF (&BBGZ_APCPROL_DSECT).NODSECT
&BBGZ_APCPROL_DSECT SETB 1
APCPROL_IARV64         DSECT    Mapping of the parms to IARV64
APCPROL_IARV64_SEGCT   DS FD    Number of segments requested
                       ORG APCPROL_IARV64_SEGCT
APCPROL_IARV64_ORIGIN  DS FD    Returned storage start address
APCPROL_IARV64_GUARDSZ DS F     Number of guard segments requested
APCPROL_IARV64_KEY     DS CL1   Storage key requested
                       DS CL3   Available
APCPROL_IARV64_PLIST   DS CL88  Parameter list for execute form v0
                       DS CL152 Available
APCPROL_IARV64_DYN_AREA_SEGMENTS EQU 2        Request 2 segments
APCPROL_IARV64_DYN_AREA_GUARD_SEGMENTS EQU 1  One segment is guard
APCPROL_IARV64_DYN_AREA_STORAGE_KEY EQU X'20' Storage in key 2
APCPROL_TEMP_STORAGE_LEN EQU 256     Length of temporary storage
APCPROL_TEMP_STORAGE_SUBPOOL EQU 229 Subpool of temporary storage
APCPROL_TEMP_STORAGE_KEY EQU 2       Key of temporary storage
*
         RASABEND
*
&CCN_CSECT CSECT
.NODSECT ANOP
         MEND