*
* IBM Confidential
*
* OCO Source Materials
*
* Copyright IBM Corp. 2011
*
* The source code for this program is not published or otherwise
* divested of its trade secrets, irrespective of what has been
* deposited with the U.S. Copyright Office.
*
         MACRO
&NAME    AAUTHEPL
         GBLC  &CCN_CSECT
         GBLC  &CCN_LITN
         GBLB  &BBGZ_AAUTHEPL_DSECT
* --------------------------------------------------------------------
* IMPORTANT NOTE
* This exit linkage clobbers the next/prev DSA pointers of the 144
* byte save area that it is given.  It assumes that the caller can
* find its save area without using the prev DSA pointer (backchain).
* This is true when calling from an XPLINK program, which has its own
* way to transition back to the XPLINK stack when the routine is
* finished.
* --------------------------------------------------------------------
*
* We saved the return code from name token create (IEAN4CR) 8 bytes
* back from the dynamic area.  If the name token create was
* successful, then we don't need to free our dynamic area storage
* because it's hung off the name token for the next caller.
*
         LGR  1,13             Copy dynamic area address to reg 1
         AGHI 1,-8             Subtract to find IEAN4CR return code
         L    2,0(1)           Load return code
         LTR  2,2              Test return code
         BRZ  AAUTHEPLNONEEDTOFREE&SYSNDX 
*
* Free the dynamic area
*
         LGR  2,15             Save return code in register 2
         NILH 1,X'FFFE'        Subtract 64K prefix from dynamic area
         LG   13,128(13)       Restore caller provided RSA.
         USING AAUTHEPL_SAVEAREA,13
         LMG  3,12,AAUTHEPL_SAVEAREA_R3T12 Restore regs 3 thru 12
         STG  1,AAUTHEPL_SAVEAREA_IARV64_ORG Store address to free
         IARV64 REQUEST=DETACH,MATCH=SINGLE,                           X
               MEMOBJSTART=AAUTHEPL_SAVEAREA_IARV64_ORG,               X
               USERTKN=NO_USERTKN,COND=NO,PLISTVER=0,                  X
               MF=(E,AAUTHEPL_SAVEAREA_IARV64_PL,COMPLETE)
         LG   14,AAUTHEPL_SAVEAREA_R14 Restore reg 14
         LGR  15,2             Restore reg 15 (return code)
         LMG  1,2,AAUTHEPL_SAVEAREA_R1T2 Restore regs 1 thru 2
         BR   14               Return to caller
         DROP 13
AAUTHEPLNONEEDTOFREE&SYSNDX DS 0H
*
* Try to unset the in-use bit in the prefix.
*
         LGR   3,1         Compute server task data in reg 3
         NILH  3,X'FFFE'   Subtract 64K prefix from dynamic area
         LGHI 6,-1 Load non-zero into R6 (expected value)
         LGHI 7,0  Load zero into R7
         CS   6,7,28(3) Try to return the dynamic area
         BRZ  RTNTOCALLER&SYSNDX Branch if we returned the dyn area
         LARL  5,&CCN_LITN
         USING &CCN_LITN,5
         ABEND ABEND_TYPE_SERVER,REASON=KRSN_AAUTHEPL_STACK_IN_USE,    X
               DUMP,STEP,SYSTEM
         DROP  5
RTNTOCALLER&SYSNDX DS 0H
         LG   13,128(13)       Restore caller provided RSA.
         LMG  1,12,32(13)      Restore regs 1 thru 12
         LG   14,8(13)         Restore reg 14
         BR   14               Return to caller
*
* Define the DSECTs we're going to use if this is the first time the
* macro is being invoked.
*
         AIF (&BBGZ_AAUTHEPL_DSECT).NODSECT
&BBGZ_AAUTHEPL_DSECT SETB 1
AAUTHEPL_SAVEAREA        DSECT    Caller provided F4SA
AAUTHEPL_SAVEAREA_RSVD   DS CL8   Header
AAUTHEPL_SAVEAREA_R14T2  DS CL40  Registers 14, 15, 0, 1 and 2
                        ORG AAUTHEPL_SAVEAREA_R14T2
AAUTHEPL_SAVEAREA_R14    DS CL8
AAUTHEPL_SAVEAREA_R15T0  DS CL16
AAUTHEPL_SAVEAREA_R1T2   DS CL16
AAUTHEPL_SAVEAREA_R3T12  DS CL80  Registers 2 thru 12
                        ORG AAUTHEPL_SAVEAREA_R3T12
AAUTHEPL_SAVEAREA_IARV64_ORG DS FD  Returned memory origin address
AAUTHEPL_SAVEAREA_IARV64_PL  DS CL88 Parameter list for v0
*
         RASABEND
*
&CCN_CSECT CSECT
.NODSECT ANOP
*
         MEND
