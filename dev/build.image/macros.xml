<?xml version="1.0" encoding="UTF-8"?>
<project name="macros">
  <import file="../ant_build/public_imports/internal_imports/buildtasks.xml"/>
  <macrodef name="packageServer">
    <attribute name="server"/>
    <attribute name="archive"/>
    <attribute name="user.dir"/>
    <attribute name="output.dir" default="@{user.dir}/servers"/>

    <sequential>
      <property name="extra.package.options" value=""/>
      <!-- minify the embeddable wlp install with the server.xml that has just the extended feature manifests -->
      <iff if="unix.shell">
        <then>
          <echo message="Packaging server to @{archive}"/>
          <mkdir dir="@{output.dir}/@{server}/logs/"/>
          <!-- allow 5 seconds for the start command to return -->
          <exec dir="wlp" executable="${unix.shell}">
            <arg value="bin/server" />
            <arg value="package" />
            <arg value="@{server}" />
            <arg value="--include=minify" />
            <arg value="--archive=@{archive}" />
            <arg value="--clean"/>
            <arg value="${extra.package.options}"/>
            <env key="WLP_USER_DIR" value="@{user.dir}" />
            <env key="WLP_OUTPUT_DIR" value="@{output.dir}" />
            <env key="JAVA_HOME" value="${java.home}" />
          </exec>
        </then>
        <else>
          <iff if="msoft.environment">
            <then>
              <exec dir="wlp\bin" executable="CMD">
                <arg value="/C" />
                <arg value="server.bat" />
                <arg value="package" />
                <arg value="@{server}" />
                <arg value="--include=minify" />
                <arg value="--archive=@{archive}" />
                <arg value="--clean"/>
                <arg value="${extra.package.options}"/>
                <env key="WLP_USER_DIR" value="@{user.dir}" />
                <env key="WLP_OUTPUT_DIR" value="@{output.dir}" />
                <env key="JAVA_HOME" value="${java.home}" />
              </exec>
            </then>
            <else>
              <!-- Without the script, we have no way to redirect console.log. -->
              <fail message="unix.shell must be set" />
            </else>
          </iff>
        </else>
      </iff>
      <echo message="Packaged server to @{archive}"/>

      <!-- If we're running against a partial image, there are of course going to be missing features. Long term, 
      we need to get the whitelist of missing features and only filter them (task 163292). Tactically, to reduce build noise, 
      just suppress all of the warnings about missing features in this case. -->

      <condition property="allowed.minify.errors" value=" E CWWKF0001E:" else="A string that will never occur">
        <istrue value="${unittest.prop.allow.missing.features}"/>
      </condition>
      <!-- Core features create different missing messages when not found -->
      <condition property="allowed.minify.errors.core" value=" E CWWKF0042E:" else="A string that will never occur">
        <istrue value="${unittest.prop.allow.missing.features}"/>
      </condition>

      <copy file="@{output.dir}/@{server}/logs/messages.log" tofile="@{output.dir}/@{server}/logs/package-errors.log">
        <filterchain>
          <linecontainsregexp>
            <regexp pattern="[A-Z]{5}[0-9]{4}E: "/>
          </linecontainsregexp>
          <linecontainsregexp negate="true">
            <regexp pattern="${allowed.minify.errors}"/>
          </linecontainsregexp>
          <linecontainsregexp negate="true">
            <regexp pattern="${allowed.minify.errors.core}"/>
          </linecontainsregexp>
        </filterchain>
      </copy>
      <local name="package.log.file.len"/>
      <length property="package.log.file.len" file="@{output.dir}/@{server}/logs/package-errors.log" />
      <iff>
        <not>
          <equals arg1="0" arg2="${package.log.file.len}"/>
        </not>
        <then>
          <local name="file.name"/>
          <basename property="file.name" file="@{archive}"/>
          <local name="package.error"/>
          <loadfile property="package.error" srcFile="@{output.dir}/@{server}/logs/messages.log" failonerror="false"/>
          <local name="package.errors.log.content"/>
          <loadfile property="package.errors.log.content" srcFile="@{output.dir}/@{server}/logs/package-errors.log" failonerror="false"/>
          <publishAsJunitFailure claimedTestClassName="${file.name}"
                             claimedTestCaseName="archive creation - messages.log content"
                             summary="${file.name} could not be created"
                             failureText="${package.error}"
                             tempFile="${build.tmp.dir}/${file.name}-imagefail.xml"
                             encoding="ISO-8859-1" />
          <publishAsJunitFailure claimedTestClassName="${file.name}"
                             claimedTestCaseName="archive creation - package-errors.log content"
                             summary="${file.name} could not be created"
                             failureText="${package.errors.log.content}"
                             tempFile="${build.tmp.dir}/${file.name}-imagefail2.xml"
                             encoding="ISO-8859-1" />
          <!-- If we're running locally (not an RTC build) then we want to report the packaging failure and halt the build.
               Do not fail ant build if running in an RTC build (keep going) -->
          <condition property="halt.on.packaging.failure">
            <not>
              <isset property="is.running.rtc.build" />
            </not>
          </condition>
        </then>
      </iff>
    </sequential>
  </macrodef>

  <macrodef name="generateFeatureList">
    <attribute name="output.file"/>

    <sequential>
      <!-- minify the embeddable wlp install with the server.xml that has just the extended feature manifests -->
      <iff if="unix.shell">
        <then>
          <!-- allow 5 seconds for the start command to return -->
          <exec dir="wlp" executable="${unix.shell}">
            <arg value="bin/featureManager" />
            <arg value="featureList" />
            <arg value="@{output.file}" />
            <env key="JAVA_HOME" value="${java.home}" />
          </exec>
        </then>
        <else>
          <iff if="msoft.environment">
            <then>
              <exec dir="wlp\bin" executable="CMD">
                <arg value="/C" />
                <arg value="featureManager.bat" />
                <arg value="featureList" />
                <arg value="@{output.file}" />
                <env key="JAVA_HOME" value="${java.home}" />
              </exec>
            </then>
            <else>
              <!-- Without the script, we have no way to redirect console.log. -->
              <fail message="unix.shell must be set" />
            </else>
          </iff>
        </else>
      </iff>
    </sequential>
  </macrodef>

  <macrodef name="createAddOnInstaller">
    <attribute name="addOn" />
    <attribute name="edition"/>
    <attribute name="runtime.archive"/>
    <attribute name="properties" />
    <attribute name="license.properties" />
    <sequential>
      <!-- the edition can provide properties to configure how it is created, local them
             to ensure it only affects this build and then load the properties -->
      <local name="license.type" />
      <local name="default.archive.name" />
      <local name="archive.name" />
      <local name="editions" />
      <local name="add.to.download.xml" />
      <local name="build.always" />
      <local name="build.repo.metadata"/>
      <local name="repo.name"/>
      <local name="repo.shortDescription"/>
      <local name="repo.downloadURL"/>
      <local name="subsystemContent"/>
      <local name="build.addon.esa"/>
      <local name="addon.esa.editions"/>
      <local name="dhe.license.path"/>
      <local name ="license.editions" />
      <local name="files.to.strip"/>

      <!-- Build up the default archive name in case one of the properties want to use it -->
      <property name="default.archive.name" value="${install.name}-@{edition}-@{addOn}-${edition.version}" />

      <!-- read the archive properties file, this should set license.type and archive.name -->
      <property file="@{properties}" />
      <property file="@{license.properties}" />

      <!-- Set the archive name and addon.esa.editions if they haven't been set in the edition specific properties -->
      <property name="archive.name" value="${default.archive.name}" />
      <property name="addon.esa.editions" value="${editions}" />
      <property name="license.editions" value="${license.editions}" />

      <!-- We only build if the edition build properties file says it always builds, or 
             the build is building all the images -->
      <iff>
        <or>
          <equals arg1="${create.im.repo}" arg2="true"/>
          <equals arg1="${build.license.zip}" arg2="true"/>
          <equals arg1="${build.always}" arg2="true" />
        </or>
        <then>
          <!-- Create a server.xml that contains everything from the runtime and this addon -->
          <echo file="${build.dir}/servers/image/server.xml">
&lt;server&gt;
  &lt;include location="${editions.@{edition}}/runtime.xml" /&gt;
  &lt;include location="${editions.@{edition}}/@{addOn}.xml" /&gt;
&lt;/server&gt;
            </echo>

          <!-- Get a server zip that contains everything that would be installed once this addon was installed -->
          <echo message="Building installer ${archive.name}.jar" />
          <packageServer server="image"
                           archive="${basedir}/build/tmp/${archive.name}.zip" 
                           user.dir="${build.dir}"
                           output.dir="${build.dir}/archives"/>

          <mkdir dir="build/tmp/big"/>
          <mkdir dir="build/tmp/core"/>
          <mkdir dir="build/tmp/extended"/>

          <unzip dest="build/tmp/big" src="${basedir}/build/tmp/${archive.name}.zip"/>
          <!-- if the edition is beta or bluemix validate for any new/unapproved opensource packages -->
          <validateOpenSource archive.name = "${basedir}/build/tmp/${archive.name}.zip" tempDir="${basedir}/build/tmp/big"/>

          <java jar="@{runtime.archive}" fork="true">
            <arg value="-acceptLicense"/>
            <arg value="build/tmp/core"/>
          </java>

          <!-- copy all the files that only exist in the jar that contains all the content -->
          <copy todir="build/tmp/extended">
            <fileset dir="build/tmp/big" includes="**/*">
              <present present="srconly" targetdir="build/tmp/core"/>
            </fileset>
          </copy>
          <!-- We don't want the usr dir, or the package file from the lib versions folder so we remove them -->
          <delete includeemptydirs="true">
            <fileset dir="${basedir}/build/tmp/extended/wlp/" includes="usr/**/*"/>
            <fileset dir="${basedir}/build/tmp/extended/wlp/" includes="usr"/>
            <fileset dir="${basedir}/build/tmp/extended/wlp/lib/versions" includes="package*"/>
            <fileset dir="${basedir}/build/tmp/extended/wlp/lib" includes="versions*"/>
          </delete>

          <!-- Deleting unwanted files -->
          <iff>
            <isset property="files.to.strip" />
            <then>
              <delete  includeemptydirs="true" failonerror="false">
                <fileset dir="${basedir}/build/tmp/extended/wlp" includes="${files.to.strip}"/>
              </delete>
            </then>
          </iff>

          <!-- We now need to work out what the extended content needs, so we do some magic here involving
                 creating a zip with the extended content, plus only what is needed from the runtime jar -->
          <local name="minifyServerDir" />
          <local name="minifyExtendedZip" />
          <property name="minifyServerDir" value="${build.dir}/tmp/big/wlp/usr/servers/image" />
          <property name="minifyExtendedZip" value="minifyExtended.zip" />
          <mkdir dir="${minifyServerDir}" />

          <!-- Generate a zip with just the extended content, we use this to work out what features are required
                 by the extended content -->
          <echo file="${build.dir}/servers/image/server.xml">
&lt;server&gt;
      &lt;include location="${editions.@{edition}}/@{addOn}.xml" /&gt;
&lt;/server&gt;
            </echo>

          <!-- minify the embeddable wlp install with the server.xml that has just the extended feature manifests -->
          <packageServer server="image"
                           archive="${build.dir}/tmp/${minifyExtendedZip}" 
                           user.dir="${build.dir}"/>

          <!-- Get a comma separated String that lists the required core features to add as a manifest header -->
          <local name="require.feature" />
          <local name="provide.feature" />
          <local name="license.type.check"/>
          <local name="applies.to"/>
          <condition property="license.type.check" value="; productLicenseType=${license.type}" else="">
            <and>
              <isset property="license.type"/>
              <not>
                <equals arg1="${license.type}" arg2=""/>
              </not>
              <not>
                <equals arg1="${license.type}" arg2="UNSPECIFIED"/>
              </not>
            </and>
          </condition>
          <listCoreAndExtendedFeatures minifyZipLocation="${build.dir}/tmp/${minifyExtendedZip}">
            <fileset dir="${build.dir}/tmp/extended/wlp/lib/features" includes="*.mf" />
          </listCoreAndExtendedFeatures>
          <iff>
            <equals arg1="${build.addon.esa}" arg2="true"/>
            <then>
              <!-- We are building an ESA that contains the same content provided by the addon archive.  We can use the output from 
                 listCoreAndExtendedFeatures to create the subsystem content and inject it into a templated manifest file
                 (extendedPackage-1.0.mf).  Then we will copy it to a special directory in the build dir 
                 (build/@{edition}/esaManifests) so that it is then picked up in the embedable zip. -->
              <convertProvideFeaturesToSubsystemContent provideFeatureValue="${provide.feature}" subsystemContentPropertyName="subsystemContent"/>
              <mkdir dir="${build.dir}/@{edition}/esaManifests"/>
              <copy tofile="${build.dir}/@{edition}/esaManifests/@{addOn}Package-1.0.mf" file="${basedir}/extendedPackage-1.0.mf">
                <filterset>
                  <filter token="SUBSYSTEM_CONTENT" value="${subsystemContent}"/>
                  <filter token="SUBSYSTEM_NAME" value="@{addOn}Package-1.0"/>
                  <filter token="APPLIES_TO_EDITIONS" value="${addon.esa.editions}"/>
                  <filter token="APPLIES_TO_VERSION" value="${edition.version}"/>
                </filterset>
              </copy>
              <copy todir="${build.dir}/tmp/extended/${install.name}/lib/features/l10n">
                <fileset dir="${basedir}/editions/@{edition}/@{addOn}/l10n/"/>
                <globmapper from="subsystem*.properties" to="com.ibm.websphere.appserver.@{addOn}Package-1.0*.properties"/>
                <filterset>
                  <filter token="VERSION" value="${edition.version}"/>
                </filterset>
              </copy>
            </then>
          </iff>

          <local name="applies.to"/>
          <!-- Build applies to here instead of BND to ensure it is consistent with the download we generate later on. We need a " in the value so use ''  to enclose the value -->
          <property name="applies.to" value='com.ibm.websphere.appserver; productVersion=${edition.version}; productInstallType=Archive; productEdition="${editions}"${license.type.check}'/>

          <!-- Populate applies to tag for licenses -->
          <local name="license.applies.to" />
          <property name="license.applies.to" value='com.ibm.websphere.appserver; productInstallType=Archive; productEdition="${license.editions}"${license.type.check}'/>

          <local name="la.header" />
          <local name="li.header" />

          <condition property="la.header" value="License-Agreement: wlp/lafiles/LA" else="">
            <available file="editions/@{edition}/runtime/lafiles/" />
          </condition>
          <condition property="li.header" value="License-Information: wlp/lafiles/LI" else="">
            <available file="editions/@{edition}/runtime/lafiles/" />
          </condition>

          <!-- Generate a bnd file specifically for the addon -->
          <echo file="${basedir}/build-install-@{addOn}.bnd">
-include= ~build-install-addon.bnd
edition=@{edition}
require.feature=${require.feature}
provide.feature=${provide.feature}
applies.to=${applies.to}
archive=@{addOn}
            </echo>

          <!-- generate a bnd file to create the license jar-->
          <echo file="${basedir}/build-lic-install-@{edition}.bnd">
-include= ~build-lic-install.bnd
edition=@{edition}
archive=runtime
license.applies.to=${license.applies.to}
${la.header}
${li.header}
           </echo>

          <!-- and run bnd -->
          <bnd eclipse="false"
                 failok="false"
                 exceptions="true"
                 classpath="${pcp}"
                 output="${liberty.image.output.upload.dir}/${archive.name}.jar"
                 files="${basedir}/build-install-@{addOn}.bnd" />

          <!-- Run build-lic-install bnd to get license archive -->
          <iff>
            <available file="@{license.properties}" />
            <then>
              <bnd eclipse="false"
             failok="false"
             exceptions="true"
             classpath="${pcp}"
             output="${liberty.image.output.upload.dir}/wlp-${edition}-license.jar"
             files="${basedir}/build-lic-install-@{edition}.bnd" />
            </then>
          </iff>

          <!-- tidy up after outselves -->
          <delete file="${basedir}/build-install-@{addOn}.bnd"/>
          <delete file="${basedir}/build-lic-install-@{edition}.bnd"/>
          <delete dir="build/tmp/big"/>
          <delete dir="build/tmp/core"/>
          <delete dir="build/tmp/extended"/>
          <delete file="${basedir}/build/tmp/${archive.name}.zip"/>

          <echo file="build/@{edition}/generatedArchives.properties" append="true">,${archive.name}.jar</echo>

          <!-- Add to the download.xml if this edition properties says to -->
          <iff>
            <istrue value="${add.to.download.xml}" />
            <then>

              <echo message="Adding /wlp/${edition.version}/${archive.name}.jar to download.xml"/>

              <!-- Add the info to the download XML.  If no download XML attirbute is supplied this is a no-op -->
              <local name="archive.size"/>
              <length file="${liberty.image.output.upload.dir}/${archive.name}.jar" property="archive.size"/>
              <createDownloadXml downloadXmlFile="${download.xml.output.file}" 
                                   name="${repo.name}"
                                   licenses="${dhe.license.path}"
                                   filePath="/wlp/${display.edition.version}/${archive.name}.jar"
                                   archiveSize="${archive.size}"
                                   appliesTo="${applies.to}"
                                   provideFeature="${provide.feature}"
                                   type="addon"/>
            </then>
          </iff>

          <!-- create addon ${archive.name}.zip -->
          <iff>
            <istrue value="${build.repo.metadata}"/>
            <then>
              <!-- Put this file into the output directory for this version of the repo -->
              <mkdir dir="${dhe.repo.build.basedir}/${display.edition.version}/${dhe.repo.root.path}/wlp/${display.edition.version}"/>

              <createRepositoryMetadata lafiles="editions/@{edition}/@{addOn}/lafiles_html/" outputDir="${dhe.repo.build.basedir}/${display.edition.version}/${dhe.repo.root.path}/wlp/${display.edition.version}" descriptionFile="editions/@{edition}/@{addOn}.description.html" repo.downloadURL="repo.downloadURL"/>

              <!-- Create the JSON for the Addon -->
              <createJsonMacro assetFile="${liberty.image.output.upload.dir}/${archive.name}.jar"
                        metadataFile="${dhe.repo.build.basedir}/${display.edition.version}/${dhe.repo.root.path}/wlp/${display.edition.version}/${archive.name}.jar.metadata.zip"
                        assetType="ADDON"
                        outputDir="${dhe.repo.build.basedir}/${display.edition.version}/${dhe.repo.root.path}/wlp/${display.edition.version}"/>

              <!-- This is something for the repo so make sure it gets included in the repo ZIP -->
              <copy todir="${dhe.repo.build.basedir}/${display.edition.version}/${dhe.repo.root.path}/wlp/${display.edition.version}">
                <fileset file="${liberty.image.output.upload.dir}/${archive.name}.jar"/>
                <fileset file="${liberty.image.output.upload.dir}/${archive.name}.jar.json"/>
              </copy>
              <iff>
                <istrue value="${add.to.download.xml}" />
                <then>
                  <!-- This is going to be used by the tools so also copy in the lafiles -->
                  <copy todir="${dhe.repo.build.basedir}/${display.edition.version}/${dhe.repo.root.path}${dhe.license.path}">
                    <fileset dir="editions/@{edition}/@{addOn}/lafiles_html/">
                      <!-- Tools only want the combined file, e.g. en.html -->
                      <exclude name="LA_*"/>
                      <exclude name="LI_*"/>
                    </fileset>
                  </copy>
                </then>
              </iff>
            </then>
          </iff>

          <echo message="AddOn ${archive.name}.jar created successfully." />
        </then>
        <else>
          <echo message="Skipping the build of ${archive.name}.jar" />
        </else>
      </iff>
    </sequential>
  </macrodef>

  <!-- 126466: Produce the metadata .zip file to go with the product or addon.jar 
  We need to create a .zip file with:
    /assetInfo.properties
        - name=someName
        - shortDescription=something
        - longDescription=<html>A few more somethings</html>
        - url=http://address.in.dhe.where.this.will.live
        - licenseType=ILAN,ILAR etc.

    /en.html, /de.html etc - license files to follow later. 
        - user story 107419 or 122720 or 122608
        - also add licenseType field - required by upload utils. 
  -->
  <macrodef name="createRepositoryMetadata">
    <attribute name="descriptionFile"/>
    <attribute name="lafiles" />
    <attribute name="outputDir" />
    <attribute name="building.withjava" default="false"/>
    <attribute name="edition.version" default="${edition.version}"/>
    <attribute name="file.extension" default=".jar"/>
    <attribute name="repo.downloadURL" default=""/>
    <attribute name="provide.feature" default=""/>
    <attribute name="generic.requirements" default="" />
    <attribute name="packaged.java" default="" />
    <attribute name="web.display.policy" default="" />
    <sequential>
      <local name="tempPropsFile"/>
      <local name="tempHtmlFile"/>

      <echo message="in createRepositoryMetadata, building ${archive.name}@{file.extension}.metadata.zip to @{outputDir}"/>
      <tempfile property="tempPropsFile" deleteonexit="true"/>
      <tempfile property="tempHtmlFile" deleteonexit="true"/>

      <local name="final.name"/>
      <local name="final.shortDescription"/>
      <iff>
        <equals arg1="@{building.withjava}" arg2="false"/>
        <then>
          <property name="final.name" value="${repo.name}"/>
          <property name="final.shortDescription" value="${repo.shortDescription}"/>
        </then>
        <else>
          <property name="final.name" value="${repo.withjava.name}"/>
          <property name="final.shortDescription" value="${repo.withjava.shortDescription}"/>
        </else>
      </iff>

      <propertyfile file="${tempPropsFile}">
        <entry key="name" value="${final.name}"/>
        <entry key="shortDescription" value="${final.shortDescription}"/>
        <entry key="downloadURL" value="@{repo.downloadURL}"/>
        <entry key="provideFeature" value="@{provide.feature}"/>
        <entry key="genericRequirements" value="@{generic.requirements}"/>
        <entry key="packagedJava" value="@{packaged.java}"/>
        <entry key="licenseType" value="${license.type}"/>
        <entry key="webDisplayPolicy" value="@{web.display.policy}"/>
      </propertyfile>
      <copy file="@{descriptionFile}" tofile="${tempHtmlFile}">
        <filterset>
          <filter token="ARCHIVE_NAME" value="${archive.name}"/>
          <filter token="VERSION" value="@{edition.version}"/>
          <filter token="PRODUCT_OWNER" value="${com.ibm.websphere.productOwner}"/>
          <filter token="PRODUCT_NAME" value="${com.ibm.websphere.productName}"/>
        </filterset>
      </copy>
      <zip destfile="@{outputDir}/${archive.name}@{file.extension}.metadata.zip">
        <zipfileset file="${tempPropsFile}" fullpath="assetInfo.properties"/>
        <zipfileset dir="@{lafiles}" prefix="lafiles">
          <!-- Website only want the combined file, e.g. en.html -->
          <exclude name="LA_*"/>
          <exclude name="LI_*"/>
        </zipfileset>
        <zipfileset file="${tempHtmlFile}" fullpath="description.html"/>
      </zip>

      <echo message="created metadata ${liberty.image.output.upload.dir}/${archive.name}.metadata.zip"/>
    </sequential>
  </macrodef>

  <!-- 
  This creates the repository metadata zip for a single asset representing all the zips
  with java. As the asset has no associated binary, it needs to live in the 'externals'
  folder of the repository.
  -->
  <macrodef name="createZipWithJavaRepoMetadata">
    <attribute name="descriptionFile" />
    <attribute name="lafiles" />
    <attribute name="outputDir" />
    <attribute name="provide.feature" />
    <attribute name="edition.version" default="${edition.version}" />
    <sequential>

      <local name="tempPropsFile"/>
      <local name="tempHtmlFile"/>
      <tempfile property="tempPropsFile" deleteonexit="true" />
      <tempfile property="tempHtmlFile" deleteonexit="true" />

      <!-- Do a bit of property name munging to a form required for the metadata zip -->
      <local name="repo.url.version"/>
      <local name="repo.edition.name"/>
      <script language="javascript">
        <![CDATA[
        var url_version;
        var repo_edition_name = project.getProperty("product.edition");
        if (repo_edition_name == 'EARLY_ACCESS') {
          url_version = 'beta';
        } else {
          url_version = project.getProperty("edition.version");
          // This should be 8.5.5.7 or similar. Need to remove the last digit to get 8.5.5
          url_version = url_version.substring(0, url_version.lastIndexOf("."));
        }
        project.setProperty("repo.url.version", url_version);
        project.setProperty("repo.edition.name", repo_edition_name);
        ]]>
      </script>

      <propertyfile file="${tempPropsFile}">
        <entry key="name" value="${repo.withjava.name}" />
        <entry key="shortDescription" value="${repo.withjava.shortDescription}" />
        <entry key="licenseType" value="${license.type}" />
        <entry key="provideFeature" value="@{provide.feature}" />
        <entry key="displayPolicy" value="HIDDEN" />
        <entry key="assetType" value="INSTALL" />
        <entry key="linkType" value="WEB_PAGE" />
        <!-- this is overriden by the javascript in the web page but it needs to have an initial
        value set here -->
        <entry key="downloadURL" value="http://example.com" />
        <!-- 
        The value generated by the uploaders is based on the file name and isn't helpful,
        needs to get set here, should be "runtimes-webprofile7-ibm-java" or similar
        -->
        <entry key="vanityUrl" value="runtimes-webprofile7-ibm-java" />
        <entry key="productVersion" value="@{edition.version}" />
        <entry key="productEdition" value="${repo.edition.name}" />
        <entry key="productId" value="com.ibm.websphere.appserver" />
      </propertyfile>
      <copy file="@{descriptionFile}" tofile="${tempHtmlFile}">
        <filterset>
          <filter token="ARCHIVE_NAME" value="${archive.name}" />
          <filter token="VERSION" value="@{edition.version}" />
          <filter token="PRODUCT_OWNER" value="${com.ibm.websphere.productOwner}" />
          <filter token="PRODUCT_NAME" value="${com.ibm.websphere.productName}" />
        </filterset>
      </copy>

      <!--
      This replicates logic from RepositoryTask.java, to produce the metadata zip file name. This is
      necessary to ensure the repository upload build can find/delete the assets 
      -->
      <local name="stripped.asset.name"/>
      <script language="javascript">
        <![CDATA[
          var before = project.getProperty("repo.withjava.name");
          project.setProperty("stripped.asset.name", before.replaceAll("[^\\w.-]", ""));
            ]]>
      </script>

      <local name="repo.metadata.output.zip"/>
      <property name="repo.metadata.output.zip" value="@{outputDir}/${stripped.asset.name}.metadata.zip"/>
      <zip destfile="${repo.metadata.output.zip}">
        <zipfileset file="${tempPropsFile}" fullpath="assetInfo.properties" />
        <zipfileset dir="@{lafiles}" prefix="lafiles">
          <!-- Website only want the combined file, e.g. en.html -->
          <exclude name="LA_*" />
          <exclude name="LI_*" />
        </zipfileset>
        <zipfileset file="${tempHtmlFile}" fullpath="description.html" />
      </zip>

      <echo message="created java zip metadata ${repo.metadata.output.zip}" />

    </sequential>
  </macrodef>


  <macrodef name="createInstaller">
    <attribute name="edition" />
    <attribute name="archive" />
    <attribute name="signed.config" default="false" />
    <attribute name="properties" />
  	<attribute name="runtime.type" default="runtime" />
    <sequential>
      <!-- local and load the edition properties to use them only for this one call.
           This cannot be moved to its own macro because the scope of the properties is lost. -->
      <local name="product.edition" />
      <local name="license.type" />
      <local name="archive.name" />
      <local name="base.archive.name" />
      <local name="add.to.download.xml" />
      <local name="build.always" />
      <local name="extra.package.options"/>
      <local name="build.repo.metadata"/>
      <local name="repo.name"/>
      <local name="repo.shortDescription"/>
      <local name="repo.downloadURL"/>
      <local name="edition.version"/>
      <local name="display.edition.version"/>
      <local name="dhe.license.path"/>
      <local name="build.web.license"/>
      <local name="files.to.strip"/>
      <!-- Try to figure out the archive name, this is also used in the properties files themself to build
             up install instructions for the repository metadata. However, the properties file might also set
             the archive.name and part of the archive.name is the edition.version that is always set in the
             properties file!  Therefore do as much as we can now and create a base.archive.name, if the 
             properties file want to reference the file name it will be 
             ${base.archive.name}-${edition.version}.jar and if they override the archive.name property they
             can just use the value they set.
             One key point - this property must always be set prior to loading the properties file! -->
      <property name="base.archive.name" value="${install.name}-@{edition}-@{archive}" />
      <property file="@{properties}" />

      <echo message="createInstaller: build.repo.metadata=${build.repo.metadata} runtime.type=@{runtime.type}"/>

      <!-- Set the archive name if it hasn't been set in the edition specific properties -->
      <iff>
        <equals arg1="@{runtime.type}" arg2="runtime" />
        <then>
           <property name="archive.name" value="${base.archive.name}-${edition.version}" />
        </then>
        <else>
            <property name="archive.name" value="${install.name}-@{edition}-@{runtime.type}-${edition.version}" />
        </else>
      </iff>
      <local name="archive.zip.full.path"/>
      <property name="archive.zip.full.path" value="${basedir}/build/tmp/${archive.name}.zip"/>

      <!-- Default display.edition.version if it wasn't set in the properties -->
      <property name="display.edition.version" value="${edition.version}" />

      <!-- We only build if the edition build properties file says it always builds, or 
             the build is building all the images -->
      <iff>
        <or>
          <equals arg1="${create.im.repo}" arg2="true"/>
          <equals arg1="${build.license.zip}" arg2="true"/>
          <equals arg1="${build.always}" arg2="true" />
        </or>
        <then>
          <property name="built.image" value="true"/>
          <!-- Create a server.xml that points to this edition so we can create the runtime archive with
                 the right content -->
          <iff>
            <equals arg1="@{runtime.type}" arg2="all" />
            <then>
              <echo file="${build.dir}/servers/image/server.xml">
      &lt;server&gt;
      &lt;include location="${editions.@{edition}}/all.xml" /&gt;
      &lt;/server&gt;
              </echo>
            </then>
            <else>
              <iff>
                <equals arg1="@{runtime.type}" arg2="kernel" />
                <then>
                  <echo file="${build.dir}/servers/image/server.xml">
      &lt;server/&gt;
                  </echo>
                </then>
                <else>
                  <echo file="${build.dir}/servers/image/server.xml">
      &lt;server&gt;
      &lt;include location="${editions.@{edition}}/runtime.xml" /&gt;
      &lt;/server&gt;
                  </echo>
                </else>
              </iff>
            </else>
          </iff>

          <echo message="Building installer ${archive.name}.jar" />
          <copyVersionSpecificFiles/>

          <!-- generateChecksums can run now that the version specific files are in place. -->
          <echo message="Generating checksums"/>
          <generateChecksums installRoot="${install.name}" ignoreBinFiles="true"/>

          <mkdir dir="build/tmp"/>

          <!-- If we are building a fix pack then we may need to generate an fxtag -->
          <iff>
            <not>
              <equals arg1="0" arg2="${liberty.fixpack}"/>
            </not>
            <then>
              <echo message="Generating fxtag"/>
              <delete dir="build/fxtag" failonerror="false"/>
              <mkdir dir="build/fxtag"/>

              <copy todir="build/fxtag" failonerror="false">
                <fileset dir="editions/@{edition}/tags/fx">
                  <include name="*"/>
                </fileset>
                <mapper>
                  <mapper type="regexp"
                            from="(ibm.com_WebSphere_Application_Server_Liberty*.*)-(\d+.\d+.\d+.\d+).swidtag"
                            to="\1-${edition.version}.swidtag"/>
                </mapper>
                <filterset begintoken="${" endtoken="}">
                  <filter token="edition.version" value="${edition.version}"/>
                  <filter token="buildLabel" value="${buildLabel}"/>
                </filterset>
              </copy>
            </then>
          </iff>

          <!-- Get a server zip that contains what we need -->
          <packageServer server="image"
                           archive="${archive.zip.full.path}" 
                           user.dir="${build.dir}"
                           output.dir="${build.dir}/archives"/>

          <local name="la.header" />
          <local name="li.header" />

          <condition property="la.header" value="License-Agreement: wlp/lafiles/LA" else="">
            <available file="editions/@{edition}/@{archive}/lafiles/" />
          </condition>
          <condition property="li.header" value="License-Information: wlp/lafiles/LI" else="">
            <available file="editions/@{edition}/@{archive}/lafiles/" />
          </condition>

          <!-- generate a bnd file to create the install jar -->
          <echo file="${basedir}/build-install-@{edition}.bnd">
-include= ~build-install.bnd
edition=@{edition}
archive=@{archive}
${la.header}
${li.header}
          </echo>

          <unzip src="${archive.zip.full.path}" dest="${basedir}/build/tmp/"/>

          <!-- if the edition is beta or bluemix validate for any new/unapproved opensource packages -->
          <validateOpenSource archive.name = "${archive.zip.full.path}" tempDir="${basedir}/build/tmp"/>

          <!-- We don't want the usr dir, or the package file from the lib versions folder so we remove them -->
          <delete includeemptydirs="true">
            <fileset dir="${basedir}/build/tmp/wlp/" includes="usr/**/*"/>
            <fileset dir="${basedir}/build/tmp/wlp/lib/versions" includes="package*"/>
          </delete>

          <!-- Is this still needed? The image.common/empty-dirs suggests not, but not sure how that works -->
          <mkdir dir="build/tmp/wlp/usr/servers"/>
          <mkdir dir="build/tmp/wlp/usr/shared/apps"/>
          <mkdir dir="build/tmp/wlp/usr/shared/config"/>
          <mkdir dir="build/tmp/wlp/usr/shared/resources"/>

          <!-- if signed.config is true we do some special stuff -->
          <iff>
            <equals arg1="@{signed.config}" arg2="true" />
            <then>
              <!-- replace the standard config extension jar with a special embedders version of the
                     jar that prevents the server from starting if its server.xml is not signed -->
              <jar jarfile="${basedir}/build/tmp/wlp/lib/com.ibm.ws.config.ext_1.0.${micro.version}_embedded.jar" filesetmanifest="merge">
                <zipfileset src="${basedir}/build/tmp/wlp/lib/com.ibm.ws.config.ext_1.0.${micro.version}.jar" excludes="**/ConfigExtension.class" />
              </jar>
              <delete>
                <fileset dir="${basedir}/build/tmp" includes="wlp/lib/com.ibm.ws.config.ext_1.0.${micro.version}.jar"/>
              </delete>
            </then>
          </iff>

          <iff>
            <available file="${liberty.dir}/CHANGES.TXT" />
            <then>
              <copy file="${liberty.dir}/CHANGES.TXT" todir="${basedir}/build/tmp/wlp"/>
            </then>
          </iff>

          <iff>
            <equals arg1="@{runtime.type}" arg2="all" />
            <then>
              <!-- copy the allTemplate edition template -->
              <copy file="${basedir}/resources/allEdition/templates/servers/defaultServer/server.xml" overwrite="true" todir="${basedir}/build/tmp/wlp/templates/servers/defaultServer"/>
            </then>
          </iff>

          <!-- Deleting unwanted files -->
          <iff>
            <isset property="files.to.strip" />
            <then>
              <delete  includeemptydirs="true" failonerror="false">
                <fileset dir="${basedir}/build/tmp/wlp" includes="${files.to.strip}"/>
              </delete>
            </then>
          </iff>

          <listCoreAndExtendedFeatures minifyZipLocation="${archive.zip.full.path}">
            <fileset dir="${basedir}/build/tmp/wlp/lib/features" includes="*.mf"/>
          </listCoreAndExtendedFeatures>

          <!-- We run bnd to get the archive -->
          <bnd eclipse="false"
                 failok="false"
                 exceptions="true"
                 classpath="${pcp}"
                 output="${liberty.image.output.upload.dir}/${archive.name}.jar"
                 files="${basedir}/build-install-@{edition}.bnd" />

          <!-- tidy up by deleting working files -->
          <delete dir="build/tmp/wlp"/>
          <delete file="build-install-@{edition}.bnd"/>
          <delete file="${archive.zip.full.path}"/>

          <echo file="build/@{edition}/generatedArchives.properties">archives=${archive.name}.jar</echo>

          <!-- If the edition should be added to the download.xml make sure we add it -->
          <iff>
            <istrue value="${add.to.download.xml}" />
            <then>
              <!-- Add the info to the download XML.  If no download XML attirbute is supplied this is a no-op -->
              <local name="archive.size"/>
              <length file="${liberty.image.output.upload.dir}/${archive.name}.jar" property="archive.size"/>
              <createDownloadXml downloadXmlFile="${download.xml.output.file}" 
                                   licenseType="${license.type}" 
                                   name="${repo.name}"
                                   licenses="${dhe.license.path}"
                                   filePath="/wlp/${display.edition.version}/${archive.name}.jar"
                                   archiveSize="${archive.size}"
                                   productId="${com.ibm.websphere.productId}"
                                   productEdition="@{edition}"
                                   productVersion="${edition.version}"
                                   type="install"
                                   installType="Archive"/>
            </then>
          </iff>
          <echo message="Product ${archive.name}.jar created successfully." />
          <iff>
            <istrue value="${build.repo.metadata}"/>
            <then>
              <echo message="build product metadata ${archive.name}.zip"/>

              <!-- Put this file into the output directory for this version of the repo -->
              <mkdir dir="${dhe.repo.build.basedir}/${display.edition.version}/${dhe.repo.root.path}/wlp/${display.edition.version}"/>

              <createRepositoryMetadata lafiles="editions/@{edition}/@{archive}/lafiles_html/" outputDir="${dhe.repo.build.basedir}/${display.edition.version}/${dhe.repo.root.path}/wlp/${display.edition.version}" descriptionFile="editions/@{edition}/@{archive}.description.html" repo.downloadURL="${repo.downloadURL}"/>

              <createJsonMacro assetFile="${liberty.image.output.upload.dir}/${archive.name}.jar"
                                         metadataFile="${dhe.repo.build.basedir}/${display.edition.version}${dhe.repo.root.path}/wlp/${display.edition.version}/${archive.name}.jar.metadata.zip"
                                         assetType="INSTALL" 
                                         outputDir="${dhe.repo.build.basedir}/${display.edition.version}${dhe.repo.root.path}/wlp/${display.edition.version}"/>

              <!-- This is something for the repo so make sure it gets included in the repo ZIP -->
              <copy todir="${dhe.repo.build.basedir}/${display.edition.version}/${dhe.repo.root.path}/wlp/${display.edition.version}" file="${liberty.image.output.upload.dir}/${archive.name}.jar"/>
              <iff>
                <istrue value="${add.to.download.xml}" />
                <then>
                  <!-- This is going to be used by the tools so also copy in the lafiles -->
                  <copy todir="${dhe.repo.build.basedir}/${display.edition.version}/${dhe.repo.root.path}${dhe.license.path}">
                    <fileset dir="editions/@{edition}/@{archive}/lafiles_html/">
                      <!-- Tools only want the combined file, e.g. en.html -->
                      <exclude name="LA_*"/>
                      <exclude name="LI_*"/>
                    </fileset>
                  </copy>
                </then>
              </iff>
            </then>
          </iff>

          <iff>
            <istrue value="${build.web.license}"/>
            <then>
              <local name="license.type.lowercase"/>
              <local name="product.edition.lowercase"/>

              <script language="javascript">
                var licenseType = project.getProperty('license.type')
                project.setProperty('license.type.lowercase', licenseType.toLowerCase())
                
                var productEdition = project.getProperty('product.edition')
                project.setProperty('product.edition.lowercase', productEdition.toLowerCase())
              </script>

              <copy todir="${dhe.repo.build.basedir}/${display.edition.version}/wasdev/license/${product.edition.lowercase}/${license.type.lowercase}/${edition.version}/lafiles">
                <fileset dir="editions/@{edition}/@{archive}/lafiles_html/"/>
              </copy>
            </then>
          </iff>

        </then>
        <else>
          <echo message="Skipping the build of ${archive.name}.jar" />
        </else>
      </iff>
    </sequential>
  </macrodef>

  <!-- 162351 Create JSON for a repository asset and store it in the build output -->
  <macrodef name="createJsonMacro">
    <attribute name="assetFile" />
    <attribute name="metadataFile" default="null"/>
    <attribute name="assetType" />
    <attribute name="outputDir" default = "null"/>

    <sequential>
      <echo message="in createJsonMacro"/>

      <!-- only produce JSON from a build with build.license.zip=true (e.g. the release build) -->
      <iff>
        <istrue value="${build.license.zip}"/>
        <then>

          <!-- we will only produce JSON from a Java 7+ build as the code uses Java7 java.nio.* classes
               and there is no requirement to produce this JSON from an earlier level of Java build -->
          <condition property="isJdk6" value="true">
            <matches pattern="1\.6.*" string="${java.version}"/>
          </condition>
          <iff>
            <isfalse value="${isJdk6}"/>
            <then>

              <!-- set classpath once -->
              <iff>
                <not>
                  <typefound name="createJsonFromAsset"/>
                </not>
                <then>

                  <path id="jsonParserClassPath">
                    <pathelement path="../ant_build/lib/repositoryUploadUtilities.jar" />
                    <pathelement path="../com.ibm.ws.org.glassfish.json/lib/javax.json-1.0.4.jar" />
                    <fileset dir="../com.ibm.ws.org.apache.aries.util/lib" includes="org.apache.aries.util*.jar"/>
                    <pathelement path="../com.ibm.websphere.org.osgi.core/lib/org.osgi.core-6.0.0.jar" />
                  </path>

                  <taskdef name="createJsonFromAsset" classname="com.ibm.ws.repository.parsers.internal.CreateJsonRepositoryFiles" 
                      classpathref="jsonParserClassPath"/>

                </then>
              </iff>

              <!-- then call class to run the appropriate parser to produce the JSON -->
              <createJsonFromAsset assetFile="@{assetFile}" metadataFile="@{metadataFile}" assetType="@{assetType}" outputLocation="@{outputDir}"/>
            </then>
          </iff>
        </then>
      </iff>
    </sequential>
  </macrodef>


  <macrodef name="createEmbeddableZip">
    <attribute name="edition"/>
    <attribute name="properties"/>
    <sequential>
      <iff>
        <and>
          <available file="build/@{edition}/generatedArchives.properties" />
          <available file="editions/@{edition}/embeddable.properties" />
        </and>
        <then>
          <local name="archives" />
          <local name="build.embeddable" />
          <local name="extra.archives" />
          <local name="archive.name" />
          <local name="delete.source" />
          <local name="files.to.strip"/>
          <property file="build/@{edition}/generatedArchives.properties" />
          <property file="editions/@{edition}/embeddable.properties" />

          <iff>
            <equals arg1="${build.embeddable}" arg2="true" />
            <then>
              <delete dir="${file.local.dir}/extract_dest"/>
              <foreach param="archive" in="${archives},${extra.archives}">
                <iff>
                  <not>
                    <contains string="${archive}" substring="${"/>
                  </not>
                  <then>
                    <echo message="Installing archive ${archive} "/>
                    <java jar="${liberty.image.output.upload.dir}/${archive}" fork="true" failonerror="true">
                      <arg value="-acceptLicense"/>
                      <arg value="${file.local.dir}/extract_dest/"/>
                    </java>
                    <iff>
                      <!-- delete if delete source is true and the archive is the runtime one -->
                      <and>
                        <istrue value="${delete.source}"/>
                        <contains string="${archive}" substring="-runtime-"/>
                      </and>
                      <then>
                        <delete file="${liberty.image.output.upload.dir}/${archive}" />
                      </then>
                    </iff>
                  </then>
                </iff>
              </foreach>

              <!-- Copy in any manifests that contain the whole addon content so that we build ESAs for them -->
              <iff>
                <available file="${build.dir}/@{edition}/esaManifests" />
                <then>
                  <copy todir="${file.local.dir}/extract_dest/wlp/lib/features">
                    <fileset dir="${build.dir}/@{edition}/esaManifests"/>
                  </copy>
                </then>
              </iff>

              <iff>
                <available file="${liberty.dir}/CHANGES.TXT" />
                <then>
                  <copy file="${liberty.dir}/CHANGES.TXT" todir="${file.local.dir}/extract_dest/wlp"/>
                </then>
              </iff>

              <!-- Deleting unwanted files -->
              <iff>
                <isset property="files.to.strip" />
                <then>
                  <delete includeemptydirs="true" failonerror="false">
                    <fileset dir="${file.local.dir}/extract_dest/wlp" includes="${files.to.strip}"/>
                  </delete>
                </then>
              </iff>

              <echo message="deleting licenses" />
              <delete dir="${file.local.dir}/extract_dest/wlp/lafiles" includes="**" includeemptydirs="true"/>

              <!-- Just kidding, we need licenses for the beta -->
              <iff>
                <equals arg1="@{edition}" arg2="beta"/>
                <then>
                  <copy todir="${file.local.dir}/extract_dest/wlp/lafiles/">
                    <fileset dir="../build.image/editions/beta/runtime/lafiles/"
                             includes="**" />
                  </copy>
                </then>
              </iff>

              <echo message="deleting software tags" />
              <delete dir="${file.local.dir}/extract_dest/wlp/lib/versions/tags" includeemptydirs="true" />

              <!-- Set the archive name if it hasn't been set in the edition specific properties -->
              <property name="archive.name" value="${install.name}-@{edition}-embeddable-${edition.version}" />

              <zip destfile="${liberty.image.output.upload.dir}/${archive.name}.zip" duplicate="preserve">
                <zipfileset dir="${file.local.dir}/extract_dest/wlp/bin" includes="**" excludes="**/*.*" prefix="${install.name}/bin" filemode="754"/>
                <zipfileset dir="${file.local.dir}/extract_dest" includes="**/*"/>
              </zip>
            </then>
          </iff>
        </then>
        <else>
          <echo message="Not building an embeddable zip for edition @{edition}" />
        </else>
      </iff>
    </sequential>
  </macrodef>

  <macrodef name="createEsas">
    <attribute name="wlp.build.dir"/>
    <attribute name="dest.dir"/>
    <attribute name="editions" default=""/>
    <attribute name="wlp.exclude.dir" default=""/>
    <attribute name="download.xml.file" default=""/>
    <attribute name="productFeature" default="true"/>
    <!-- you can set this to add a 'productInstallType=Archive' type directive to the applies to in the ESAS
         from 8554 onwards this is removed for ALL features (see story 141808). -->
    <attribute name="appliesToInstallType" default=""/>
    <attribute name="licenseLocation" default="${basedir}/../image.common/lafiles/featureTerms"/>
    <attribute name="htmlLicenseLocation" default="${basedir}/../image.common/lafiles_html/featureTerms"/>
    <attribute name="licenseType" default="" />
    <attribute name="featureTermsUrl" default="http://www.ibm.com/licenses/wlp-featureterms-v1" />
    <attribute name="generateKnowledgeCentreLinks" default="true" />
    <attribute name="downloadLicenseLocation" default="/wlp/${liberty.service.version}/lafiles/featureTerms/"/>
    <!-- TODO: This may need to be fixed up if we create ESAs for non-service offerings. -->
    <attribute name="edition.version" default="${liberty.service.version}"/>
    <attribute name="download.dir" default="@{edition.version}"/>
    <sequential>

      <iff>
        <equals arg1="@{wlp.exclude.dir}" arg2=""/>
        <then>
          <!-- No filtering required -->
          <fileset id="manifestFiles" dir="@{wlp.build.dir}" includes="**/features/*.mf"/>
        </then>
        <else>
          <!-- Don't include the excluded manifests -->
          <fileset id="manifestFiles" dir="@{wlp.build.dir}" includes="**/features/*.mf">
            <present present="srconly" targetdir="@{wlp.exclude.dir}"/>
          </fileset>
        </else>
      </iff>

      <generateEsas version="@{edition.version}" 
                    licenseLocation="@{licenseLocation}"
                htmlLicenseLocation="@{htmlLicenseLocation}" 
                  outputDirLocation="@{dest.dir}" 
                  editions="@{editions}" 
                  downloadXmlFile="@{download.xml.file}" 
                  downloadLocation="/wlp/@{download.dir}/" 
                  downloadLicenseLocation="@{downloadLicenseLocation}" 
                  productFeature="@{productFeature}" 
            generateKnowledgeCentreLinks="@{generateKnowledgeCentreLinks}" 
                 appliesToInstallType="@{appliesToInstallType}"
                    featureTermsUrl="@{featureTermsUrl}"
                  licenseType="@{licenseType}">
        <fileset refid="manifestFiles"/>
      </generateEsas>
    </sequential>
  </macrodef>

  <!-- Macro to create the profile zip.
       Required input properties:
       profile - The name of the profile to package. This is the name of a directory in profiles/*
       jvm.prop.dir - The Java properties directory, used when packaging the profiles which include a JVM
       
       The following properties come from the build definition:
       build.profile.zip.with.java - indicates that the profile should be packaged with Java (when applicable)
       
       The following local properties are computed within this macro scope:
       default.package.name
       package.name
       
       The following local properties come from the profile.properties file for each profile:
       display.edition.version (optional)
       edition.version
       license.type
       product.edition
       repo.name
       repo.shortDescription
       repo.withjava.shortDescription (optional)
       repo.withjava.name (optional)
       -->
  <macrodef name="createProfileZip">
    <attribute name="profile" />
    <attribute name="jvm.prop.dir" />
    <sequential>
      <!-- Local, computed within scope -->
      <local name="default.package.name" />
      <local name="package.name" />
      <!-- Local, set from profile.properties -->
      <local name="display.edition.version"/>
      <local name="edition.version"/>
      <local name="license.type"/>
      <local name="product.edition" />
      <local name="repo.name"/>
      <local name="repo.shortDescription"/>
      <local name="repo.withjava.shortDescription" />
      <local name="repo.withjava.name" />

      <echo>Creating the profile zip for @{profile}</echo>

      <!-- Read properties file -->
      <property file="profiles/@{profile}/metadata/profile.properties" />

      <!-- Construct the archive package name -->
      <property name="default.package.name" value="${install.name}-@{profile}" />
      <property name="package.name" value="${default.package.name}-${edition.version}" />

      <!-- Default display.edition.version if it wasn't set in the properties -->
      <property name="display.edition.version" value="${edition.version}" />

      <!-- Create temporary working space within the build directory -->
      <property name="create.profile.zip.tmp" value="${basedir}/build/tmp/create.profile.zip"/>
      <delete dir="${create.profile.zip.tmp}"/>
      <mkdir dir="${create.profile.zip.tmp}"/>

      <!-- Create a server.xml that points to this profile so we can create the archive with
           the right content -->
      <echo file="${build.dir}/servers/image/server.xml">
    &lt;server&gt;
      &lt;include location="${profiles.@{profile}}/server.xml" /&gt;
    &lt;/server&gt;
      </echo>

      <!-- Get a server zip that contains everything that would be installed once this addon was installed -->
      <echo message="Building archive ${package.name}.zip" />
      <copyVersionSpecificFiles/>

      <!-- generateChecksums can run now that the version specific files are in place. -->
      <echo message="Generating checksums"/>
      <generateChecksums installRoot="${install.name}" ignoreBinFiles="true"/>

      <!-- This can not run for beta-zos packaging because it includes all Liberty Features.
           It may be that future profiles will also need to package these EE6 features but
           until then this is just conditional on the specific profile name. -->
      <iff>
        <not>
            <equals arg1="@{profile}" arg2="beta-zos" />
        </not>
        <then>
          <!-- Create temp directory and copy over ee-6 feature manifests so that they are not packaged -->
          <property name="ee6tmp" value="${create.profile.zip.tmp}/ee6tmp"/>
          <delete dir="${ee6tmp}" />
          <mkdir dir="${ee6tmp}"/>
          <move file="${install.name}/lib/features/com.ibm.websphere.appserver.servlet-3.0.mf" todir="${ee6tmp}" failonerror="${require.all.content}" />
          <move file="${install.name}/lib/features/com.ibm.websphere.appserver.jsp-2.2.mf" todir="${ee6tmp}" failonerror="${require.all.content}" />
          <move file="${install.name}/lib/features/com.ibm.websphere.appserver.jaxrs-1.1.mf" todir="${ee6tmp}" failonerror="${require.all.content}"/>
          <move file="${install.name}/lib/features/com.ibm.websphere.appserver.jdbc-4.0.mf" todir="${ee6tmp}" failonerror="${require.all.content}"/>
          <move file="${install.name}/lib/features/com.ibm.websphere.appserver.jca-1.6.mf" todir="${ee6tmp}" failonerror="${require.all.content}"/>
          <!-- Exclude internal.jaxrs-1.1 for 231109 (force restConnector-1.0 to resolve with EE7 features) -->
          <move file="${install.name}/lib/features/com.ibm.websphere.appserver.internal.jaxrs-1.1.mf" todir="${ee6tmp}" failonerror="${require.all.content}" />
        </then>
      </iff>

      <!-- Had to duplicate packageServer function because removing ee-6 features cause tests in there to fail -->
      <packageServer server="image"
                     archive="${create.profile.zip.tmp}/${package.name}.zip" 
                     user.dir="${build.dir}"
                     output.dir="${build.dir}/test"/>

      <!-- Move back ee-6 feature manifests back to the install image if we moved them -->
      <iff>
        <not>
          <or>
            <equals arg1="@{profile}" arg2="beta-zos" />
          </or>
        </not>
        <then>
          <move todir="${install.name}/lib/features" >
          <fileset dir="${ee6tmp}">
            <include name="**/*" />
          </fileset>
        </move>
        <delete dir="${ee6tmp}" />
        </then>
      </iff>

      <!-- If the packaging step failed earlier, report the failure.
           This must be done after the moving of ee6 features or we leave
           the system in a bad state -->
      <fail if="halt.on.packaging.failure"
            message="Creating archive failed while running locally.${line.separator}See the previous log messages for what happened."/>

      <!-- Replace with appropriate archive name -->
      <unzip src="${create.profile.zip.tmp}/${package.name}.zip" dest="${create.profile.zip.tmp}/"/>

      <!-- We don't want the usr dir, or the package file from the lib versions folder so we remove them -->
      <delete includeemptydirs="true">
        <fileset dir="${create.profile.zip.tmp}/wlp/" includes="usr/**/*"/>
        <fileset dir="${create.profile.zip.tmp}/wlp/lib/versions" includes="package*"/>
      </delete>

      <!-- Create usr file structure -->
      <mkdir dir="${create.profile.zip.tmp}/wlp/usr/servers"/>
      <mkdir dir="${create.profile.zip.tmp}/wlp/usr/shared/apps"/>
      <mkdir dir="${create.profile.zip.tmp}/wlp/usr/shared/config"/>
      <mkdir dir="${create.profile.zip.tmp}/wlp/usr/shared/resources"/>

      <!-- Create the tags directory required by ILMT (used for auditing and license management) -->
      <mkdir dir="${create.profile.zip.tmp}/wlp/lib/versions/tags"/>

      <!-- Generate a temporary bnd file to pass variables into the bdn packaging step
           The key variable passed is license.type, as this is used for packaging the
           correct license files into the final zip. It is referenced in the Include-Resource
           stanza of build-profile-install.bnd -->
      <echo file="${basedir}/build-profile-install-@{profile}.bnd">
    -include= ~build-profile-install.bnd
    license.type=${license.type}
      </echo>

      <local name="second.zip"/>
      <property name="second.zip" value="${create.profile.zip.tmp}/${package.name}_second.zip"/>
      <!-- We run bnd to get the archive -->
      <bnd eclipse="false"
           failok="false"
           exceptions="true"
           classpath="${pcp}"
           output="${second.zip}"
           files="${basedir}/build-profile-install-@{profile}.bnd" />

      <mkdir dir="${create.profile.zip.tmp}/tmp_zips" />
      <unzip src="${second.zip}" dest="${create.profile.zip.tmp}/tmp_zips" />

      <move file="${create.profile.zip.tmp}/tmp_zips/META-INF/MANIFEST.MF" todir="${create.profile.zip.tmp}/tmp_zips/wlp/lib/extract/META-INF" />

      <!-- Complete the final package step.
           Certain profiles (javaeeClient7, kernel and microProfile1) don't contain
           restConnector so conditional around what to package.
           These specific profiles are missing  the clients/jython folder -->
      <iff>
        <not>
          <or>
            <equals arg1="@{profile}" arg2="javaeeClient7" />
            <equals arg1="@{profile}" arg2="kernel" />
            <equals arg1="@{profile}" arg2="microProfile1" />
          </or>
        </not>
        <then>
          <zip destfile="${liberty.image.output.upload.dir}/${package.name}.zip" duplicate="preserve">
            <zipfileset dir="${create.profile.zip.tmp}/tmp_zips/wlp/bin" includes="**" excludes="**/*.*" prefix="${install.name}/bin" filemode="754"/>
            <zipfileset dir="${create.profile.zip.tmp}/tmp_zips/wlp/lib/native/os400/bin" includes="**" prefix="${install.name}/lib/native/os400/bin" filemode="754" erroronmissingdir="${require.all.content}"/>
            <zipfileset file="${create.profile.zip.tmp}/tmp_zips/wlp/clients/jython/restConnector.py" prefix="${install.name}/clients/jython" filemode="754"  erroronmissingdir="${require.all.content}"/>
            <zipfileset file="${basedir}/profiles/@{profile}/templates/servers/defaultServer/server.xml" prefix="${install.name}/templates/servers/defaultServer" erroronmissingdir="${require.all.content}"/>
            <zipfileset dir="${create.profile.zip.tmp}/tmp_zips/wlp" includes="**/*" prefix="${install.name}"/>
          </zip>
        </then>
        <else>
          <zip destfile="${liberty.image.output.upload.dir}/${package.name}.zip" duplicate="preserve">
            <zipfileset dir="${create.profile.zip.tmp}/tmp_zips/wlp/bin" includes="**" excludes="**/*.*" prefix="${install.name}/bin" filemode="754" />
            <zipfileset dir="${create.profile.zip.tmp}/tmp_zips/wlp/lib/native/os400/bin" includes="**" prefix="${install.name}/lib/native/os400/bin" filemode="754" erroronmissingdir="${require.all.content}"/>
            <zipfileset file="${basedir}/profiles/@{profile}/templates/servers/defaultServer/server.xml" prefix="${install.name}/templates/servers/defaultServer" erroronmissingdir="${require.all.content}"/>
            <zipfileset dir="${create.profile.zip.tmp}/tmp_zips/wlp" includes="**/*" prefix="${install.name}"/>
          </zip>
        </else>
      </iff>
      <!-- This completes the normal packaging step. -->

      <!-- Next, perform additional packaging, including creating the
           repostiory metadata and profiles which include Java images. -->

      <!-- Build the repository metadata if a profile.description.html file exists -->
      <iff>
        <available file="profiles/@{profile}/metadata/profile.description.html" />
        <then>
          <echo message="Building repository metadata ${package.name}.zip"/>
          <!-- Put the repo metadata into the output directory for this version of the repo -->
          <local name="dhe.repo.edition.dir" />
          <property name="dhe.repo.edition.dir" value="${dhe.repo.build.basedir}/${display.edition.version}/${dhe.repo.root.path}/wlp/${display.edition.version}" />
          <mkdir dir="${dhe.repo.edition.dir}" />
          <copy todir="${dhe.repo.edition.dir}" file="${liberty.image.output.upload.dir}/${package.name}.zip" />

          <!-- Work out the provide feature, this used to go into the manifest header but we don't have
               a manifest for the ZIP packaging-->
          <local name="require.feature" />
          <local name="provide.feature" />
          <listCoreAndExtendedFeatures minifyZipLocation="${liberty.image.output.upload.dir}/${package.name}.zip">
            <fileset dir="${create.profile.zip.tmp}/wlp/lib/features" includes="*.mf" />
          </listCoreAndExtendedFeatures>

          <local name="archive.name"/>
          <property name="archive.name" value="${package.name}"/>
          <createRepositoryMetadata lafiles="licenses/${license.type}/lafiles_html/"
                                    outputDir="${dhe.repo.edition.dir}" 
                                    descriptionFile="profiles/@{profile}/metadata/profile.description.html" 
                                    file.extension=".zip"
                                    provide.feature="${provide.feature}"/>
        </then>
        <else>
            <echo message="Skipping repository metadata build for @{profile} because there is no profiles/@{profile}/metadata/profile.description.html file."/>
        </else>
      </iff>

      <!-- Build a profile zip which includes Java if a profile_with_java.description.html file exists -->
      <iff>
        <and>
          <available file="profiles/@{profile}/metadata/profile_with_java.description.html" />
          <available file="profiles/@{profile}/metadata/profile_with_java.short_description.html" />
          <equals arg1="${build.profile.zip.with.java}" arg2="true" />
        </and>
        <then>
          <!-- Read JVM level mapping -->
          <property file="profiles/jvmLevelNameMapping.properties"/>

          <!-- Create java.env -->
          <property name ="jvm.text" value="WLP_DEFAULT_JAVA_HOME=@WLP_INSTALL_DIR@/java/java" />
          <mkdir dir="${liberty.image.output.upload.dir}/java" />
          <touch file="${liberty.image.output.upload.dir}/java/java.env" />
          <echo message="${jvm.text}" file="${liberty.image.output.upload.dir}/java/java.env" />

          <fileset id="jvmLevels" dir="${build.dir}/jvmlevel" includes="*.zip" />
          <foreach param="targetJvmLevel" in="jvmLevels">
            <echo message="Creating @{profile} archive with JVM: ${targetJvmLevel}"/>
            <local name="jvmLevelName" />
            <local name="trimmedJvmLevelName" />
            <local name="mappedJvmLevelName" />

            <basename property="jvmLevelName" file="${targetJvmLevel}" suffix=".zip" />

            <!-- Replace spaces with dots in the JVM level file names since Ant doesn't like to see spaces in property names-->
            <loadresource property="trimmedJvmLevelName">
              <propertyresource name="jvmLevelName"/>
              <filterchain>
                <tokenfilter>
                  <replacestring from=" " to="."/>
                </tokenfilter>
              </filterchain>
            </loadresource>

            <!-- Plugging in the value of trimmedJvmLevelName in order to get a
                 property name and then getting the value of that property name -->
            <propertycopy name="mappedJvmLevelName" from="${trimmedJvmLevelName}" />

            <local name="archive.name" />
            <property name="archive.name" value="${default.package.name}-${mappedJvmLevelName}-${edition.version}" />

            <!-- Merge the the package, JDK and the java.env -->
            <local name="profile.zip.dest.file" />
            <property name="profile.zip.dest.file" value="${liberty.image.output.upload.dir}/${archive.name}.zip" />
            <zip destfile="${profile.zip.dest.file}">
              <zipgroupfileset dir="${liberty.image.output.upload.dir}" includes="${package.name}.zip"/>
              <zipfileset src="${targetJvmLevel}" prefix="wlp"/>
              <zipfileset file="${liberty.image.output.upload.dir}/java/java.env" prefix="wlp/java"/>
            </zip>

            <!-- Put this file into the output directory for this version of the repo -->
            <copy todir="${dhe.repo.edition.dir}" file="${profile.zip.dest.file}" />

            <!-- Create the metadata zip for each profile zip with java. Not visible on website -->
            <local name="platform.info" />
            <property file="${jvm.prop.dir}/${jvmLevelName}.properties" />
            <createRepositoryMetadata lafiles="licenses/${license.type}/lafiles_html/" 
                                      outputDir="${dhe.repo.edition.dir}" 
                                      descriptionFile="profiles/@{profile}/metadata/profile_with_java.short_description.html"
                                      file.extension=".zip" 
                                      generic.requirements="${platform.info}" 
                                      packaged.java="${mappedJvmLevelName}" 
                                      building.withjava="true" 
                                      web.display.policy="HIDDEN" />
          </foreach>

          <!-- Create the metadata zip for the zips with java. Currently only one asset for all of them -->
          <local name="zip.with.java.output.dir"/>
          <!-- Even though we only build for webProfile7 right now, if we do build profile+java for beta, we'll need this conitional logic -->
          <condition property="zip.with.java.output.dir" 
                     value="${dhe.repo.build.basedir}/${display.edition.version}/${dhe.repo.external.path}/${display.edition.version}/${edition.version}" 
                     else="${dhe.repo.build.basedir}/${display.edition.version}/${dhe.repo.external.path}/${display.edition.version}">
            <equals arg1="${display.edition.version}" arg2="beta"/>
          </condition>
          <createZipWithJavaRepoMetadata lafiles="licenses/${license.type}/lafiles_html/"
                                         provide.feature="${provide.feature}"
                                         outputDir="${zip.with.java.output.dir}"
                                         descriptionFile="profiles/@{profile}/metadata/profile_with_java.description.html" />

          <!-- Clean up -->
          <delete dir="${liberty.image.output.upload.dir}/java" />
        </then>
        <else>
          <echo message="Skipping creation of @{profile} archive with Java because there is no profiles/@{profile}/metadata/metadata/profile_with_java.description.html file, profile_with_java.short_description.html file or ${build.profile.zip.with.java} is not true."/>
        </else>
      </iff>

      <!-- The following two post-create actions are specific to beta-zos, and while they
           may be more common in the future, this is enough to work right now -->
      <iff>
        <equals arg1="@{profile}" arg2="beta-zos" />
        <then>
          <!-- The reason this step is required is because the beta-zos profile is listed
               in the files.to.upload.zos property, and the location that the upload task
               will look for the file is in ${file.local.dir}. These uploads, in turn, are
               expected to be there when building the zOS images (see build-zos-liberty.xml)
               The zOS build will pull these uploaded images down for more zOS specific
               packaging. Additionally, we remove the wlp-beta-zos.zip from the image output
               upload dir because it would be misleading to upload it as an 'installable'
               when it is replaced by the pax version. Its not magic, just convoluted -->
          <echo>Moving the beta-zos profile zip from ${liberty.image.output.upload.dir} to ${file.local.dir}, as the subsequent upload step expects it to be there</echo>
          <move file="${liberty.image.output.upload.dir}/${package.name}.zip"
                todir="${file.local.dir}" />
          
          <!-- Now, we remove the archive from ${dhe.repo.beta.archive.dir} because it will
               be pointless to zip it up in the repo.beta.zip only to have it not be used.
               (As the pax version is what will be used). -->
          <echo>Deleting the beta-zos profile zip from ${dhe.repo.beta.archive.dir}</echo>
          <delete file="${dhe.repo.beta.archive.dir}/${package.name}.zip" />

          <!-- We need to 'rename' the previously built wlp-beta-zos-*.zip.metadata.zip to
               wlp-beta-zos-*.pax.metadata.zip because we'll eventually convert this to a
               pax format as part of the zOS packaging build. -->
          <move file="${dhe.repo.beta.archive.dir}/${package.name}.zip.metadata.zip"
                tofile="${dhe.repo.beta.archive.dir}/${package.name}.pax.metadata.zip" />

          <!-- Lastly, customize the contents of the metadata.zip which are requried for the zOS beta.
               This step will add:
               lafiles_text/*
               wlp/lib/versions/WebSphereApplicationServer.properties
               wlp/lib/versions/WebSphereApplicationServerZOS.properties -->
          <copy file="${basedir}/../com.ibm.zos.native/versions/WebSphereApplicationServerZOS.properties" todir="build/tmp/">
            <filterchain>
              <tokenfilter>
                <replaceregex pattern="version4Z/OS_this_is_changed_in_build-antz-zos-liberty.xml"
                              replace="${liberty.beta.version}" />
              </tokenfilter>
            </filterchain>
          </copy>
          <zip destfile="${dhe.repo.beta.archive.dir}/${package.name}.pax.metadata.zip"
               update="true">
            <zipfileset file="${install.name}/lib/versions/WebSphereApplicationServer.properties" prefix="wlp/lib/versions/" />
            <zipfileset file="build/tmp/WebSphereApplicationServerZOS.properties" prefix="wlp/lib/versions/" />
            <zipfileset dir="licenses/${license.type}/lafiles" prefix="lafiles_text" />
          </zip>

          <delete file="build/tmp/WebSphereApplicationServerZOS.properties" />
        </then>
      </iff>

      <!-- tidy up by deleting working files -->
      <delete dir="${create.profile.zip.tmp}"/>
      <delete file="${basedir}/build-profile-install-@{profile}.bnd"/>
    </sequential>
  </macrodef>

  <macrodef name="createExtrasJarFile">
    <attribute name="license.name"/>
    <attribute name="exclude.license.name" default="false"/>
    <attribute name="edition.version"/>
    <attribute name="build.repo.metadata" default="false"/>
    <sequential>

      <local name="archive.name"/>
      <condition property="archive.name" 
                     value="${install.name}-@{license.name}-extras-@{edition.version}"
                     else="${install.name}-extras-@{edition.version}">
        <equals arg1="@{exclude.license.name}" arg2="false"/>
      </condition>
      <copy file="${basedir}/../com.ibm.ws.jpa/containers/com.ibm.ws.jpa.thinclient_8.5.0.jar" todir="build/tmp/extras"/>
      <copy file="${basedir}/../com.ibm.ws.ejbcontainer/containers/com.ibm.ws.ejb.embeddableContainer_nls_8.5.0.jar" todir="build/tmp/extras"/>

      <echo file="extract-@{license.name}.bnd">
-include= ~build-install-extras.bnd
license.name=@{license.name}
          </echo>

      <bnd eclipse="false"
              failok="false"
              exceptions="true"
              classpath="${pcp}"
              output="${liberty.image.output.upload.dir}/${archive.name}.jar"
              files="extract-@{license.name}.bnd" />

      <iff>
        <istrue value="@{build.repo.metadata}"/>
        <then>
          <echo message="build product metadata ${archive.name}.zip"/>
          <mkdir dir="${dhe.repo.build.basedir}/@{edition.version}/${dhe.repo.root.path}/wlp/@{edition.version}"/>

          <local name="license.type" />
          <local name="repo.name"/>
          <local name="repo.shortDescription"/>
          <local name="repo.downloadURL"/>
          <local name="repo.longDescription"/>
          <property file="extras/@{license.name}.properties" />
          <createRepositoryMetadata lafiles="extras/@{license.name}_html/" outputDir="${dhe.repo.build.basedir}/@{edition.version}/${dhe.repo.root.path}/wlp/@{edition.version}" descriptionFile="extras/@{license.name}.description.html" edition.version="@{edition.version}" repo.downloadURL="${repo.downloadURL}"/>

          <!-- Create the JSON for the extra's jar -->
          <createJsonMacro assetFile="${liberty.image.output.upload.dir}/${archive.name}.jar"
                  metadataFile="${dhe.repo.build.basedir}/@{edition.version}/${dhe.repo.root.path}/wlp/@{edition.version}/${archive.name}.jar.metadata.zip"
                  assetType="TOOL" 
                  outputDir="${dhe.repo.build.basedir}/@{edition.version}/${dhe.repo.root.path}/wlp/@{edition.version}"/>


          <!-- This is something for the repo so make sure it gets included in the repo ZIP -->
          <copy todir="${dhe.repo.build.basedir}/@{edition.version}/${dhe.repo.root.path}/wlp/@{edition.version}" file="${liberty.image.output.upload.dir}/${archive.name}.jar"/>
        </then>
      </iff>

      <delete file="extract-@{license.name}.bnd"/>
    </sequential>
  </macrodef>

  <macrodef name="validateOpenSource">
    <attribute name="archive.name"/>
    <attribute name="tempDir"/>
    <!-- if the edition is beta or bluemix validate for any new/unapproved opensource packages -->
    <sequential>
      <iff>
        <or>
          <equals arg1="${edition}" arg2="beta"/>
          <equals arg1="${edition}" arg2="bluemix"/>
        </or>
        <then>
          <echo message="Validating @{archive.name} for unapproved open source packages..." />
          <mkdir dir="build/reports/"/>
          <local name="ossc.failure" />
          <!-- TO ADD NEW PACKAGES FROM SCAN INCLUDE 'appendPackage="true"' IN THE scanOSS element -->
          <scanOSS allowedPackagesFile="${basedir}/allowedOSSPackages.txt" junitResult="build/reports/${edition}.xml" failureProperty="ossc.failure">
            <fileset dir="@{tempDir}/wlp/lib" includes="**/*.jar"/>
            <fileset dir="@{tempDir}/wlp/dev" includes="**/*.jar" />
          </scanOSS>
          <publishJUnitLog filePath="build/reports/${edition}.xml" isFat="false" />
          <iff>
            <and>
              <istrue value="${ossc.failure}"/>
              <not>
                <isset property="is.running.rtc.build"/>
              </not>
            </and>
            <then>
              <fail message="Error occurred validating features. Please check build/reports/${edition}.xml for details" />
            </then>
            <else>
              <echo message="Validated @{archive.name}. No New/unapproved open source packages found." />
            </else>
          </iff>
        </then>
      </iff>
    </sequential>
  </macrodef>

  <macrodef name="copyVersionSpecificFiles">
    <sequential>
      <!-- Copy the version specific files into place before packaging server -->
      <!-- Ensure that the edition info is correct in properties file. -->
      <mkdir dir="${install.name}/lib/versions"/>
      <copy file="publish/WebSphereApplicationServer.properties" todir="${install.name}/lib/versions" overwrite="true">
        <filterchain>
          <tokenfilter>
            <replaceregex pattern="com.ibm.websphere.productEdition=.*"
                          replace="com.ibm.websphere.productEdition=${product.edition}"/>
            <replaceregex pattern="com.ibm.websphere.productLicenseType=.*"
                          replace="com.ibm.websphere.productLicenseType=${license.type}"/>
            <replaceregex pattern="com.ibm.websphere.productVersion=.*"
                          replace="com.ibm.websphere.productVersion=${edition.version}"/>
          </tokenfilter>
        </filterchain>
      </copy>

      <!-- Ensure that the liberty and build versions are correct in the README file. -->
      <copy file="publish/README.TXT" todir="${install.name}" overwrite="true">
        <filterchain>
          <tokenfilter>
            <replaceregex pattern="\$BUILD_ID\$"
                          replace="${edition.version}-${buildLabel}"/>
            <replaceregex pattern="\$LIBERTY_VERSION\$"
                         replace="${edition.version}"/>
          </tokenfilter>
        </filterchain>
      </copy>
    </sequential>
  </macrodef>

  <macrodef name="createDirectoryRepoZip">
    <attribute name="esazip"/>
    <attribute name="jsonzip"/>
    <attribute name="repodir"/>
    <attribute name="destzip"/>
    <sequential>
      <unzip src="@{esazip}"
             dest="@{repodir}/temp">
        <patternset>
          <include name="**/*.esa"/>
        </patternset>
        <mapper type="flatten"/>
      </unzip>
      <unzip src="@{jsonzip}"
             dest="@{repodir}/temp">
        <patternset>
          <include name="**/*.json"/>
        </patternset>
        <mapper type="flatten"/>
      </unzip>
      <property name="temp" value="@{repodir}/temp/"/>
      <script language="javascript">
        <![CDATA[        
            fs = project.createDataType("fileset");
            dir = temp;
            fs.setDir( new java.io.File( dir ) );
          fs.setIncludes( "**/*.json" );
        
          // create echo Task via Ant API
          echo = project.createTask("echo");
        
        addonset = null;
        noversionaddonset = null;
        featureset = null;
        noversionfeatureset = null;
          
          var assetVersion = "noversion";
        
            // iterate over files found.
            srcFiles = fs.getDirectoryScanner( project ).getIncludedFiles( );
            for ( i = 0; i < srcFiles.length; i++ ) {
                var filename = srcFiles[i];
            //remove .json extension to get the filename of the main attachment
            var filenamepattern = filename.substr(0, filename.length()-5);
                
             var file = new java.io.File(dir + filename);
                fr = new java.io.FileReader(file);
                br = new java.io.BufferedReader(fr);
                
                // Read the file. 
                var typeLine = null;
                var visibilityLine = null;
          var appliesToLine = null;
                var currentline = br.readLine();
            while (currentline != null)
            {
              if (currentline.trim().indexOf('"visibility"') == 0){
                visibilityLine = currentline;
                visibilityLine = "(" + "{" + visibilityLine + "}" + ")";
                    }
              if (currentline.trim().indexOf('"typeLabel"') == 0) {
                typeLine = currentline;
                typeLine = "(" + "{" + typeLine + "}" + ")";
                    }
            if (currentline.trim().indexOf('"appliesTo"') == 0) {
                appliesToLine = currentline;
                appliesToLine = "(" + "{" + appliesToLine + "}" + ")";
                  }
              currentline = br.readLine();
            }
                
            var type = null;
            var visibility = null;
        
              // Evaluate the JSON.
          if (typeLine != null){
              var typeJSON = eval(typeLine);
            type = typeJSON["typeLabel"];
              }

          if (visibilityLine != null){
            var visibilityJSON = eval(visibilityLine);
            visibility = visibilityJSON["visibility"];
              }
        
            if (appliesToLine != null){
              var appliesToJSON = eval(appliesToLine);
              var appliesTo = appliesToJSON["appliesTo"];
            if (appliesTo.indexOf("productVersion") == -1){
              assetVersion = "noversion";
            } else {
      		  var re = /\d+\.\d+\.\d+\.\d+/;
              assetVersion = appliesTo.match(re);
                }
                }
          
          if (type == "Feature"){
            if (visibility == "INSTALL"){
              if (assetVersion == "noversion"){
                if (noversionaddonset == null){
                  noversionaddonset = project.createDataType("fileset");
                  noversionaddonset.setDir(new java.io.File(dir));
                }
                noversionaddonset.appendIncludes(["**/" + filename, "**/" + filenamepattern]);                
              } 
                      else {
                if (addonset == null) {
                  addonset = project.createDataType("fileset");
                  addonset.setDir(new java.io.File(dir));
                        }
                addonset.appendIncludes(["**/" + filename, "**/" + filenamepattern]);
                      }
            }
            else {
              if (assetVersion == "noversion") {
                if (noversionfeatureset == null){
                  noversionfeatureset = project.createDataType("fileset");
                  noversionfeatureset.setDir(new java.io.File(dir)); 
                }
                noversionfeatureset.appendIncludes(["**/" + filename, "**/" + filenamepattern]);
              } 
                      else {
                if (featureset == null){
                  featureset = project.createDataType("fileset");
                  featureset.setDir(new java.io.File(dir));    
                }  
                featureset.appendIncludes(["**/" + filename, "**/" + filenamepattern]);
                      }  
                  }
          }
            }
            
          
        // create echo Task via Ant API
        if (addonset != null){
            moveaddon = project.createTask("copy");
          moveaddon.addFileset(addonset);
          moveaddon.setTodir(new java.io.File(temp + "addons/" + assetVersion + "/"));
          moveaddon.setFlatten(true);
          moveaddon.perform();
        }
      
          if (noversionaddonset != null) {
            moveaddonnoversion = project.createTask("copy");
          moveaddonnoversion.addFileset(noversionaddonset);
          moveaddonnoversion.setTodir(new java.io.File(temp + "addons/" + "noversion" + "/"));
          moveaddonnoversion.setFlatten(true);
          moveaddonnoversion.perform();       
          }

      
        // create echo Task via Ant API
      
          if (featureset != null){
             movefeature = project.createTask("copy");
          movefeature.addFileset(featureset);
          movefeature.setTodir(new java.io.File(temp + "features/" + assetVersion + "/"));
          movefeature.setFlatten(true);
          movefeature.perform();                  
          }
      
        if (noversionfeatureset != null){
             movefeaturenoversion = project.createTask("copy");
          movefeaturenoversion.addFileset(noversionfeatureset);
          movefeaturenoversion.setTodir(new java.io.File(temp + "features/" + "noversion" + "/"));
          movefeaturenoversion.setFlatten(true);
          movefeaturenoversion.perform();  
        }          
        ]]>
      </script>
      <echo file="@{repodir}/temp/repository.config">LayoutPolicy=P1
LayoutPolicyVersion=0.0.0.1
# repository.type=liberty.directory
        </echo>
      <zip destfile="@{repodir}/@{destzip}">
        <fileset dir="@{repodir}/temp/">
          <include name="repository.config"/>
          <include name="addons/**/*.*"/>
          <include name="features/**/*.*"/>
        </fileset>
      </zip>
      <delete dir="@{repodir}/temp"/>
    </sequential>
  </macrodef>

  <!-- This is useful when you need to plug in the value of another property in order to get
       a property name and then want to get the value of that property name. -->
  <macrodef name="propertycopy">
    <attribute name="name"/>
    <attribute name="from"/>
    <sequential>
      <iff>
        <or>
          <equals arg1="${@{from}}" arg2=""/>
          <not>
            <isset property="@{from}"/>
          </not>
        </or>
        <then>
          <fail message="Error occurred when looking up property @{from}." />
        </then>
      </iff>

      <property name="@{name}" value="${@{from}}"/>
    </sequential>
  </macrodef>

  <macrodef name="generateDownloadXmlFromEsas">
    <attribute name="download.xml.output.file"/>
    <attribute name="liberty.base.runtime.jar"/>
    <attribute name="liberty.base.extended.jar"/>
    <sequential>
      <local name="xml.tmp.dir"/>
      <property name="xml.tmp.dir" value ="${build.dir}/tmp/download_xml"/>
      <delete dir="${xml.tmp.dir}" />
      <mkdir dir="${xml.tmp.dir}" />

      <echo message="Creating WDT  download xml file to @{download.xml.output.file} using tmp dir ${xml.tmp.dir}"/>

      <mkdir dir="${xml.tmp.dir}/base-extended" />
      <java jar="@{liberty.base.runtime.jar}" fork="true" failonerror="true">
        <arg value="-acceptLicense" />
        <arg value="${xml.tmp.dir}/base-extended/" />
      </java>
      <java jar="@{liberty.base.extended.jar}" fork="true" failonerror="true">
        <arg value="-acceptLicense" />
        <arg value="${xml.tmp.dir}/base-extended/" />
      </java>

      <mkdir dir="${xml.tmp.dir}/base-runtime" />
      <java jar="@{liberty.base.runtime.jar}" fork="true" failonerror="true">
        <arg value="-acceptLicense" />
        <arg value="${xml.tmp.dir}/base-runtime/" />
      </java>

      <mkdir dir="${xml.tmp.dir}/esas-throw-away"/>
      <createEsas 
                dest.dir="${xml.tmp.dir}/esas-throw-away" 
                wlp.build.dir="${xml.tmp.dir}/base-extended/wlp" 
                wlp.exclude.dir="${xml.tmp.dir}/base-runtime/wlp" 
                editions="BASE,BASE_ILAN,DEVELOPERS,EXPRESS,ND,zOS" 
                download.xml.file="@{download.xml.output.file}"/>

      <echo message="download xml created in ${download.xml.output.file}. Deleting tmp dir ${xml.tmp.dir}"/>
      <delete dir="${xml.tmp.dir}"/>

    </sequential>
  </macrodef>

    
    <macrodef name="verifyChecksum">
        <attribute name="checksum"/>
        <attribute name="file"/>
        <sequential>
            <local name="verify.checksums"/>
            <checksum file="@{file}" property="@{checksum}" algorithm="MD5" verifyproperty="verify.checksums"/>
            <iff>
              <isfalse value="${verify.checksums}"/>
              <then>
                <fail if="verify.checksums" message="The file @{file} has been frozen and should never change. Revert your changes. If in doubt email liberty-dev@mailman.hursley.ibm.com for help." />
              </then>
            </iff>
        </sequential>
    </macrodef>
</project>